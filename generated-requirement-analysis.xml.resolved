<?xml version="1.0" encoding="UTF-8"?>
<RequirementAnalysis xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Metadata>
    <DocumentTitle>Fiservemea Authorize Flow Requirement Analysis</DocumentTitle>
    <ConnectorName>Fiservemea</ConnectorName>
    <ConnectorDisplayName>Authipay Payments API</ConnectorDisplayName>
    <FlowScope>Authorize Only</FlowScope>
    <GeneratedDate>2026-02-12</GeneratedDate>
    <Version>1.0</Version>
    <Architecture>Macro-Based UCS Connector Integration</Architecture>
  </Metadata>

  <!-- ================================================================= -->
  <!-- SECTION 1: TECHNICAL SPECIFICATION SUMMARY                          -->
  <!-- ================================================================= -->
  <TechnicalSpecification>
    <ConnectorInformation>
      <Name>Authipay Payments API</Name>
      <Provider>Fiserv EMEA</Provider>
      <BaseUrls>
        <Production>https://prod.emea.api.fiservapps.com/sandbox/ipp/payments-gateway/v2/payments</Production>
        <Sandbox>https://prod.emea.api.fiservapps.com/sandbox/ipp/payments-gateway/v2/payments</Sandbox>
      </BaseUrls>
    </ConnectorInformation>

    <Authentication>
      <Method>Message Signature Authentication</Method>
      <RequiredHeaders>
        <Header>
          <Name>Content-Type</Name>
          <Value>application/json</Value>
          <Required>true</Required>
        </Header>
        <Header>
          <Name>Api-Key</Name>
          <Description>Key given to merchant after boarding</Description>
          <Required>true</Required>
        </Header>
        <Header>
          <Name>Client-Request-Id</Name>
          <Description>UUID for request tracking and idempotency</Description>
          <Required>true</Required>
        </Header>
        <Header>
          <Name>Timestamp</Name>
          <Description>Epoch timestamp in milliseconds</Description>
          <Required>true</Required>
        </Header>
        <Header>
          <Name>Message-Signature</Name>
          <Description>HMAC-SHA256 signature (Base64 encoded)</Description>
          <Required>true</Required>
        </Header>
        <Header>
          <Name>Message-Authentication-Value</Name>
          <Description>Optional for Card Present transactions</Description>
          <Required>false</Required>
        </Header>
      </RequiredHeaders>

      <SignatureGeneration>
        <Algorithm>HMAC-SHA256</Algorithm>
        <Process>
          <Step>Concatenate: API-Key + ClientRequestId + Timestamp + requestBody</Step>
          <Step>Generate HMAC using API Secret as key</Step>
          <Step>Apply HMAC to concatenated string</Step>
          <Step>Encode result in Base64</Step>
        </Process>
      </SignatureGeneration>
    </Authentication>

    <AuthorizeEndpoint>
      <Url>/sandbox/ipp/payments-gateway/v2/payments</Url>
      <HttpMethod>POST</HttpMethod>
      <RequestType>PaymentCardPreAuthTransaction</RequestType>
      <AlternativeRequestType>PaymentCardSaleTransaction</AlternativeRequestType>
    </AuthorizeEndpoint>

    <AmountFormat>
      <Type>StringMajorUnit</Type>
      <Description>Decimal string with two decimal places (e.g., "100.00")</Description>
      <Examples>
        <Example input="1000" output="10.00"/>
        <Example input="5000" output="50.00"/>
      </Examples>
    </AmountFormat>
  </TechnicalSpecification>

  <!-- ================================================================= -->
  <!-- SECTION 2: FLOW SCOPE AND CONSTRAINTS                               -->
  <!-- ================================================================= -->
  <FlowScope>
    <AllowedFlows>
      <Flow>Authorize</Flow>
    </AllowedFlows>
    <ProhibitedFlows>
      <Flow>Capture</Flow>
      <Flow>Refund</Flow>
      <Flow>Void</Flow>
      <Flow>PSync</Flow>
      <Flow>RSync</Flow>
      <Flow>SetupMandate</Flow>
      <Flow>Any other flow</Flow>
    </ProhibitedFlows>

    <ImplementationConstraints>
      <Constraint>MUST use macro_connector_implementation! macro</Constraint>
      <Constraint>MUST add Authorize flow to create_all_prerequisites! macro FIRST</Constraint>
      <Constraint>MUST NOT manually implement ConnectorIntegrationV2 trait</Constraint>
      <Constraint>MUST use PaymentFlowData as resource_common_data</Constraint>
      <Constraint>MUST use PaymentsAuthorizeData&lt;T&gt; as flow_request</Constraint>
      <Constraint>MUST use PaymentsResponseData as flow_response</Constraint>
      <Constraint>MUST implement ConnectorIntegrationV2&lt;Authorize, PaymentFlowData, PaymentsAuthorizeData&lt;T&gt;, PaymentsResponseData&gt;</Constraint>
    </ImplementationConstraints>
  </FlowScope>

  <!-- ================================================================= -->
  <!-- SECTION 3: MACRO CONFIGURATION                                      -->
  <!-- ================================================================= -->
  <MacroConfiguration>
    <PrerequisitesMacro>
      <MacroName>create_all_prerequisites!</MacroName>
      <ConnectorName>Fiservemea</ConnectorName>
      <GenericType>T</GenericType>
      <AmountConverter>StringMajorUnit</AmountConverter>

      <ApiDefinitions>
        <ApiDefinition>
          <Flow>Authorize</Flow>
          <RequestBody>FiservemeaAuthorizeRequest&lt;T&gt;</RequestBody>
          <ResponseBody>FiservemeaAuthorizeResponse</ResponseBody>
          <RouterData>RouterDataV2&lt;Authorize, PaymentFlowData, PaymentsAuthorizeData&lt;T&gt;, PaymentsResponseData&gt;</RouterData>
        </ApiDefinition>
      </ApiDefinitions>

      <MemberFunctions>
        <Function>
          <Name>build_headers</Name>
          <Signature>pub fn build_headers&lt;F, FCD, Req, Res&gt;(&amp;self, req: &amp;RouterDataV2&lt;F, FCD, Req, Res&gt;) -&gt; CustomResult&lt;Vec&lt;(String, Maskable&lt;String&gt;)&gt;, ConnectorError&gt;</Signature>
          <Description>Build headers with Content-Type and Fiserv signature authentication</Description>
        </Function>
        <Function>
          <Name>connector_base_url_payments</Name>
          <Signature>pub fn connector_base_url_payments&lt;'a, F, Req, Res&gt;(&amp;self, req: &'a RouterDataV2&lt;F, PaymentFlowData, Req, Res&gt;) -&gt; &'a str</Signature>
          <Description>Get base URL for payment operations</Description>
        </Function>
        <Function>
          <Name>generate_client_request_id</Name>
          <Signature>pub fn generate_client_request_id() -&gt; String</Signature>
          <Description>Generate UUID for Client-Request-Id header</Description>
        </Function>
        <Function>
          <Name>generate_timestamp</Name>
          <Signature>pub fn generate_timestamp() -&gt; i64</Signature>
          <Description>Generate current epoch timestamp in milliseconds</Description>
        </Function>
        <Function>
          <Name>generate_message_signature</Name>
          <Signature>pub fn generate_message_signature(api_key: &amp;str, client_request_id: &amp;str, timestamp: i64, request_body: &amp;str, api_secret: &amp;str) -&gt; String</Signature>
          <Description>Generate HMAC-SHA256 signature for Message-Signature header</Description>
        </Function>
      </MemberFunctions>
    </PrerequisitesMacro>

    <ImplementationMacro>
      <MacroName>macro_connector_implementation!</MacroName>
      <ConnectorName>Fiservemea</ConnectorName>
      <FlowName>Authorize</FlowName>

      <DefaultImplementations>
        <Implementation>get_content_type</Implementation>
        <Implementation>get_error_response_v2</Implementation>
      </DefaultImplementations>

      <RequestConfiguration>
        <ContentType>Json</ContentType>
        <RequestType>FiservemeaAuthorizeRequest</RequestType>
        <ResponseType>FiservemeaAuthorizeResponse</ResponseType>
      </RequestConfiguration>

      <FlowDataTypes>
        <ResourceCommonData>PaymentFlowData</ResourceCommonData>
        <FlowRequest>PaymentsAuthorizeData&lt;T&gt;</FlowRequest>
        <FlowResponse>PaymentsResponseData</FlowResponse>
      </FlowDataTypes>

      <HttpMethod>Post</HttpMethod>
      <GenericType>T</GenericType>
      <TraitBounds>PaymentMethodDataTypes + Debug + Sync + Send + 'static + Serialize</TraitBounds>

      <OtherFunctions>
        <Function>
          <Name>get_headers</Name>
          <Implementation>
            fn get_headers(
                &amp;self,
                req: &amp;RouterDataV2&lt;Authorize, PaymentFlowData, PaymentsAuthorizeData&lt;T&gt;, PaymentsResponseData&gt;,
            ) -&gt; CustomResult&lt;Vec&lt;(String, Maskable&lt;String&gt;)&gt;, errors::ConnectorError&gt; {
                self.build_headers(req)
            }
          </Implementation>
        </Function>
        <Function>
          <Name>get_url</Name>
          <Implementation>
            fn get_url(
                &amp;self,
                req: &amp;RouterDataV2&lt;Authorize, PaymentFlowData, PaymentsAuthorizeData&lt;T&gt;, PaymentsResponseData&gt;,
            ) -&gt; CustomResult&lt;String, errors::ConnectorError&gt; {
                let base_url = self.connector_base_url_payments(req);
                Ok(format!("{}/payments", base_url))
            }
          </Implementation>
        </Function>
      </OtherFunctions>
    </ImplementationMacro>
  </MacroConfiguration>

  <!-- ================================================================= -->
  <!-- SECTION 4: REQUEST TRANSFORMATION                                   -->
  <!-- ================================================================= -->
  <RequestTransformation>
    <RequestStruct>
      <Name>FiservemeaAuthorizeRequest&lt;T&gt;</Name>
      <Derives>Debug, Serialize</Derives>
      <SerdeAttributes>
        <Attribute>rename_all = "camelCase"</Attribute>
      </SerdeAttributes>

      <Fields>
        <Field>
          <Name>request_type</Name>
          <Type>String</Type>
          <Required>true</Required>
          <FixedValue>"PaymentCardPreAuthTransaction"</FixedValue>
          <Description>Type of transaction to perform</Description>
        </Field>
        <Field>
          <Name>transaction_amount</Name>
          <Type>FiservemeaTransactionAmount</Type>
          <Required>true</Required>
          <Description>Transaction amount and currency</Description>
        </Field>
        <Field>
          <Name>payment_method</Name>
          <Type>FiservemeaPaymentMethod</Type>
          <Required>true</Required>
          <Description>Payment method details</Description>
        </Field>
        <Field>
          <Name>order</Name>
          <Type>Option&lt;FiservemeaOrder&gt;</Type>
          <Required>false</Required>
          <Description>Order information (optional)</Description>
        </Field>
      </Fields>
    </RequestStruct>

    <NestedStructs>
      <Struct>
        <Name>FiservemeaTransactionAmount</Name>
        <Derives>Debug, Serialize</Derives>
        <SerdeAttributes>
          <Attribute>rename_all = "camelCase"</Attribute>
        </SerdeAttributes>
        <Fields>
          <Field>
            <Name>total</Name>
            <Type>String</Type>
            <Required>true</Required>
            <Description>Total amount in major units (e.g., "100.00")</Description>
          </Field>
          <Field>
            <Name>currency</Name>
            <Type>String</Type>
            <Required>true</Required>
            <Description>ISO 4217 currency code (e.g., "GBP")</Description>
          </Field>
        </Fields>
      </Struct>

      <Struct>
        <Name>FiservemeaPaymentMethod</Name>
        <Derives>Debug, Serialize</Derives>
        <SerdeAttributes>
          <Attribute>rename_all = "camelCase"</Attribute>
        </SerdeAttributes>
        <Fields>
          <Field>
            <Name>payment_card</Name>
            <Type>FiservemeaPaymentCard</Type>
            <Required>true</Required>
            <Description>Card payment details</Description>
          </Field>
        </Fields>
      </Struct>

      <Struct>
        <Name>FiservemeaPaymentCard</Name>
        <Derives>Debug, Serialize</Derives>
        <SerdeAttributes>
          <Attribute>rename_all = "camelCase"</Attribute>
        </SerdeAttributes>
        <Fields>
          <Field>
            <Name>number</Name>
            <Type>Secret&lt;String&gt;</Type>
            <Required>true</Required>
            <Description>Card number</Description>
          </Field>
          <Field>
            <Name>security_code</Name>
            <Type>Secret&lt;String&gt;</Type>
            <Required>true</Required>
            <Description>CVV/CVC code</Description>
          </Field>
          <Field>
            <Name>expiry_date</Name>
            <Type>FiservemeaExpiryDate</Type>
            <Required>true</Required>
            <Description>Card expiry date</Description>
          </Field>
        </Fields>
      </Struct>

      <Struct>
        <Name>FiservemeaExpiryDate</Name>
        <Derives>Debug, Serialize</Derives>
        <SerdeAttributes>
          <Attribute>rename_all = "camelCase"</Attribute>
        </SerdeAttributes>
        <Fields>
          <Field>
            <Name>month</Name>
            <Type>String</Type>
            <Required>true</Required>
            <Description>Expiry month (MM format)</Description>
          </Field>
          <Field>
            <Name>year</Name>
            <Type>String</Type>
            <Required>true</Required>
            <Description>Expiry year (YY format)</Description>
          </Field>
        </Fields>
      </Struct>

      <Struct>
        <Name>FiservemeaOrder</Name>
        <Derives>Debug, Serialize</Derives>
        <SerdeAttributes>
          <Attribute>rename_all = "camelCase"</Attribute>
        </SerdeAttributes>
        <Fields>
          <Field>
            <Name>order_id</Name>
            <Type>String</Type>
            <Required>true</Required>
            <Description>Merchant order ID</Description>
          </Field>
          <Field>
            <Name>billing</Name>
            <Type>Option&lt;FiservemeaBilling&gt;</Type>
            <Required>false</Required>
            <Description>Billing information</Description>
          </Field>
        </Fields>
      </Struct>

      <Struct>
        <Name>FiservemeaBilling</Name>
        <Derives>Debug, Serialize</Derives>
        <SerdeAttributes>
          <Attribute>rename_all = "camelCase"</Attribute>
        </SerdeAttributes>
        <Fields>
          <Field>
            <Name>name</Name>
            <Type>String</Type>
            <Required>true</Required>
            <Description>Customer name</Description>
          </Field>
          <Field>
            <Name>customer_id</Name>
            <Type>Option&lt;String&gt;</Type>
            <Required>false</Required>
            <Description>Customer ID</Description>
          </Field>
        </Fields>
      </Struct>
    </NestedStructs>

    <TryFromImplementation>
      <InputType>FiservemeaRouterData&lt;RouterDataV2&lt;Authorize, PaymentFlowData, PaymentsAuthorizeData&lt;T&gt;, PaymentsResponseData&gt;, T&gt;</InputType>
      <OutputType>FiservemeaAuthorizeRequest&lt;T&gt;</OutputType>
      <ErrorType>error_stack::Report&lt;ConnectorError&gt;</ErrorType>

      <TransformationSteps>
        <Step>
          <Description>Extract router_data and amount from input</Description>
        </Step>
        <Step>
          <Description>Extract payment method data from router_data.request.payment_method_data</Description>
        </Step>
        <Step>
          <Description>Match on PaymentMethodData::Card to extract card details</Description>
        </Step>
        <Step>
          <Description>Build FiservemeaPaymentCard with card number, security code, and expiry date</Description>
        </Step>
        <Step>
          <Description>Build FiservemeaTransactionAmount with converted amount and currency</Description>
        </Step>
        <Step>
          <Description>Build optional FiservemeaOrder with order_id from connector_request_reference_id</Description>
        </Step>
        <Step>
          <Description>Return complete FiservemeaAuthorizeRequest</Description>
        </Step>
      </TransformationSteps>

      <ErrorHandling>
        <ErrorCondition>Non-card payment method</ErrorCondition>
        <ErrorType>ConnectorError::NotImplemented("Only card payments are supported")</ErrorType>
      </ErrorHandling>
    </TryFromImplementation>
  </RequestTransformation>

  <!-- ================================================================= -->
  <!-- SECTION 5: RESPONSE TRANSFORMATION                                  -->
  <!-- ================================================================= -->
  <ResponseTransformation>
    <ResponseStruct>
      <Name>FiservemeaAuthorizeResponse</Name>
      <Derives>Debug, Deserialize</Derives>
      <SerdeAttributes>
        <Attribute>rename_all = "camelCase"</Attribute>
      </SerdeAttributes>

      <Fields>
        <Field>
          <Name>client_request_id</Name>
          <Type>String</Type>
          <Required>true</Required>
          <Description>Echoed Client-Request-Id from request</Description>
        </Field>
        <Field>
          <Name>api_trace_id</Name>
          <Type>String</Type>
          <Required>true</Required>
          <Description>Request identifier for support</Description>
        </Field>
        <Field>
          <Name>ipg_transaction_id</Name>
          <Type>String</Type>
          <Required>true</Required>
          <Description>The response transaction ID</Description>
        </Field>
        <Field>
          <Name>order_id</Name>
          <Type>String</Type>
          <Required>true</Required>
          <Description>Client Order ID</Description>
        </Field>
        <Field>
          <Name>transaction_type</Name>
          <Type>String</Type>
          <Required>true</Required>
          <Description>Type of transaction (PREAUTH, SALE, etc.)</Description>
        </Field>
        <Field>
          <Name>transaction_result</Name>
          <Type>FiservemeaTransactionResult</Type>
          <Required>true</Required>
          <Description>Result of the operation</Description>
        </Field>
        <Field>
          <Name>transaction_state</Name>
          <Type>FiservemeaTransactionState</Type>
          <Required>true</Required>
          <Description>State of the transaction</Description>
        </Field>
        <Field>
          <Name>approval_code</Name>
          <Type>Option&lt;String&gt;</Type>
          <Required>false</Required>
          <Description>Transaction approval code</Description>
        </Field>
        <Field>
          <Name>scheme_response_code</Name>
          <Type>Option&lt;String&gt;</Type>
          <Required>false</Required>
          <Description>Scheme response code</Description>
        </Field>
        <Field>
          <Name>error_message</Name>
          <Type>Option&lt;String&gt;</Type>
          <Required>false</Required>
          <Description>Error message if transaction failed</Description>
        </Field>
        <Field>
          <Name>processor</Name>
          <Type>Option&lt;FiservemeaProcessor&gt;</Type>
          <Required>false</Required>
          <Description>Processor response data</Description>
        </Field>
        <Field>
          <Name>error</Name>
          <Type>Option&lt;FiservemeaErrorDetail&gt;</Type>
          <Required>false</Required>
          <Description>Error details for declined transactions</Description>
        </Field>
      </Fields>
    </ResponseStruct>

    <ResponseEnums>
      <Enum>
        <Name>FiservemeaTransactionResult</Name>
        <Derives>Debug, Deserialize</Derives>
        <SerdeAttributes>
          <Attribute>rename_all = "SCREAMING_SNAKE_CASE"</Attribute>
        </SerdeAttributes>
        <Variants>
          <Variant>Approved</Variant>
          <Variant>Declined</Variant>
          <Variant>Failed</Variant>
          <Variant>Waiting</Variant>
          <Variant>Partial</Variant>
          <Variant>Fraud</Variant>
        </Variants>
      </Enum>

      <Enum>
        <Name>FiservemeaTransactionState</Name>
        <Derives>Debug, Deserialize</Derives>
        <SerdeAttributes>
          <Attribute>rename_all = "SCREAMING_SNAKE_CASE"</Attribute>
        </SerdeAttributes>
        <Variants>
          <Variant>Authorized</Variant>
          <Variant>Captured</Variant>
          <Variant>Declined</Variant>
          <Variant>Pending</Variant>
          <Variant>Settled</Variant>
          <Variant>Voided</Variant>
          <Variant>Waiting</Variant>
        </Variants>
      </Enum>

      <Struct>
        <Name>FiservemeaProcessor</Name>
        <Derives>Debug, Deserialize</Derives>
        <SerdeAttributes>
          <Attribute>rename_all = "camelCase"</Attribute>
        </SerdeAttributes>
        <Fields>
          <Field>
            <Name>authorization_code</Name>
            <Type>Option&lt;String&gt;</Type>
          </Field>
          <Field>
            <Name>response_code</Name>
            <Type>Option&lt;String&gt;</Type>
          </Field>
          <Field>
            <Name>response_message</Name>
            <Type>Option&lt;String&gt;</Type>
          </Field>
          <Field>
            <Name>association_response_code</Name>
            <Type>Option&lt;String&gt;</Type>
          </Field>
          <Field>
            <Name>association_response_message</Name>
            <Type>Option&lt;String&gt;</Type>
          </Field>
        </Fields>
      </Struct>

      <Struct>
        <Name>FiservemeaErrorDetail</Name>
        <Derives>Debug, Deserialize</Derives>
        <SerdeAttributes>
          <Attribute>rename_all = "camelCase"</Attribute>
        </SerdeAttributes>
        <Fields>
          <Field>
            <Name>code</Name>
            <Type>String</Type>
          </Field>
          <Field>
            <Name>message</Name>
            <Type>String</Type>
          </Field>
          <Field>
            <Name>decline_reason_code</Name>
            <Type>Option&lt;String&gt;</Type>
          </Field>
        </Fields>
      </Struct>
    </ResponseEnums>

    <TryFromImplementation>
      <InputType>ResponseRouterData&lt;FiservemeaAuthorizeResponse, RouterDataV2&lt;Authorize, PaymentFlowData, PaymentsAuthorizeData&lt;T&gt;, PaymentsResponseData&gt;&gt;</InputType>
      <OutputType>RouterDataV2&lt;Authorize, PaymentFlowData, PaymentsAuthorizeData&lt;T&gt;, PaymentsResponseData&gt;</OutputType>
      <ErrorType>error_stack::Report&lt;ConnectorError&gt;</ErrorType>

      <TransformationSteps>
        <Step>
          <Description>Extract response and router_data from input</Description>
        </Step>
        <Step>
          <Description>Map transaction_result and transaction_state to AttemptStatus using mapping function</Description>
        </Step>
        <Step>
          <Description>Build PaymentsResponseData::TransactionResponse with:</Description>
          <SubSteps>
            <SubStep>resource_id: ResponseId::ConnectorTransactionId(ipg_transaction_id)</SubStep>
            <SubStep>redirection_data: None</SubStep>
            <SubStep>mandate_reference: None</SubStep>
            <SubStep>connector_metadata: None</SubStep>
            <SubStep>network_txn_id: None</SubStep>
            <SubStep>connector_response_reference_id: Some(order_id)</SubStep>
            <SubStep>incremental_authorization_allowed: None</SubStep>
            <SubStep>status_code: item.http_code</SubStep>
          </SubSteps>
        </Step>
        <Step>
          <Description>Return RouterDataV2 with updated resource_common_data.status and response</Description>
        </Step>
      </TransformationSteps>
    </TryFromImplementation>
  </ResponseTransformation>

  <!-- ================================================================= -->
  <!-- SECTION 6: STATUS MAPPING                                           -->
  <!-- ================================================================= -->
  <StatusMapping>
    <MappingFunction>
      <Name>map_fiservemea_status_to_attempt_status</Name>
      <Input>&amp;FiservemeaTransactionResult</Input>
      <Output>common_enums::AttemptStatus</Output>
      <Implementation>
        <Code>
          pub fn map_fiservemea_status_to_attempt_status(
              transaction_result: &amp;FiservemeaTransactionResult,
              transaction_state: &amp;FiservemeaTransactionState,
          ) -&gt; common_enums::AttemptStatus {
              match (transaction_result, transaction_state) {
                  // Approved transactions
                  (FiservemeaTransactionResult::Approved, FiservemeaTransactionState::Authorized) =&gt;
                      common_enums::AttemptStatus::Authorized,
                  (FiservemeaTransactionResult::Approved, FiservemeaTransactionState::Captured) =&gt;
                      common_enums::AttemptStatus::Charged,
                  
                  // Pending/waiting transactions
                  (FiservemeaTransactionResult::Waiting, _) |
                  (FiservemeaTransactionResult::Approved, FiservemeaTransactionState::Pending) |
                  (FiservemeaTransactionResult::Approved, FiservemeaTransactionState::Waiting) =&gt;
                      common_enums::AttemptStatus::Pending,
                  
                  // Declined/failed transactions
                  (FiservemeaTransactionResult::Declined, _) |
                  (FiservemeaTransactionResult::Failed, _) |
                  (_, FiservemeaTransactionState::Declined) =&gt;
                      common_enums::AttemptStatus::Failure,
                  
                  // Fraud transactions
                  (FiservemeaTransactionResult::Fraud, _) =&gt;
                      common_enums::AttemptStatus::Failure,
                  
                  // Default to failure for unknown states
                  _ =&gt; common_enums::AttemptStatus::Failure,
              }
          }
        </Code>
      </Implementation>
    </MappingFunction>

    <MappingRules>
      <Rule>ALWAYS create dedicated status enums (FiservemeaTransactionResult, FiservemeaTransactionState)</Rule>
      <Rule>ALWAYS use mapping function in response transformers</Rule>
      <Rule>NEVER hardcode status values</Rule>
      <Rule>Map ALL possible connector status values from API docs</Rule>
      <Rule>Consider both transaction_result AND transaction_state for accurate mapping</Rule>
    </MappingRules>

    <StatusMatrix>
      <Row>
        <TransactionResult>Approved</TransactionResult>
        <TransactionState>Authorized</TransactionState>
        <AttemptStatus>Authorized</AttemptStatus>
      </Row>
      <Row>
        <TransactionResult>Approved</TransactionResult>
        <TransactionState>Captured</TransactionState>
        <AttemptStatus>Charged</AttemptStatus>
      </Row>
      <Row>
        <TransactionResult>Approved</TransactionResult>
        <TransactionState>Pending</TransactionState>
        <AttemptStatus>Pending</AttemptStatus>
      </Row>
      <Row>
        <TransactionResult>Waiting</TransactionResult>
        <TransactionState>*</TransactionState>
        <AttemptStatus>Pending</AttemptStatus>
      </Row>
      <Row>
        <TransactionResult>Declined</TransactionResult>
        <TransactionState>*</TransactionState>
        <AttemptStatus>Failure</AttemptStatus>
      </Row>
      <Row>
        <TransactionResult>Failed</TransactionResult>
        <TransactionState>*</TransactionState>
        <AttemptStatus>Failure</AttemptStatus>
      </Row>
      <Row>
        <TransactionResult>Fraud</TransactionResult>
        <TransactionState>*</TransactionState>
        <AttemptStatus>Failure</AttemptStatus>
      </Row>
    </StatusMatrix>
  </StatusMapping>

  <!-- ================================================================= -->
  <!-- SECTION 7: ERROR HANDLING                                           -->
  <!-- ================================================================= -->
  <ErrorHandling>
    <ErrorResponseStruct>
      <Name>FiservemeaErrorResponse</Name>
      <Derives>Debug, Deserialize</Derives>
      <SerdeAttributes>
        <Attribute>rename_all = "camelCase"</Attribute>
      </SerdeAttributes>
      <Fields>
        <Field>
          <Name>client_request_id</Name>
          <Type>String</Type>
        </Field>
        <Field>
          <Name>api_trace_id</Name>
          <Type>String</Type>
        </Field>
        <Field>
          <Name>response_type</Name>
          <Type>FiservemeaResponseType</Type>
        </Field>
        <Field>
          <Name>error</Name>
          <Type>FiservemeaErrorDetail</Type>
        </Field>
      </Fields>
    </ErrorResponseStruct>

    <ResponseTypeEnum>
      <Name>FiservemeaResponseType</Name>
      <Derives>Debug, Deserialize</Derives>
      <Variants>
        <Variant>BadRequest</Variant>
        <Variant>Unauthenticated</Variant>
        <Variant>Unauthorized</Variant>
        <Variant>NotFound</Variant>
        <Variant>GatewayDeclined</Variant>
        <Variant>EndpointDeclined</Variant>
        <Variant>ServerError</Variant>
        <Variant>EndpointCommunicationError</Variant>
        <Variant>UnsupportedMediaType</Variant>
      </Variants>
    </ResponseTypeEnum>

    <ErrorMapping>
      <Mapping>
        <ResponseType>BadRequest</ResponseType>
        <HttpStatusCode>400</HttpStatusCode>
        <AttemptStatus>Failure</AttemptStatus>
      </Mapping>
      <Mapping>
        <ResponseType>Unauthenticated</ResponseType>
        <HttpStatusCode>401</HttpStatusCode>
        <AttemptStatus>AuthenticationFailed</AttemptStatus>
      </Mapping>
      <Mapping>
        <ResponseType>Unauthorized</ResponseType>
        <HttpStatusCode>403</HttpStatusCode>
        <AttemptStatus>AuthorizationFailed</AttemptStatus>
      </Mapping>
      <Mapping>
        <ResponseType>NotFound</ResponseType>
        <HttpStatusCode>404</HttpStatusCode>
        <AttemptStatus>Failure</AttemptStatus>
      </Mapping>
      <Mapping>
        <ResponseType>GatewayDeclined</ResponseType>
        <HttpStatusCode>409</HttpStatusCode>
        <AttemptStatus>Failure</AttemptStatus>
      </Mapping>
      <Mapping>
        <ResponseType>EndpointDeclined</ResponseType>
        <HttpStatusCode>422</HttpStatusCode>
        <AttemptStatus>Failure</AttemptStatus>
      </Mapping>
      <Mapping>
        <ResponseType>ServerError</ResponseType>
        <HttpStatusCode>500</HttpStatusCode>
        <AttemptStatus>Pending</AttemptStatus>
      </Mapping>
      <Mapping>
        <ResponseType>EndpointCommunicationError</ResponseType>
        <HttpStatusCode>502</HttpStatusCode>
        <AttemptStatus>Pending</AttemptStatus>
      </Mapping>
    </ErrorMapping>

    <BuildErrorResponseImplementation>
      <Signature>fn build_error_response(&amp;self, res: Response, event_builder: Option&lt;&amp;mut Event&gt;) -&gt; CustomResult&lt;ErrorResponse, ConnectorError&gt;</Signature>
      <Logic>
        <Step>Parse response as FiservemeaErrorResponse</Step>
        <Step>Set error response body in event_builder if provided</Step>
        <Step>Map response_type to attempt_status</Step>
        <Step>Extract error code, message, and decline_reason_code</Step>
        <Step>Return ErrorResponse with all fields populated</Step>
      </Logic>
    </BuildErrorResponseImplementation>
  </ErrorHandling>

  <!-- ================================================================= -->
  <!-- SECTION 8: AUTHENTICATION TYPE                                      -->
  <!-- ================================================================= -->
  <AuthenticationType>
    <AuthStruct>
      <Name>FiservemeaAuthType</Name>
      <Derives>Debug, Clone</Derives>
      <Fields>
        <Field>
          <Name>api_key</Name>
          <Type>Secret&lt;String&gt;</Type>
          <Description>API Key for authentication</Description>
        </Field>
        <Field>
          <Name>api_secret</Name>
          <Type>Secret&lt;String&gt;</Type>
          <Description>API Secret for signature generation</Description>
        </Field>
      </Fields>
    </AuthStruct>

    <TryFromImplementation>
      <SourceType>&amp;ConnectorAuthType</SourceType>
      <TargetType>FiservemeaAuthType</TargetType>
      <ErrorType>ConnectorError</ErrorType>
      <Matching>
        <MatchOn>ConnectorAuthType::SignatureKey { api_key, api_secret, .. }</MatchOn>
        <Construction>
          api_key: api_key.clone(),
          api_secret: api_secret.clone(),
        </Construction>
      </Matching>
      <FallbackError>ConnectorError::FailedToObtainAuthType</FallbackError>
    </TryFromImplementation>

    <SignatureGenerationHelper>
      <FunctionName>generate_message_signature</FunctionName>
      <Signature>pub fn generate_message_signature(api_key: &amp;str, client_request_id: &amp;str, timestamp: i64, request_body: &amp;str, api_secret: &amp;str) -&gt; String</Signature>
      <Implementation>
        <Step>Concatenate: api_key + client_request_id + &amp;timestamp.to_string() + request_body</Step>
        <Step>Create HMAC-SHA256 using api_secret as key</Step>
        <Step>Apply HMAC to concatenated string</Step>
        <Step>Encode result in Base64</Step>
        <Step>Return Base64 encoded signature</Step>
      </Implementation>
      <Dependencies>
        <Dependency>hmac</Dependency>
        <Dependency>sha2</Dependency>
        <Dependency>base64</Dependency>
      </Dependencies>
    </SignatureGenerationHelper>
  </AuthenticationType>

  <!-- ================================================================= -->
  <!-- SECTION 9: FILE STRUCTURE                                            -->
  <!-- ================================================================= -->
  <FileStructure>
    <Files>
      <File>
        <Path>backend/connector-integration/src/connectors/fiservemea.rs</Path>
        <Description>Main connector implementation file</Description>
        <Contents>
          <Content>Module declaration for transformers</Content>
          <Content>Imports from domain_types, common_utils, interfaces</Content>
          <Content>Trait implementations (ConnectorServiceTrait, PaymentAuthorizeV2)</Content>
          <Content>create_all_prerequisites! macro invocation</Content>
          <Content>macro_connector_implementation! for Authorize flow</Content>
          <Content>ConnectorCommon trait implementation</Content>
          <Content>Empty trait implementations for unsupported flows</Content>
        </Contents>
      </File>
      <File>
        <Path>backend/connector-integration/src/connectors/fiservemea/transformers.rs</Path>
        <Description>Data transformation logic file</Description>
        <Contents>
          <Content>FiservemeaAuthType struct and TryFrom implementation</Content>
          <Content>FiservemeaErrorResponse struct</Content>
          <Content>Request structs (FiservemeaAuthorizeRequest and nested structs)</Content>
          <Content>Response structs (FiservemeaAuthorizeResponse and nested structs)</Content>
          <Content>Status enums (FiservemeaTransactionResult, FiservemeaTransactionState)</Content>
          <Content>Status mapping function (map_fiservemea_status_to_attempt_status)</Content>
          <Content>TryFrom implementation for request transformation</Content>
          <Content>TryFrom implementation for response transformation</Content>
          <Content>Helper functions for signature generation</Content>
        </Contents>
      </File>
    </Files>
  </FileStructure>

  <!-- ================================================================= -->
  <!-- SECTION 10: IMPLEMENTATION CHECKLIST                                -->
  <!-- ================================================================= -->
  <ImplementationChecklist>
    <Phase name="Pre-Implementation">
      <Task status="pending">Read and understand technical specification</Task>
      <Task status="pending">Read pattern_authorize.md for authorize flow patterns</Task>
      <Task status="pending">Read macro_patterns_reference.md for macro usage</Task>
      <Task status="pending">Review Airwallex reference implementation</Task>
      <Task status="pending">Understand Fiserv signature authentication mechanism</Task>
    </Phase>

    <Phase name="File Creation">
      <Task status="pending">Create fiservemea.rs main connector file</Task>
      <Task status="pending">Create fiservemea directory</Task>
      <Task status="pending">Create fiservemea/transformers.rs file</Task>
    </Phase>

    <Phase name="Transformers Implementation">
      <Task status="pending">Define FiservemeaAuthType struct</Task>
      <Task status="pending">Implement TryFrom&lt;&amp;ConnectorAuthType&gt; for FiservemeaAuthType</Task>
      <Task status="pending">Define FiservemeaErrorResponse struct</Task>
      <Task status="pending">Define all request structs (FiservemeaAuthorizeRequest, nested structs)</Task>
      <Task status="pending">Define all response structs (FiservemeaAuthorizeResponse, nested structs)</Task>
      <Task status="pending">Define status enums (FiservemeaTransactionResult, FiservemeaTransactionState)</Task>
      <Task status="pending">Implement map_fiservemea_status_to_attempt_status function</Task>
      <Task status="pending">Implement TryFrom for request transformation</Task>
      <Task status="pending">Implement TryFrom for response transformation</Task>
      <Task status="pending">Implement signature generation helper functions</Task>
    </Phase>

    <Phase name="Main Connector Implementation">
      <Task status="pending">Add all necessary imports</Task>
      <Task status="pending">Implement trait markers (ConnectorServiceTrait, PaymentAuthorizeV2)</Task>
      <Task status="pending">Add Authorize flow to create_all_prerequisites! macro</Task>
      <Task status="pending">Implement member functions (build_headers, connector_base_url_payments, etc.)</Task>
      <Task status="pending">Implement macro_connector_implementation! for Authorize flow</Task>
      <Task status="pending">Implement ConnectorCommon trait</Task>
      <Task status="pending">Add empty implementations for unsupported flows</Task>
    </Phase>

    <Phase name="Validation">
      <Task status="pending">Run cargo build and fix compilation errors</Task>
      <Task status="pending">Run cargo clippy and fix warnings</Task>
      <Task status="pending">Verify no unwrap/expect calls</Task>
      <Task status="pending">Verify no TODO/FIXME comments</Task>
      <Task status="pending">Verify status mapping is derived from response</Task>
      <Task status="pending">Verify only Authorize flow is implemented</Task>
    </Phase>

    <Phase name="Final Steps">
      <Task status="pending">Mark generated-requirement-analysis.xml as resolved</Task>
      <Task status="pending">Verify project compiles and runs without errors</Task>
    </Phase>
  </ImplementationChecklist>

  <!-- ================================================================= -->
  <!-- SECTION 11: CODE QUALITY RULES                                      -->
  <!-- ================================================================= -->
  <CodeQualityRules>
    <CriticalRules>
      <Rule>NEVER manually implement ConnectorIntegrationV2 - ALWAYS use macros</Rule>
      <Rule>ALWAYS add flow to create_all_prerequisites! before using macro_connector_implementation!</Rule>
      <Rule>Flow name MUST match exactly in both macros</Rule>
      <Rule>Request/Response types MUST match between macro and transformers</Rule>
      <Rule>ALWAYS use domain_types imports (not hyperswitch_*)</Rule>
      <Rule>ALWAYS use RouterDataV2 (not RouterData)</Rule>
      <Rule>Generic &lt;T&gt; needed for Authorize flow</Rule>
      <Rule>POST endpoints: always include curl_request parameter in macro</Rule>
      <Rule>Remove all fields hardcoded to None - if always None, delete the field</Rule>
      <Rule>Don't use Option unless truly optional per API spec</Rule>
      <Rule>NEVER hardcode status - always derive from connector response</Rule>
      <Rule>Use specific NotSupported errors with exact feature names</Rule>
      <Rule>Only include fields actually used by the connector API</Rule>
    </CriticalRules>

    <SerdeRules>
      <Rule>Rust fields: snake_case</Rule>
      <Rule>JSON: camelCase using #[serde(rename_all = "camelCase")]</Rule>
      <Rule>Use Secret&lt;T&gt; for sensitive fields (card numbers, CVV, API keys)</Rule>
      <Rule>Use Maskable&lt;T&gt; for headers containing sensitive data</Rule>
    </SerdeRules>

    <Prohibitions>
      <Item>Implementing any flow other than Authorize</Item>
      <Item>Manually implementing ConnectorIntegrationV2 trait</Item>
      <Item>Mocked responses</Item>
      <Item>unwrap / expect</Item>
      <Item>Returning success on error</Item>
      <Item>Code that does not compile</Item>
      <Item>Skipping macro-based approach</Item>
      <Item>Adding fields "just in case"</Item>
      <Item>TODO or FIXME comments</Item>
    </Prohibitions>
  </CodeQualityRules>

  <!-- ================================================================= -->
  <!-- SECTION 12: DELIVERABLES                                             -->
  <!-- ================================================================= -->
  <Deliverables>
    <Deliverable>
      <Name>Main Connector File</Name>
      <Path>backend/connector-integration/src/connectors/fiservemea.rs</Path>
      <Description>Complete macro-based connector implementation for Authorize flow</Description>
    </Deliverable>
    <Deliverable>
      <Name>Transformers File</Name>
      <Path>backend/connector-integration/src/connectors/fiservemea/transformers.rs</Path>
      <Description>Request/response transformation logic with status mapping</Description>
    </Deliverable>
    <Deliverable>
      <Name>Resolved Requirement Analysis</Name>
      <Path>generated-requirement-analysis.xml.resolved</Path>
      <Description>Marked as resolved after all tasks completed</Description>
    </Deliverable>
  </Deliverables>

  <!-- ================================================================= -->
  <!-- SECTION 13: FINAL VALIDATION                                         -->
  <!-- ================================================================= -->
  <FinalValidation>
    <SelfChecks>
      <Check>ONLY Authorize flow implemented</Check>
      <Check>create_all_prerequisites! macro updated with Authorize flow</Check>
      <Check>macro_connector_implementation! used for Authorize flow</Check>
      <Check>Request/Response types defined in transformers.rs</Check>
      <Check>Status mapping function implemented</Check>
      <Check>cargo build succeeds</Check>
      <Check>cargo clippy passes</Check>
      <Check>No unwrap/expect calls</Check>
      <Check>No TODO/FIXME comments</Check>
      <Check>Status derived from connector response (not hardcoded)</Check>
      <Check>generated-requirement-analysis.xml marked as resolved</Check>
    </SelfChecks>

    <BuildCommands>
      <Command>cargo build</Command>
      <Command>cargo clippy -- -D warnings</Command>
      <Command>cargo test</Command>
    </BuildCommands>
  </FinalValidation>
</RequirementAnalysis>