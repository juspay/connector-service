# PhonePe UPI Integration Analysis Documentation

## Table of Contents
1. [Overview](#overview)
2. [Entry Points and Flow Routing](#entry-points-and-flow-routing)
3. [Request Body Structures](#request-body-structures)
4. [Response Body Structures](#response-body-structures)
5. [Parameter Transformation Details](#parameter-transformation-details)
6. [API Integration Details](#api-integration-details)
7. [Implementation Steps](#implementation-steps)
8. [Key Files Reference](#key-files-reference)

## Overview

The PhonePe UPI integration supports three payment methods:
- **UPI Collect**: Push notification mechanism where merchant sends payment request to customer's VPA
- **UPI Intent**: Deep links that redirect customers to specific UPI apps for payment
- **UPI QR**: QR code generation that customers scan with their UPI apps

### Architecture Pattern
- **UPI Collect**: Separate transaction flow via `UPI_COLLECT` transaction type
- **UPI Intent/QR**: Handled through `getSdkParams` function with `sourceObject` differentiation
- All methods use PhonePe V2 API with base64-encoded JSON payloads

## Entry Points and Flow Routing

### 1. getSdkParams Function (Intent & QR)
**Location**: `./euler-x/src-generated/Gateway/PhonePe/Flow.hs:4380`

**Function Signature**:
```haskell
getSdkParams :: SecondFactor -> OrderReference -> TxnDetail -> MerchantGatewayAccount -> TransactionCreateReq -> MerchantAccount -> TestMode -> OrderMetadataV2 -> Maybe SubscriptionResponse -> Maybe Customer -> Bool -> TxnCardInfo -> BackendFlow st Configs (Either ErrorPaymentResp SdkParams)
```

**UPI Flow Routing Logic**:
```haskell
Just UPI -> do
  isV2IntegrationEnabled <- isPhonepeIntegrationV2 merchantGatewayAccount phonepeDetails
  if ((txnDetail ^. L._sourceObject == just ("UPI_PAY" :: Text)) && isV2IntegrationEnabled)
    then callPhonepeIntegrationV2UpiIntentFlow phonepeDetails sf orderReference txnDetail meshEnabled testMode cust txnCardInfo orderMetadataV2
    else if (txnDetail ^. L._sourceObject == just ("UPI_QR" :: Text)) && isV2IntegrationEnabled  
      then phonepeV2UpiQRFlow phonepeDetails sf orderReference txnDetail meshEnabled testMode cust orderMetadataV2 txnCardInfo
      else -- Other UPI flows including legacy
```

**Key Decision Points**:
- `txnDetail.sourceObject == "UPI_PAY"` → UPI Intent Flow
- `txnDetail.sourceObject == "UPI_QR"` → UPI QR Flow  
- `isV2IntegrationEnabled` must be true for both flows
[/Users/utkarsh.pandey/Documents/repo/euler-api-txns/paytm-upi-integration-analysis.md](file:///Users/utkarsh.pandey/Documents/repo/euler-api-txns/paytm-upi-integration-analysis.md)
### 2. UPI Collect Entry Point
**Location**: `./oltp/src-generated/Product/OLTP/Transaction.hs:4132`

**Transaction Type Routing**:
```haskell
UPI_COLLECT -> sendCollectRequest req updTxn updOrd mga pm sf gw mAccnt meshEnabled orderMetaData cust mandate orderBasket txnIntentTrackingDetails.mTxnIntentDetail mMAD cardInfo
```

**Gateway Specific Routing** (`./euler-x/src-generated/Gateway/CommonGateway.hs:3082`):
```haskell
PG.PHONEPE -> PhonePe.sendCollectRequest txnDetail order gatewayAccount txnCardInfo meshEnabled maybeCust secondFactor orderMetadataV2
```

## Request Body Structures

### UPI Intent Request Structure
**Generated by**: `makePhonepeUpiIntentV2Payload` in `./euler-x/src-generated/Gateway/PhonePe/Transforms.hs:1445`

```json
{
  "merchantId": "string",           // From phonepeDetails.phonepeMerchantId
  "merchantTransactionId": "string", // From txnDetail.txnId
  "merchantUserId": "string|null",   // From orderReference.customerId
  "amount": 12345,                   // Transaction amount in paisa
  "callbackUrl": "string",           // Generated webhook URL
  "mobileNumber": "string|null",     // Customer mobile number
  "deviceContext": {
    "deviceOS": "string"             // Detected from request headers
  },
  "paymentInstrument": {
    "type": "UPI_INTENT",
    "targetApp": "string|null"       // Specific UPI app preference
  }
}
```

### UPI QR Request Structure  
**Generated by**: `makePhonepeUpiQRV2Payload` in `./euler-x/src-generated/Gateway/PhonePe/Transforms.hs:1708`

```json
{
  "merchantId": "string",           
  "merchantTransactionId": "string",
  "merchantUserId": "string|null", 
  "amount": 12345,                   
  "callbackUrl": "string",           
  "mobileNumber": "string|null",     
  "paymentInstrument": {
    "type": "UPI_QR"                // No targetApp or deviceContext needed
  }
}
```

### UPI Collect Request Structure
**Generated by**: `phonepeUpiCollectPayLoad` in `./euler-x/src-generated/Gateway/PhonePe/Transforms.hs:1409`

```json
{
  "merchantId": "string",           
  "merchantTransactionId": "string",
  "merchantUserId": "string|null", 
  "amount": 12345,                   
  "callbackUrl": "string",           
  "mobileNumber": "string|null",     
  "paymentInstrument": {
    "type": "UPI_COLLECT",
    "vpa": "customer@upi"            // Customer's Virtual Payment Address
  }
}
```

## Response Body Structures

### UPI Intent Response
**Type**: `PhonePeV2UpiIntentResponse` in `./euler-x/src-generated/Gateway/PhonePe/Types.hs`

**Success Response**:
```json
{
  "success": true,
  "code": "string",                  // Status code from PhonePe
  "message": "string",               // Status message
  "data": {
    "merchantId": "string",
    "merchantTransactionId": "string", 
    "instrumentResponse": {
      "type": "UPI_INTENT",
      "intentUrl": "upi://pay?..."   // Deep link for UPI app
    },
    "responseCode": "string|null",
    "responseCodeDescription": "string|null",
    "payResponseCode": "string|null",
    "payResponseCodeDescription": "string|null",
    "transactionDetails": {          // Optional
      "payResponseCode": "string|null",
      "payResponseCodeDescription": "string|null"
    }
  }
}
```

**Error Response**:
```json
{
  "success": false,
  "code": "string",                  // Error code
  "message": "string|null"           // Error message
}
```

### UPI QR Response
**Type**: `PhonePeV2UpiQRResponse` in `./euler-x/src-generated/Gateway/PhonePe/Types.hs`

**Success Response**:
```json
{
  "success": true,
  "code": "string",
  "message": "string", 
  "data": {
    "merchantId": "string",
    "merchantTransactionId": "string",
    "instrumentResponse": {
      "type": "UPI_QR", 
      "qrData": "upi://pay?...",      // QR code data
      "intentUrl": "string|null"      // Optional intent URL
    },
    "responseCode": "string|null",
    "responseCodeDescription": "string|null",
    "payResponseCode": "string|null",
    "payResponseCodeDescription": "string|null"
  }
}
```

### UPI Collect Response
**Type**: `PhonePeUpiCollectResponse` in `./euler-x/src-generated/Gateway/PhonePe/Types.hs`

```json
{
  "code": 200,                       // HTTP status code
  "status": "string",                // Status string
  "response": {
    // Either PhonePeUpiCollectValidResponse or PhonePeV2ErrorResponse
    // Structure similar to Intent/QR responses
  }
}
```

## Parameter Transformation Details

### Step-by-Step Transformation Process

#### 1. Amount Calculation
**Function**: `getMoney` in `./euler-x/src-generated/Gateway/PhonePe/Transforms.hs:1741`
```haskell
getMoney :: TxnDetail -> OrderReference -> BackendFlow st Configs Int
```
- Extracts amount from transaction detail
- Handles Money Framework integration
- Converts to paisa (smallest currency unit)
- **Result**: `amount` field in request

#### 2. Customer Mobile Number Extraction
**Function**: `getCustomerMobileNumber` in `./euler-x/src-generated/Gateway/PhonePe/Transforms.hs:1501`
```haskell
getCustomerMobileNumber :: OrderReference -> Maybe Customer -> Maybe Text
```
- Precedence: Customer record > Order record
- Validates phone number format
- **Function**: `removeDefaultPhoneNumber` filters invalid/default numbers
- **Result**: `mobileNumber` field in request

#### 3. Webhook URL Generation
**Function**: `getWebhookUrl` in `./euler-x/src-generated/Gateway/PhonePe/Transforms.hs:472`
```haskell
getWebhookUrl :: TxnDetail -> BackendFlow st Configs Text
```
- Generates callback URL for payment status updates
- Includes transaction ID and gateway information
- **Result**: `callbackUrl` field in request

#### 4. Device Context (Intent Only)
**Function**: `getSdkOSfromRequestHeader` 
```haskell
getSdkOSfromRequestHeader :: BackendFlow st Configs (Maybe Text)
```
- Extracts OS information from HTTP headers
- Used for `deviceContext.deviceOS` in Intent requests
- **Function**: `getPhonepeIntegrationV2DeviceContext` creates the context object

#### 5. Payment Instrument Creation

**For UPI Intent**:
```haskell
getPhonepeIntegrationV2PaymentInstrument :: TxnCardInfo -> Maybe Text -> PhonePeV2UpiPaymentInstrument
```
- Sets `type` to "UPI_INTENT"
- Extracts `targetApp` from transaction card info

**For UPI QR**:
```haskell
getPhonepeIntegrationV2QRPaymentInstrument :: PhonePeV2UpiPaymentInstrument
```
- Sets `type` to "UPI_QR"
- No additional parameters needed

**For UPI Collect**:
```haskell
makeUPICollectpaymentInstrument :: Text -> UPICollectpaymentInstrument
```
- Sets `type` to "UPI_COLLECT"
- Includes customer's VPA from `txnCardInfo.paymentSource`

### Key Data Sources

| Request Field | Source | Transformation Function |
|---------------|--------|------------------------|
| `merchantId` | `phonepeDetails.phonepeMerchantId` | Direct mapping |
| `merchantTransactionId` | `txnDetail.txnId` | Direct mapping |
| `merchantUserId` | `orderReference.customerId` | Direct mapping |
| `amount` | `txnDetail` + `orderReference` | `getMoney` |
| `callbackUrl` | Generated | `getWebhookUrl` |
| `mobileNumber` | `orderReference` + `customer` | `getCustomerMobileNumber` |
| `deviceOS` | HTTP headers | `getSdkOSfromRequestHeader` |
| `vpa` | `txnCardInfo.paymentSource` | `isVpaAvaiableToCallCollect` |

## API Integration Details

### Request Preparation Process

#### 1. Payload Creation and Encoding
```haskell
-- Step 1: Create raw payload object
rawPayload <- makePhonepeUpiIntentV2Payload phonepeDetails ord txn meshEnabled maybeCust txnCardInfo

-- Step 2: Convert to JSON
jsonPayload = encodeJSON rawPayload

-- Step 3: Base64 encode the JSON
encPayload <- encodeBase64 jsonPayload

-- Step 4: Create request wrapper
request = makePhonepeUpiIntentV2Request encPayload
-- Results in: { "request": "base64EncodedJsonPayload" }
```

#### 2. Header Generation
**Functions**: Various header generation functions in `./euler-x/src-generated/Gateway/PhonePe/Transforms.hs`

```haskell
-- For UPI Intent V2
makePhonepeUpiIntentIntegrationV2ApiHeader :: PhonepeDetails -> Text -> TxnDetail -> OrderMetadataV2 -> TxnCardInfo -> BackendFlow st Configs Headers

-- For UPI Collect  
makePhonepeUpiCollectHeader :: PhonepeDetails -> Text -> OrderMetadataV2 -> TxnCardInfo -> TxnDetail -> BackendFlow st Configs Headers
```

**Header Components**:
- `Content-Type`: `application/json`
- `X-VERIFY`: Checksum for request verification
- Additional authentication headers

#### 3. Checksum Generation
**Function**: `getCheckSumforV2API` in `./euler-x/src-generated/Gateway/PhonePe/Transforms.hs:1441`

**Algorithm**:
```
checksum = base64(sha256(base64EncodedPayload + saltKey + merchantId))
```

Where:
- `base64EncodedPayload`: The request payload encoded in base64
- `saltKey`: PhonePe provided salt key from `phonepeDetails`
- `merchantId`: PhonePe merchant identifier

### API Endpoints and Methods

#### 1. UPI Intent API
**Function**: `initPhonepeIntegrationV2UpiIntent`
- **Method**: POST
- **Endpoint**: PhonePe V2 UPI Intent endpoint
- **API Tag**: `GW_INIT_INTENT`

#### 2. UPI QR API  
**Function**: `initPhonePeV2UpiQRRequest`
- **Method**: POST
- **Endpoint**: PhonePe V2 UPI QR endpoint
- **API Tag**: `GW_INIT_QR`

#### 3. UPI Collect API
**Function**: `initPhonepeUpiCollectRequest`
- **Method**: POST
- **Endpoint**: PhonePe UPI Collect endpoint
- **API Tag**: `GW_INIT_COLLECT`

### Error Handling Strategy

#### Error Categories
1. **HTTP Errors**: 504 (Gateway Timeout), 503 (Service Unavailable)
2. **Socket Errors**: Connection timeouts, network issues
3. **Payload Errors**: Invalid response format, parsing failures

#### Error Response Mapping
```haskell
case response of
  Right (ValidUpiIntentV2Resp valid) -> 
    if valid ^. L._success
      then -- Success: Extract intentUrl and create SdkParams
      else -- PhonePe API Error: Use code/message from response
  Right (ErrorUpiIntentV2Resp fail) -> 
    -- PhonePe Error Response: Use fail.code and fail.message
  Left err -> case err of
    API httpError -> -- Network/HTTP errors
    Socket socketError -> -- Connection errors  
    Payload payload -> -- Response parsing errors
```

## Implementation Steps

### For New Integration Implementation

#### Step 1: Set Up Request Pipeline
1. **Create payload generation functions** similar to:
   - `makePhonepeUpiIntentV2Payload`
   - `makePhonepeUpiQRV2Payload` 
   - `phonepeUpiCollectPayLoad`

2. **Implement base64 encoding**:
   ```
   jsonPayload = JSON.stringify(payloadObject)
   base64Payload = base64Encode(jsonPayload)
   requestBody = { "request": base64Payload }
   ```

#### Step 2: Implement Checksum Generation
```
checksum = base64(sha256(base64Payload + saltKey + merchantId))
headers["X-VERIFY"] = checksum
headers["Content-Type"] = "application/json"
```

#### Step 3: Set Up Response Handling
1. **Parse response structure** based on documented response formats
2. **Handle success/error cases** with appropriate status mapping
3. **Extract relevant data**:
   - Intent: `data.instrumentResponse.intentUrl`
   - QR: `data.instrumentResponse.qrData`
   - Collect: Success/failure status

#### Step 4: Integrate with Transaction Flow
1. **For Collect**: Hook into transaction processing with `UPI_COLLECT` type
2. **For Intent/QR**: Hook into SDK parameter generation flow
3. **Update transaction status** based on response

#### Step 5: Error Handling
1. **Network errors**: Retry logic, timeout handling
2. **API errors**: Map PhonePe error codes to internal error types
3. **Validation**: Input validation before API calls

## Key Files Reference

### Core Implementation Files
1. **Flow Logic**: `euler-x/src-generated/Gateway/PhonePe/Flow.hs`
   - `getSdkParams` (lines 4380+)
   - `callPhonepeIntegrationV2UpiIntentFlow` (lines 4070+)
   - `phonepeV2UpiQRFlow` (lines 4158+)
   - `sendCollectRequest` (lines 4012+)

2. **Payload Creation**: `euler-x/src-generated/Gateway/PhonePe/Transforms.hs`
   - `makePhonepeUpiIntentV2Payload` (lines 1445-1463)
   - `makePhonepeUpiQRV2Payload` (lines 1708-1721)
   - `phonepeUpiCollectPayLoad` (lines 1409+)
   - Header generation functions (lines 1506+)

3. **Type Definitions**: `euler-x/src-generated/Gateway/PhonePe/Types.hs`
   - Request/Response type definitions
   - JSON serialization instances

### Supporting Files
4. **Transaction Processing**: `oltp/src-generated/Product/OLTP/Transaction.hs`
   - Transaction type routing (line 4132)

5. **Common Gateway**: `euler-x/src-generated/Gateway/CommonGateway.hs`
   - Gateway-specific routing (line 3082)

### Configuration and Utilities
6. **Helper Functions**: Various utility functions across:
   - Amount calculation (`getMoney`)
   - Mobile number extraction (`getCustomerMobileNumber`)
   - URL generation (`getWebhookUrl`)
   - Device detection (`getSdkOSfromRequestHeader`)

## Encryption and Hashing Implementation Details

### Checksum Generation Algorithm

**Function**: `getCheckSumforV2API` in `./euler-x/src-generated/Gateway/PhonePe/Transforms.hs:1441`

```haskell
getCheckSumforV2API :: Text -> PhonepeDetails -> Text -> Text
getCheckSumforV2API encPayload phonepeDetails v2ApiPayPath = 
  sha256 (encPayload <> v2ApiPayPath <> phonepeDetails ^. _phonepeKey1) 
  <> saltSeparator 
  <> (fromMaybe ("1" :: Text) $ getTrueString $ phonepeDetails ^. _keyIndex1)
```

**Step-by-Step Algorithm**:
1. **Concatenate**: `base64EncodedPayload + apiPath + saltKey`
2. **Hash**: Apply SHA256 to the concatenated string
3. **Format**: `sha256Hash + "###" + keyIndex`

**Components**:
- `encPayload`: Base64 encoded JSON payload
- `v2ApiPayPath`: API endpoint path (e.g., "/pg/v1/pay")
- `phonepeDetails._phonepeKey1`: Salt key from PhonePe merchant configuration
- `saltSeparator`: Fixed string "###"
- `phonepeDetails._keyIndex1`: Key index (usually "1")

### Base64 Encoding Process

**Functions Used**:
```haskell
-- Step 1: Convert Haskell data to JSON
jsonPayload = encodeJSON rawPayload

-- Step 2: Base64 encode the JSON string
encPayload <- encodeBase64 jsonPayload

-- Step 3: Create request wrapper
request = { "request": encPayload }
```

**Complete Flow**:
```
HaskellRecord → JSON → Base64 → RequestWrapper
```

### API Path Constants

**Location**: `./euler-x/src-generated/Gateway/PhonePe/Transforms.hs`

```haskell
v2PayPath :: Text
v2PayPath = "/pg/v1/pay"           -- Used for UPI Intent, QR, Collect

v2SyncPath :: Text  
v2SyncPath = "/pg/v1/status/"      -- Used for status check

v2PGRefundPath :: Text
v2PGRefundPath = "/pg/v1/refund"   -- Used for refunds

saltSeparator :: Text
saltSeparator = "###"              -- Separator in checksum
```

### Header Generation

**X-VERIFY Header Creation**:
```haskell
headers = [
  Header "Content-Type" "application/json",
  Header "X-VERIFY" $ getCheckSumforV2API encPayload phonepeDetails v2PayPath
]
```

**Complete X-VERIFY Value Format**:
```
X-VERIFY: {SHA256_HASH}###{KEY_INDEX}
```

### PhonePe Merchant Configuration

**Required Fields from PhonepeDetails**:
- `_phonepeMerchantId`: Merchant identifier 
- `_phonepeKey1`: Salt key for checksum generation
- `_keyIndex1`: Key index (typically "1")

### Response Handling

**No Response Decryption**: PhonePe responses are received in plain JSON format, no decryption required.

**Response Processing**:
1. Parse JSON response directly
2. No checksum verification on responses (unidirectional verification)
3. Extract relevant fields based on response type
4. Handle success/error status from response fields

### Security Implementation Summary

#### Request Security:
1. **Payload Encoding**: JSON → Base64
2. **Checksum Generation**: SHA256(Base64Payload + APIPath + SaltKey) + "###" + KeyIndex
3. **Header Authentication**: X-VERIFY header with checksum

#### Response Security:
1. **No Encryption**: Plain JSON responses
2. **No Verification**: No checksum validation on responses
3. **HTTPS**: Transport layer security only

### Cryptographic Dependencies

**Hash Function**: SHA256 (from standard cryptographic libraries)
**Encoding**: Base64 (standard encoding)
**No Custom Encryption**: Uses standard algorithms only

### Implementation Example

```javascript
// Pseudo-code for new implementation
function generatePhonePeChecksum(payload, apiPath, saltKey, keyIndex) {
  // Step 1: Create JSON and encode to Base64
  const jsonPayload = JSON.stringify(payload);
  const base64Payload = btoa(jsonPayload);
  
  // Step 2: Create checksum string
  const checksumInput = base64Payload + apiPath + saltKey;
  
  // Step 3: Generate SHA256 hash
  const hash = sha256(checksumInput);
  
  // Step 4: Format with separator and key index
  const checksum = hash + "###" + keyIndex;
  
  return {
    requestBody: { "request": base64Payload },
    headers: {
      "Content-Type": "application/json",
      "X-VERIFY": checksum
    }
  };
}
```

---

**Analysis Complete**: 
✅ **Request/Response Structures** - Documented for all UPI methods  
✅ **Parameter Transformations** - Complete mapping from internal to API format  
✅ **Encryption/Hashing Details** - SHA256 checksum with Base64 encoding  
✅ **Integration Flow** - Step-by-step implementation guide  
✅ **Security Implementation** - Complete cryptographic details