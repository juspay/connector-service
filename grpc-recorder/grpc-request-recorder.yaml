admin:
  address:
    socket_address:
      address: 0.0.0.0
      port_value: 9901

static_resources:
  listeners:
  - name: listener_8086
    address:
      socket_address:
        address: 0.0.0.0
        port_value: 8086
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress_http
          codec_type: AUTO
          generate_request_id: true
          preserve_external_request_id: true
          set_current_client_cert_details:
            uri: true
          access_log:
          - name: envoy.file_access_log
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog
              path: "/var/log/envoy/access.log"
              log_format:
                text_format_source:
                  inline_string: "[%START_TIME%] \"%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%\" %RESPONSE_CODE% %RESPONSE_FLAGS% %BYTES_RECEIVED% %BYTES_SENT% %DURATION% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% \"%REQ(X-FORWARDED-FOR)%\" \"%REQ(USER-AGENT)%\" \"%REQ(X-REQUEST-ID)%\" \"%REQ(:AUTHORITY)%\" \"%UPSTREAM_HOST%\" %UPSTREAM_CLUSTER% %UPSTREAM_LOCAL_ADDRESS% %DOWNSTREAM_LOCAL_ADDRESS% %DOWNSTREAM_REMOTE_ADDRESS% %RESPONSE_CODE_DETAILS% %CONNECTION_TERMINATION_DETAILS%\n"
          - name: envoy.file_access_log
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog
              path: "/var/log/envoy/grpc-access.log"
              log_format:
                text_format_source:
                  inline_string: "[%START_TIME%] REQUEST_ID=%REQ(X-REQUEST-ID)% METHOD=%REQ(:METHOD)% PATH=%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% PROTOCOL=%PROTOCOL% RESPONSE_CODE=%RESPONSE_CODE% RESPONSE_FLAGS=%RESPONSE_FLAGS% BYTES_RECEIVED=%BYTES_RECEIVED% BYTES_SENT=%BYTES_SENT% DURATION=%DURATION% UPSTREAM_SERVICE_TIME=%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% FORWARDED_FOR=%REQ(X-FORWARDED-FOR)% USER_AGENT=%REQ(USER-AGENT)% AUTHORITY=%REQ(:AUTHORITY)% UPSTREAM_HOST=%UPSTREAM_HOST% UPSTREAM_CLUSTER=%UPSTREAM_CLUSTER% UPSTREAM_LOCAL_ADDRESS=%UPSTREAM_LOCAL_ADDRESS% DOWNSTREAM_LOCAL_ADDRESS=%DOWNSTREAM_LOCAL_ADDRESS% DOWNSTREAM_REMOTE_ADDRESS=%DOWNSTREAM_REMOTE_ADDRESS% RESPONSE_CODE_DETAILS=%RESPONSE_CODE_DETAILS% CONNECTION_TERMINATION_DETAILS=%CONNECTION_TERMINATION_DETAILS% GRPC_STATUS=%RESP(GRPC-STATUS)% GRPC_MESSAGE=%RESP(GRPC-MESSAGE)%\n"
          route_config:
            name: local_route
            virtual_hosts:
            - name: local_service
              domains: ["*"]
              routes:
              - match:
                  prefix: "/"
                route:
                  cluster: grpc_service
                  timeout: 0s
                  max_grpc_timeout: 0s
                  grpc_timeout_offset: 0s
          http_filters:
          - name: envoy.filters.http.grpc_web
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.grpc_web.v3.GrpcWeb
          - name: envoy.filters.http.lua
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
              inline_code: |
                function envoy_on_request(request_handle)
                  -- Capture request metadata and body
                  local request_id = request_handle:headers():get("x-request-id") or "auto-" .. math.random(100000, 999999)
                  local method = request_handle:headers():get(":path") or "unknown"
                  local content_type = request_handle:headers():get("content-type") or ""
                  local user_agent = request_handle:headers():get("user-agent") or ""
                  local authority = request_handle:headers():get(":authority") or ""
                  
                  -- Get request body
                  local body = request_handle:body()
                  local body_size = 0
                  local body_hex = ""
                  
                  if body and #body > 0 then
                    body_size = #body
                    -- Convert to hex for storage
                    body_hex = body:gsub(".", function(char) 
                      return string.format("%02x", string.byte(char)) 
                    end)
                  end
                  
                  -- Create request record
                  local request_record = {
                    timestamp = os.time(),
                    request_id = request_id,
                    type = "request",
                    method = method,
                    content_type = content_type,
                    user_agent = user_agent,
                    authority = authority,
                    body_size = body_size,
                    body_hex = body_hex,
                    headers = {}
                  }
                  
                  -- Capture important headers
                  local important_headers = {
                    "x-connector", "x-merchant-id", "x-tenant-id", 
                    "x-auth", "x-api-key", "x-key1"
                  }
                  
                  for _, header in ipairs(important_headers) do
                    local value = request_handle:headers():get(header)
                    if value then
                      request_record.headers[header] = value
                    end
                  end
                  
                  -- Store request metadata for response correlation
                  request_handle:streamInfo():dynamicMetadata():set("grpc_recorder", "request_id", request_id)
                  request_handle:streamInfo():dynamicMetadata():set("grpc_recorder", "request_record", request_record)
                  
                  -- Log request capture
                  request_handle:logInfo("GRPC Request Captured - ID: " .. request_id .. ", Size: " .. body_size .. " bytes")
                end
                
                function envoy_on_response(response_handle)
                  -- Get request metadata
                  local request_id = response_handle:streamInfo():dynamicMetadata():get("grpc_recorder")["request_id"]
                  local request_record = response_handle:streamInfo():dynamicMetadata():get("grpc_recorder")["request_record"]
                  
                  if not request_id then
                    request_id = "unknown-" .. math.random(100000, 999999)
                  end
                  
                  -- Get response data
                  local response_code = response_handle:headers():get(":status") or "unknown"
                  local grpc_status = response_handle:headers():get("grpc-status") or ""
                  local grpc_message = response_handle:headers():get("grpc-message") or ""
                  
                  -- Get response body
                  local body = response_handle:body()
                  local body_size = 0
                  local body_hex = ""
                  
                  if body and #body > 0 then
                    body_size = #body
                    -- Convert to hex for storage
                    body_hex = body:gsub(".", function(char) 
                      return string.format("%02x", string.byte(char)) 
                    end)
                  end
                  
                  -- Create response record
                  local response_record = {
                    timestamp = os.time(),
                    request_id = request_id,
                    type = "response",
                    response_code = response_code,
                    grpc_status = grpc_status,
                    grpc_message = grpc_message,
                    body_size = body_size,
                    body_hex = body_hex
                  }
                  
                  -- Write both request and response to file
                  local filename = "/var/log/envoy/grpc_captures/" .. request_id .. ".json"
                  local capture_data = {
                    request = request_record,
                    response = response_record,
                    capture_metadata = {
                      envoy_version = "v1.29-latest",
                      capture_time = os.date("%Y-%m-%d %H:%M:%S"),
                      total_bytes = (request_record.body_size or 0) + (response_record.body_size or 0)
                    }
                  }
                  
                  -- Write to file (this would need a proper file system interface)
                  local json_data = require("cjson").encode(capture_data)
                  response_handle:logInfo("GRPC Capture Complete - ID: " .. request_id .. ", File: " .. filename .. ", Total Size: " .. capture_data.capture_metadata.total_bytes .. " bytes")
                end
          - name: envoy.filters.http.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  clusters:
  - name: grpc_service
    type: LOGICAL_DNS
    http2_protocol_options: {}
    load_assignment:
      cluster_name: grpc_service
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: host.docker.internal
                port_value: 8085
  - name: zipkin
    type: LOGICAL_DNS
    load_assignment:
      cluster_name: zipkin
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: host.docker.internal
                port_value: 9411

tracing:
  http:
    name: envoy.tracers.zipkin
    typed_config:
      "@type": type.googleapis.com/envoy.config.trace.v3.ZipkinConfig
      collector_cluster: zipkin
      collector_endpoint: "/api/v2/spans"
      shared_span_context: false
      trace_id_128bit: true

layered_runtime:
  layers:
  - name: static_layer_0
    static_layer:
      overload:
        global_downstream_max_connections: 50000
