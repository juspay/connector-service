// This file is @generated by prost-build.
/// PaymentMethod represents a payment instrument used to process a payment
/// It contains a oneof field with all possible payment method categories
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentMethod {
    #[prost(oneof = "payment_method::PaymentMethod", tags = "1, 3, 4, 5")]
    pub payment_method: ::core::option::Option<payment_method::PaymentMethod>,
}
/// Nested message and enum types in `PaymentMethod`.
pub mod payment_method {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PaymentMethod {
        /// Card-based payment methods - SUPPORTED
        #[prost(message, tag = "1")]
        Card(super::CardPaymentMethodType),
        /// WalletPaymentMethodType wallet = 2;                  // Digital wallet payment methods - TODO: Not yet supported
        ///
        /// UPI Collect payment method - SUPPORTED
        #[prost(message, tag = "3")]
        UpiCollect(super::UpiCollect),
        /// UPI Intent payment method - SUPPORTED
        #[prost(message, tag = "4")]
        UpiIntent(super::UpiIntent),
        /// Tokenized payment methods - SUPPORTED
        #[prost(message, tag = "5")]
        Token(super::TokenPaymentMethodType),
    }
}
/// Card payment methods category
/// Includes credit cards, debit cards, and card redirect flows
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardPaymentMethodType {
    #[prost(oneof = "card_payment_method_type::CardType", tags = "1, 2, 3")]
    pub card_type: ::core::option::Option<card_payment_method_type::CardType>,
}
/// Nested message and enum types in `CardPaymentMethodType`.
pub mod card_payment_method_type {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CardType {
        /// Credit card payment details
        #[prost(message, tag = "1")]
        Credit(super::CardDetails),
        /// Debit card payment details
        #[prost(message, tag = "2")]
        Debit(super::CardDetails),
        /// Card payment via redirect flow
        #[prost(message, tag = "3")]
        CardRedirect(super::CardRedirect),
    }
}
/// Payment method token details.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenPaymentMethodType {
    /// The token string representing a payment method.
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
/// Details of a payment card.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardDetails {
    /// Card Identification
    #[prost(string, tag = "1")]
    pub card_number: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub card_exp_month: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub card_exp_year: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub card_cvc: ::prost::alloc::string::String,
    /// Cardholder Information
    #[prost(string, optional, tag = "5")]
    pub card_holder_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Card Metadata
    #[prost(string, optional, tag = "6")]
    pub card_issuer: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "CardNetwork", optional, tag = "7")]
    pub card_network: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "8")]
    pub card_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub card_issuing_country_alpha2: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "10")]
    pub bank_code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub nick_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Card redirect payment method
/// Used for card payments that require a redirect to a 3DS page or issuer site
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardRedirect {
    #[prost(enumeration = "card_redirect::CardRedirectType", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `CardRedirect`.
pub mod card_redirect {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CardRedirectType {
        Unspecified = 0,
        Knet = 1,
        Benefit = 2,
        MomoAtm = 3,
        CardRedirect = 4,
    }
    impl CardRedirectType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CardRedirectType::Unspecified => "CARD_REDIRECT_TYPE_UNSPECIFIED",
                CardRedirectType::Knet => "KNET",
                CardRedirectType::Benefit => "BENEFIT",
                CardRedirectType::MomoAtm => "MOMO_ATM",
                CardRedirectType::CardRedirect => "CARD_REDIRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CARD_REDIRECT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "KNET" => Some(Self::Knet),
                "BENEFIT" => Some(Self::Benefit),
                "MOMO_ATM" => Some(Self::MomoAtm),
                "CARD_REDIRECT" => Some(Self::CardRedirect),
                _ => None,
            }
        }
    }
}
/// UPI (Unified Payments Interface) - Indian instant real-time payment system
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpiCollect {
    /// Virtual Payment Address
    #[prost(string, optional, tag = "1")]
    pub vpa_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// No additional fields required for UPI Intent
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpiIntent {}
/// PIX - Brazilian instant payment ecosystem
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PixPayment {
    /// Unique key for PIX transfer
    #[prost(string, optional, tag = "1")]
    pub pix_key: ::core::option::Option<::prost::alloc::string::String>,
    /// CPF (Brazilian tax identification number)
    #[prost(string, optional, tag = "2")]
    pub cpf: ::core::option::Option<::prost::alloc::string::String>,
    /// CNPJ (Brazilian company tax identification number)
    #[prost(string, optional, tag = "3")]
    pub cnpj: ::core::option::Option<::prost::alloc::string::String>,
    /// Source bank account ID
    #[prost(string, optional, tag = "4")]
    pub source_bank_account_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Destination bank account ID
    #[prost(string, optional, tag = "5")]
    pub destination_bank_account_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
/// PromptPay - Thai QR code payment system
///
/// Fields will be added as needed for PromptPay integration
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromptPay {}
/// VietQR - Vietnamese QR code payment system
///
/// Fields will be added as needed for VietQR integration
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VietQr {}
/// Card network types for card payments
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CardNetwork {
    Unspecified = 0,
    Visa = 1,
    Mastercard = 2,
    Amex = 3,
    Discover = 4,
    Jcb = 5,
    Diners = 6,
    Unionpay = 7,
    Maestro = 8,
    CartesBancaires = 9,
    Rupay = 10,
}
impl CardNetwork {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CardNetwork::Unspecified => "CARD_NETWORK_UNSPECIFIED",
            CardNetwork::Visa => "VISA",
            CardNetwork::Mastercard => "MASTERCARD",
            CardNetwork::Amex => "AMEX",
            CardNetwork::Discover => "DISCOVER",
            CardNetwork::Jcb => "JCB",
            CardNetwork::Diners => "DINERS",
            CardNetwork::Unionpay => "UNIONPAY",
            CardNetwork::Maestro => "MAESTRO",
            CardNetwork::CartesBancaires => "CARTES_BANCAIRES",
            CardNetwork::Rupay => "RUPAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CARD_NETWORK_UNSPECIFIED" => Some(Self::Unspecified),
            "VISA" => Some(Self::Visa),
            "MASTERCARD" => Some(Self::Mastercard),
            "AMEX" => Some(Self::Amex),
            "DISCOVER" => Some(Self::Discover),
            "JCB" => Some(Self::Jcb),
            "DINERS" => Some(Self::Diners),
            "UNIONPAY" => Some(Self::Unionpay),
            "MAESTRO" => Some(Self::Maestro),
            "CARTES_BANCAIRES" => Some(Self::CartesBancaires),
            "RUPAY" => Some(Self::Rupay),
            _ => None,
        }
    }
}
/// Represents a physical address with contact information.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    /// Personal Information
    #[prost(string, optional, tag = "1")]
    pub first_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub last_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Address Details
    #[prost(string, optional, tag = "3")]
    pub line1: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub line2: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub line3: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub city: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub zip_code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "CountryAlpha2", optional, tag = "9")]
    pub country_alpha2_code: ::core::option::Option<i32>,
    /// Contact Information
    #[prost(string, optional, tag = "10")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub phone_number: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub phone_country_code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Access token details.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessToken {
    /// The token string.
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    /// Expiration timestamp of the token (seconds since epoch).
    #[prost(int64, tag = "2")]
    pub expires_in_seconds: i64,
}
/// Additional authentication data, typically from 3DS.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticationData {
    /// Electronic Commerce Indicator (ECI) from 3DS.
    #[prost(string, optional, tag = "1")]
    pub eci: ::core::option::Option<::prost::alloc::string::String>,
    /// Cardholder Authentication Verification Value (CAVV).
    #[prost(string, tag = "2")]
    pub cavv: ::prost::alloc::string::String,
    /// 3DS Server Transaction ID.
    #[prost(message, optional, tag = "3")]
    pub threeds_server_transaction_id: ::core::option::Option<Identifier>,
    /// 3DS Message Version (e.g., "2.1.0", "2.2.0").
    #[prost(string, optional, tag = "4")]
    pub message_version: ::core::option::Option<::prost::alloc::string::String>,
    /// Directory Server Transaction ID (DS Trans ID).
    #[prost(string, optional, tag = "5")]
    pub ds_transaction_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Details of customer acceptance for mandates or terms.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerAcceptance {
    /// Type of acceptance (e.g., online, offline).
    #[prost(enumeration = "AcceptanceType", tag = "1")]
    pub acceptance_type: i32,
    /// Unix timestamp (seconds since epoch) of when the acceptance was given.
    #[prost(int64, tag = "2")]
    pub accepted_at: i64,
    /// Details if the acceptance was an online mandate.
    #[prost(message, optional, tag = "3")]
    pub online_mandate_details: ::core::option::Option<OnlineMandate>,
}
/// Details for an online mandate acceptance.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlineMandate {
    /// IP address from which the mandate was accepted.
    #[prost(string, optional, tag = "1")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    /// User agent string of the browser used for mandate acceptance.
    #[prost(string, tag = "2")]
    pub user_agent: ::prost::alloc::string::String,
}
/// Information about the customer's browser.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrowserInformation {
    /// Display Information
    #[prost(uint32, optional, tag = "1")]
    pub color_depth: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub screen_height: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub screen_width: ::core::option::Option<u32>,
    /// Browser Settings
    #[prost(bool, optional, tag = "2")]
    pub java_enabled: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub java_script_enabled: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "4")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "7")]
    pub time_zone_offset_minutes: ::core::option::Option<i32>,
    /// Browser Headers
    #[prost(string, optional, tag = "9")]
    pub accept_header: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub user_agent: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "14")]
    pub accept_language: ::core::option::Option<::prost::alloc::string::String>,
    /// Device Information
    #[prost(string, optional, tag = "8")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub os_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub os_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub device_model: ::core::option::Option<::prost::alloc::string::String>,
}
/// Represents an identifier, which can be one of several types.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Identifier {
    #[prost(oneof = "identifier::IdType", tags = "1, 2, 3")]
    pub id_type: ::core::option::Option<identifier::IdType>,
}
/// Nested message and enum types in `Identifier`.
pub mod identifier {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum IdType {
        /// Connector's transaction ID.
        #[prost(string, tag = "1")]
        Id(::prost::alloc::string::String),
        /// Encoded data representing the ID or related information.
        #[prost(string, tag = "2")]
        EncodedData(::prost::alloc::string::String),
        /// Indicates that no specific ID is returned or applicable.
        #[prost(message, tag = "3")]
        NoResponseIdMarker(()),
    }
}
/// Reference to a payment mandate.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MandateReference {
    /// Connector's unique identifier for the mandate.
    #[prost(string, optional, tag = "1")]
    pub mandate_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Container for various address types related to a payment.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentAddress {
    /// Shipping address.
    #[prost(message, optional, tag = "1")]
    pub shipping_address: ::core::option::Option<Address>,
    /// Customer Billing address.
    #[prost(message, optional, tag = "2")]
    pub billing_address: ::core::option::Option<Address>,
}
/// Data for a redirection, can be either form data, raw HTML, or URI.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedirectForm {
    #[prost(oneof = "redirect_form::FormType", tags = "1, 2, 3")]
    pub form_type: ::core::option::Option<redirect_form::FormType>,
}
/// Nested message and enum types in `RedirectForm`.
pub mod redirect_form {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FormType {
        /// Data for constructing an HTML form for redirection.
        #[prost(message, tag = "1")]
        Form(super::FormData),
        /// Raw HTML data for redirection.
        #[prost(message, tag = "2")]
        Html(super::HtmlData),
        /// URI for direct redirection (e.g., UPI deep links).
        #[prost(message, tag = "3")]
        Uri(super::UriData),
    }
}
/// Represents data for an HTML form to be submitted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormData {
    /// The endpoint URL where the form should be submitted.
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    /// HTTP method to be used for form submission (e.g., POST).
    #[prost(enumeration = "HttpMethod", tag = "2")]
    pub method: i32,
    /// Key-value pairs representing the form fields.
    #[prost(map = "string, string", tag = "3")]
    pub form_fields: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Represents raw HTML data.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HtmlData {
    /// The HTML content as a string.
    #[prost(string, tag = "1")]
    pub html_data: ::prost::alloc::string::String,
}
/// Represents URI data for direct redirection.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UriData {
    /// The URI for redirection (e.g., UPI deep link).
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
}
/// Details of an HTTP request, typically for incoming webhooks.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestDetails {
    /// HTTP method of the request (e.g., GET, POST).
    #[prost(enumeration = "HttpMethod", tag = "1")]
    pub method: i32,
    /// URI of the request.
    #[prost(string, optional, tag = "2")]
    pub uri: ::core::option::Option<::prost::alloc::string::String>,
    /// Headers of the HTTP request.
    #[prost(map = "string, string", tag = "3")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Body of the HTTP request.
    #[prost(bytes = "vec", tag = "4")]
    pub body: ::prost::alloc::vec::Vec<u8>,
    /// Query parameters of the request.
    #[prost(string, optional, tag = "5")]
    pub query_params: ::core::option::Option<::prost::alloc::string::String>,
}
/// Secrets used for verifying connector webhooks.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebhookSecrets {
    /// Primary secret for webhook verification.
    #[prost(string, tag = "1")]
    pub secret: ::prost::alloc::string::String,
    /// Additional secret, if required by the connector.
    #[prost(string, optional, tag = "2")]
    pub additional_secret: ::core::option::Option<::prost::alloc::string::String>,
}
/// Content of a webhook response, can be one of several types.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebhookResponseContent {
    #[prost(oneof = "webhook_response_content::Content", tags = "1, 2, 3")]
    pub content: ::core::option::Option<webhook_response_content::Content>,
}
/// Nested message and enum types in `WebhookResponseContent`.
pub mod webhook_response_content {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        /// Content if the webhook is for a payment synchronization.
        #[prost(message, tag = "1")]
        PaymentsResponse(super::PaymentServiceGetResponse),
        /// Content if the webhook is for a refund synchronization.
        #[prost(message, tag = "2")]
        RefundsResponse(super::RefundResponse),
        /// Content if the webhook is for a dispute synchronization.
        #[prost(message, tag = "3")]
        DisputesResponse(super::DisputeResponse),
    }
}
/// Data for a multiple capture request.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultipleCaptureRequestData {
    /// Sequence number for this capture in a series of multiple captures.
    #[prost(int64, tag = "1")]
    pub capture_sequence: i64,
    /// Reference for this specific capture.
    #[prost(string, tag = "2")]
    pub capture_reference: ::prost::alloc::string::String,
}
/// Represents a single piece of evidence for a dispute.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidenceDocument {
    /// Type of the evidence.
    #[prost(enumeration = "EvidenceType", tag = "1")]
    pub evidence_type: i32,
    /// Content Options
    /// Content of the document, if it's a file.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub file_content: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// MIME type of the file (e.g., "application/pdf", "image/png"), if file_content is provided.
    #[prost(string, optional, tag = "3")]
    pub file_mime_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Identifier for the file if stored with an external provider.
    #[prost(string, optional, tag = "4")]
    pub provider_file_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Textual content of the evidence, if it's not a file or in addition to a file.
    #[prost(string, optional, tag = "5")]
    pub text_content: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request message for authorizing a payment.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceAuthorizeRequest {
    /// Payment Identification
    ///
    /// Renamed from connector_request_reference_id
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Amount Information
    ///
    /// The amount for the payment in major currency units
    #[prost(int64, tag = "2")]
    pub amount: i64,
    /// The currency for the payment, in ISO 4217 three-letter code
    #[prost(enumeration = "Currency", tag = "3")]
    pub currency: i32,
    /// The minor amount for the payment (e.g., cents)
    #[prost(int64, tag = "4")]
    pub minor_amount: i64,
    /// Tax amount for the order
    #[prost(int64, optional, tag = "5")]
    pub order_tax_amount: ::core::option::Option<i64>,
    /// Cost of shipping for the order
    #[prost(int64, optional, tag = "6")]
    pub shipping_cost: ::core::option::Option<i64>,
    /// Payment Method and Capture Settings
    ///
    /// Payment method to be used
    #[prost(message, optional, tag = "7")]
    pub payment_method: ::core::option::Option<PaymentMethod>,
    /// Method for capturing the payment
    #[prost(enumeration = "CaptureMethod", optional, tag = "8")]
    pub capture_method: ::core::option::Option<i32>,
    /// Customer Information
    ///
    /// Email address of the customer
    #[prost(string, optional, tag = "9")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of the customer
    #[prost(string, optional, tag = "10")]
    pub customer_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Customer ID as recognized by the connector
    #[prost(string, optional, tag = "11")]
    pub connector_customer_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Address Information
    ///
    /// Billing and shipping address details
    #[prost(message, optional, tag = "12")]
    pub address: ::core::option::Option<PaymentAddress>,
    /// Authentication Details
    ///
    /// Type of authentication to be used
    #[prost(enumeration = "AuthenticationType", tag = "13")]
    pub auth_type: i32,
    /// Indicates if the customer is enrolled for 3D Secure
    #[prost(bool, tag = "14")]
    pub enrolled_for_3ds: bool,
    /// Additional authentication data
    #[prost(message, optional, tag = "15")]
    pub authentication_data: ::core::option::Option<AuthenticationData>,
    /// Metadata
    ///
    /// Additional metadata for the connector
    #[prost(map = "string, string", tag = "16")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// URLs for Redirection and Webhooks
    ///
    /// URL to redirect after payment
    #[prost(string, optional, tag = "17")]
    pub return_url: ::core::option::Option<::prost::alloc::string::String>,
    /// URL for webhook notifications
    #[prost(string, optional, tag = "18")]
    pub webhook_url: ::core::option::Option<::prost::alloc::string::String>,
    /// URL to complete authorization
    #[prost(string, optional, tag = "19")]
    pub complete_authorize_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Session and Token Information
    ///
    /// Access token for secure communication
    #[prost(message, optional, tag = "20")]
    pub access_token: ::core::option::Option<AccessToken>,
    /// Session token, if applicable
    #[prost(string, optional, tag = "21")]
    pub session_token: ::core::option::Option<::prost::alloc::string::String>,
    /// Order Details
    ///
    /// Category of the order
    #[prost(string, optional, tag = "22")]
    pub order_category: ::core::option::Option<::prost::alloc::string::String>,
    /// Merchant's internal reference ID
    #[prost(string, optional, tag = "23")]
    pub merchant_order_reference_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Behavioral Flags and Preferences
    ///
    /// Indicates future usage intention
    #[prost(enumeration = "FutureUsage", optional, tag = "24")]
    pub setup_future_usage: ::core::option::Option<i32>,
    /// Indicates if off-session transaction
    #[prost(bool, optional, tag = "25")]
    pub off_session: ::core::option::Option<bool>,
    /// Indicates if incremental authorization is requested
    #[prost(bool, tag = "26")]
    pub request_incremental_authorization: bool,
    /// Indicates if extended authorization is requested
    #[prost(bool, optional, tag = "27")]
    pub request_extended_authorization: ::core::option::Option<bool>,
    /// Contextual Information
    ///
    /// Details of customer acceptance
    #[prost(message, optional, tag = "28")]
    pub customer_acceptance: ::core::option::Option<CustomerAcceptance>,
    /// Information about the customer's browser
    #[prost(message, optional, tag = "29")]
    pub browser_info: ::core::option::Option<BrowserInformation>,
    /// Preferred payment experience
    #[prost(enumeration = "PaymentExperience", optional, tag = "30")]
    pub payment_experience: ::core::option::Option<i32>,
}
/// Response message for a payment authorization.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceAuthorizeResponse {
    /// Identification
    ///
    /// Identifier for the resource created
    #[prost(message, optional, tag = "1")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Status Information
    ///
    /// Status of the payment attempt
    #[prost(enumeration = "PaymentStatus", tag = "2")]
    pub status: i32,
    /// Error code if the authorization failed
    #[prost(string, optional, tag = "3")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if the authorization failed
    #[prost(string, optional, tag = "4")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Redirection and Transaction Details
    ///
    /// Data for redirecting the customer's browser
    #[prost(message, optional, tag = "5")]
    pub redirection_data: ::core::option::Option<RedirectForm>,
    /// Transaction ID from the payment network
    #[prost(string, optional, tag = "6")]
    pub network_txn_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Renamed from connector_response_reference_id
    #[prost(message, optional, tag = "7")]
    pub response_ref_id: ::core::option::Option<Identifier>,
    /// Authorization Details
    ///
    /// Indicates if incremental authorization is allowed
    #[prost(bool, optional, tag = "8")]
    pub incremental_authorization_allowed: ::core::option::Option<bool>,
    /// Raw Response
    ///
    /// Raw response from the connector for debugging
    #[prost(string, optional, tag = "9")]
    pub raw_connector_response: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request message for synchronizing payment status.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceGetRequest {
    /// Identification
    ///
    /// The resource ID to synchronize
    #[prost(message, optional, tag = "1")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Reference
    ///
    /// Renamed from connector_request_reference_id
    #[prost(message, optional, tag = "2")]
    pub request_ref_id: ::core::option::Option<Identifier>,
}
/// Response message for a payment status synchronization.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceGetResponse {
    /// Identification
    ///
    /// Identifier for the synchronized resource
    #[prost(message, optional, tag = "1")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Status Information
    ///
    /// Current status of the payment attempt
    #[prost(enumeration = "PaymentStatus", tag = "2")]
    pub status: i32,
    /// Error code if synchronization encountered an issue
    #[prost(string, optional, tag = "3")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if synchronization encountered an issue
    #[prost(string, optional, tag = "4")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Transaction Details
    ///
    /// Mandate reference, if applicable
    #[prost(message, optional, tag = "5")]
    pub mandate_reference: ::core::option::Option<MandateReference>,
    /// Transaction ID from the payment network
    #[prost(string, optional, tag = "6")]
    pub network_txn_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Renamed from connector_response_reference_id
    #[prost(message, optional, tag = "7")]
    pub response_ref_id: ::core::option::Option<Identifier>,
    /// Payment Details
    ///
    /// Payment amount in major currency units
    #[prost(int64, optional, tag = "8")]
    pub amount: ::core::option::Option<i64>,
    /// Payment amount in minor currency units
    #[prost(int64, optional, tag = "9")]
    pub minor_amount: ::core::option::Option<i64>,
    /// Currency of the payment
    #[prost(enumeration = "Currency", optional, tag = "10")]
    pub currency: ::core::option::Option<i32>,
    /// Amount that has been captured
    #[prost(int64, optional, tag = "11")]
    pub captured_amount: ::core::option::Option<i64>,
    /// Captured amount in minor currency units
    #[prost(int64, optional, tag = "12")]
    pub minor_captured_amount: ::core::option::Option<i64>,
    /// Type of payment method used
    #[prost(enumeration = "PaymentMethodType", optional, tag = "13")]
    pub payment_method_type: ::core::option::Option<i32>,
    /// Capture method for the payment
    #[prost(enumeration = "CaptureMethod", optional, tag = "14")]
    pub capture_method: ::core::option::Option<i32>,
    /// Type of authentication used
    #[prost(enumeration = "AuthenticationType", optional, tag = "15")]
    pub auth_type: ::core::option::Option<i32>,
    /// Timestamps
    ///
    /// Unix timestamp when the payment was created
    #[prost(int64, optional, tag = "16")]
    pub created_at: ::core::option::Option<i64>,
    /// Unix timestamp when the payment was last updated
    #[prost(int64, optional, tag = "17")]
    pub updated_at: ::core::option::Option<i64>,
    /// Unix timestamp when the payment was authorized
    #[prost(int64, optional, tag = "18")]
    pub authorized_at: ::core::option::Option<i64>,
    /// Unix timestamp when the payment was captured
    #[prost(int64, optional, tag = "19")]
    pub captured_at: ::core::option::Option<i64>,
    /// Additional Context
    ///
    /// Name of the customer
    #[prost(string, optional, tag = "20")]
    pub customer_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Email address of the customer
    #[prost(string, optional, tag = "21")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Customer ID as recognized by the connector
    #[prost(string, optional, tag = "22")]
    pub connector_customer_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Merchant's internal reference ID
    #[prost(string, optional, tag = "23")]
    pub merchant_order_reference_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Additional metadata from the connector
    #[prost(map = "string, string", tag = "24")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Raw Response
    ///
    /// Raw response from the connector for debugging
    #[prost(string, optional, tag = "25")]
    pub raw_connector_response: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request message for voiding a payment.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceVoidRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Renamed from connector_request_reference_id
    #[prost(message, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Void Details
    ///
    /// Reason for cancelling/voiding the payment
    #[prost(string, optional, tag = "3")]
    pub cancellation_reason: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "4")]
    pub all_keys_required: ::core::option::Option<bool>,
}
/// Response message for a payment void operation.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceVoidResponse {
    /// Identification
    ///
    /// Identifier for the voided resource
    #[prost(message, optional, tag = "1")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Status Information
    ///
    /// Status of the payment attempt after voiding
    #[prost(enumeration = "PaymentStatus", tag = "2")]
    pub status: i32,
    /// Error code if the void operation failed
    #[prost(string, optional, tag = "3")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if the void operation failed
    #[prost(string, optional, tag = "4")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Renamed from connector_response_reference_id
    #[prost(message, optional, tag = "5")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Request message for capturing a payment.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceCaptureRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Renamed from connector_transaction_id
    #[prost(message, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Capture Details
    ///
    /// Amount to capture, in minor currency units
    #[prost(int64, tag = "3")]
    pub amount_to_capture: i64,
    /// Currency of the amount to capture
    #[prost(enumeration = "Currency", tag = "4")]
    pub currency: i32,
    /// Metadata
    ///
    /// Additional metadata for the connector
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Multiple Capture Information
    ///
    /// Data for multiple capture scenarios
    #[prost(message, optional, tag = "6")]
    pub multiple_capture_data: ::core::option::Option<MultipleCaptureRequestData>,
}
/// Response message for a payment capture operation.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceCaptureResponse {
    /// Identification
    ///
    /// Identifier for the captured resource
    #[prost(message, optional, tag = "1")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Status Information
    ///
    /// Status of the payment after the capture attempt
    #[prost(enumeration = "PaymentStatus", tag = "2")]
    pub status: i32,
    /// Error code if the capture failed
    #[prost(string, optional, tag = "3")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if the capture failed
    #[prost(string, optional, tag = "4")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Renamed from response_reference_id
    #[prost(message, optional, tag = "5")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Request message for processing a refund.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceRefundRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Unique identifier for the refund
    #[prost(string, tag = "2")]
    pub refund_id: ::prost::alloc::string::String,
    /// Renamed from connector_transaction_id
    #[prost(message, optional, tag = "3")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Amount Information
    ///
    /// Amount to be refunded, in major currency units
    #[prost(int64, tag = "4")]
    pub payment_amount: i64,
    /// Currency of the refund, ISO 4217 code
    #[prost(enumeration = "Currency", tag = "5")]
    pub currency: i32,
    /// Amount to be refunded, in minor currency units
    #[prost(int64, tag = "6")]
    pub minor_payment_amount: i64,
    /// Actual amount to refund, in major units
    #[prost(int64, tag = "7")]
    pub refund_amount: i64,
    /// Actual amount to refund in minor units
    #[prost(int64, tag = "8")]
    pub minor_refund_amount: i64,
    /// Refund Context
    ///
    /// Reason for the refund
    #[prost(string, optional, tag = "9")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
    /// URL for webhook notifications
    #[prost(string, optional, tag = "10")]
    pub webhook_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Merchant account ID for the refund
    #[prost(string, optional, tag = "11")]
    pub merchant_account_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Capture method related to the original payment
    #[prost(enumeration = "CaptureMethod", optional, tag = "12")]
    pub capture_method: ::core::option::Option<i32>,
    /// Metadata
    ///
    /// Metadata specific to the connector
    #[prost(map = "string, string", tag = "13")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Metadata specific to the refund
    #[prost(map = "string, string", tag = "14")]
    pub refund_metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Browser Information
    ///
    /// Browser information, if relevant
    #[prost(message, optional, tag = "15")]
    pub browser_info: ::core::option::Option<BrowserInformation>,
}
/// Response message for a refund operation (unified for both Create and Get).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefundResponse {
    /// Identification
    ///
    /// Identifier for the synchronized resource
    #[prost(message, optional, tag = "1")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Connector's ID for the refund
    #[prost(string, tag = "2")]
    pub refund_id: ::prost::alloc::string::String,
    /// Status Information
    ///
    /// Current status of the refund
    #[prost(enumeration = "RefundStatus", tag = "3")]
    pub status: i32,
    /// Error code if synchronization encountered an issue
    #[prost(string, optional, tag = "4")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if synchronization encountered an issue
    #[prost(string, optional, tag = "5")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "6")]
    pub response_ref_id: ::core::option::Option<Identifier>,
    /// Refund Details
    ///
    /// Refunded amount in major currency units
    #[prost(int64, optional, tag = "7")]
    pub refund_amount: ::core::option::Option<i64>,
    /// Refunded amount in minor currency units
    #[prost(int64, optional, tag = "8")]
    pub minor_refund_amount: ::core::option::Option<i64>,
    /// Currency of the refund
    #[prost(enumeration = "Currency", optional, tag = "9")]
    pub refund_currency: ::core::option::Option<i32>,
    /// Original payment amount in major currency units
    #[prost(int64, optional, tag = "10")]
    pub payment_amount: ::core::option::Option<i64>,
    /// Original payment amount in minor currency units
    #[prost(int64, optional, tag = "11")]
    pub minor_payment_amount: ::core::option::Option<i64>,
    /// Reason for the refund
    #[prost(string, optional, tag = "12")]
    pub refund_reason: ::core::option::Option<::prost::alloc::string::String>,
    /// Timestamps
    ///
    /// Unix timestamp when the refund was created
    #[prost(int64, optional, tag = "13")]
    pub created_at: ::core::option::Option<i64>,
    /// Unix timestamp when the refund was last updated
    #[prost(int64, optional, tag = "14")]
    pub updated_at: ::core::option::Option<i64>,
    /// Unix timestamp when the refund was processed
    #[prost(int64, optional, tag = "15")]
    pub processed_at: ::core::option::Option<i64>,
    /// Additional Context
    ///
    /// Name of the customer
    #[prost(string, optional, tag = "16")]
    pub customer_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Email address of the customer
    #[prost(string, optional, tag = "17")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Merchant's internal reference ID
    #[prost(string, optional, tag = "18")]
    pub merchant_order_reference_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Additional metadata from the connector
    #[prost(map = "string, string", tag = "19")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Refund-specific metadata from the connector
    #[prost(map = "string, string", tag = "20")]
    pub refund_metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Raw Response
    ///
    /// Raw response from the connector for debugging
    #[prost(string, optional, tag = "21")]
    pub raw_connector_response: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request message for creating a dispute.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceDisputeRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Transaction ID to raise the dispute for
    #[prost(message, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Connector's unique identifier
    #[prost(string, tag = "3")]
    pub dispute_id: ::prost::alloc::string::String,
}
/// Response message for dispute operations (unified for both Create and Get).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisputeResponse {
    /// Identification
    ///
    /// Connector's unique identifier for the dispute
    #[prost(string, optional, tag = "1")]
    pub dispute_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Transaction ID associated with the dispute
    #[prost(message, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Status Information
    ///
    /// Status of the dispute
    #[prost(enumeration = "DisputeStatus", tag = "3")]
    pub dispute_status: i32,
    /// Current stage of the dispute
    #[prost(enumeration = "DisputeStage", tag = "4")]
    pub dispute_stage: i32,
    /// Connector status code
    #[prost(string, optional, tag = "5")]
    pub connector_status_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error code if retrieval failed
    #[prost(string, optional, tag = "6")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if retrieval failed
    #[prost(string, optional, tag = "7")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Dispute Details
    ///
    /// Amount in dispute (minor currency units)
    #[prost(int64, optional, tag = "8")]
    pub dispute_amount: ::core::option::Option<i64>,
    /// Currency of the disputed amount
    #[prost(enumeration = "Currency", optional, tag = "9")]
    pub dispute_currency: ::core::option::Option<i32>,
    /// Unix timestamp when dispute was created
    #[prost(int64, optional, tag = "10")]
    pub dispute_date: ::core::option::Option<i64>,
    /// Unix timestamp of service date, if applicable
    #[prost(int64, optional, tag = "11")]
    pub service_date: ::core::option::Option<i64>,
    /// Unix timestamp of shipping date, if applicable
    #[prost(int64, optional, tag = "12")]
    pub shipping_date: ::core::option::Option<i64>,
    /// Unix timestamp of due date for response to dispute
    #[prost(int64, optional, tag = "13")]
    pub due_date: ::core::option::Option<i64>,
    /// Evidence
    ///
    /// Collection of evidence documents submitted
    #[prost(message, repeated, tag = "14")]
    pub evidence_documents: ::prost::alloc::vec::Vec<EvidenceDocument>,
    /// Additional Context
    ///
    /// Reason for the dispute
    #[prost(string, optional, tag = "15")]
    pub dispute_reason: ::core::option::Option<::prost::alloc::string::String>,
    /// Message from the disputor
    #[prost(string, optional, tag = "16")]
    pub dispute_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "17")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Request message for setting up a mandate.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceRegisterRequest {
    /// Identification
    ///
    /// Renamed from connector_request_reference_id
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Mandate Details
    ///
    /// The currency for the mandate
    #[prost(enumeration = "Currency", tag = "2")]
    pub currency: i32,
    /// Payment method to be used for the mandate
    #[prost(message, optional, tag = "3")]
    pub payment_method: ::core::option::Option<PaymentMethod>,
    /// Optional: Amount to authorize during mandate setup
    #[prost(int64, optional, tag = "4")]
    pub minor_amount: ::core::option::Option<i64>,
    /// Customer Information
    ///
    /// Email address of the customer
    #[prost(string, optional, tag = "5")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of the customer
    #[prost(string, optional, tag = "6")]
    pub customer_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Customer ID as recognized by the connector
    #[prost(string, optional, tag = "7")]
    pub connector_customer_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Address Information
    ///
    /// Billing address details for the mandate
    #[prost(message, optional, tag = "8")]
    pub address: ::core::option::Option<PaymentAddress>,
    /// Authentication Details
    ///
    /// Type of authentication to be used
    #[prost(enumeration = "AuthenticationType", tag = "9")]
    pub auth_type: i32,
    /// Indicates if the customer is enrolled for 3D Secure
    #[prost(bool, tag = "10")]
    pub enrolled_for_3ds: bool,
    /// Additional authentication data
    #[prost(message, optional, tag = "11")]
    pub authentication_data: ::core::option::Option<AuthenticationData>,
    /// Metadata
    ///
    /// Additional metadata for the connector
    #[prost(map = "string, string", tag = "12")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// URLs for Redirection and Webhooks
    ///
    /// URL to redirect after setup
    #[prost(string, optional, tag = "13")]
    pub return_url: ::core::option::Option<::prost::alloc::string::String>,
    /// URL for webhook notifications
    #[prost(string, optional, tag = "14")]
    pub webhook_url: ::core::option::Option<::prost::alloc::string::String>,
    /// URL to complete authorization
    #[prost(string, optional, tag = "15")]
    pub complete_authorize_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Session and Token Information
    ///
    /// Access token for secure communication
    #[prost(message, optional, tag = "16")]
    pub access_token: ::core::option::Option<AccessToken>,
    /// Session token, if applicable
    #[prost(string, optional, tag = "17")]
    pub session_token: ::core::option::Option<::prost::alloc::string::String>,
    /// Order Details
    ///
    /// Tax amount, if an initial payment is part of setup
    #[prost(int64, optional, tag = "18")]
    pub order_tax_amount: ::core::option::Option<i64>,
    /// Category of the order/service related to the mandate
    #[prost(string, optional, tag = "19")]
    pub order_category: ::core::option::Option<::prost::alloc::string::String>,
    /// Merchant's internal reference ID
    #[prost(string, optional, tag = "20")]
    pub merchant_order_reference_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Shipping cost, if an initial payment is part of setup
    #[prost(int64, optional, tag = "21")]
    pub shipping_cost: ::core::option::Option<i64>,
    /// Behavioral Flags and Preferences
    ///
    /// Indicates future usage intention
    #[prost(enumeration = "FutureUsage", optional, tag = "22")]
    pub setup_future_usage: ::core::option::Option<i32>,
    /// Indicates if off-session process
    #[prost(bool, optional, tag = "23")]
    pub off_session: ::core::option::Option<bool>,
    /// Indicates if incremental authorization is requested
    #[prost(bool, tag = "24")]
    pub request_incremental_authorization: bool,
    /// Indicates if extended authorization is requested
    #[prost(bool, optional, tag = "25")]
    pub request_extended_authorization: ::core::option::Option<bool>,
    /// Contextual Information
    ///
    /// Details of customer acceptance
    #[prost(message, optional, tag = "26")]
    pub customer_acceptance: ::core::option::Option<CustomerAcceptance>,
    /// Information about the customer's browser
    #[prost(message, optional, tag = "27")]
    pub browser_info: ::core::option::Option<BrowserInformation>,
    /// Preferred payment experience
    #[prost(enumeration = "PaymentExperience", optional, tag = "28")]
    pub payment_experience: ::core::option::Option<i32>,
}
/// Response message for a mandate setup operation.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceRegisterResponse {
    /// Identification
    ///
    /// Identifier for the mandate registration
    #[prost(message, optional, tag = "1")]
    pub registration_id: ::core::option::Option<Identifier>,
    /// Status Information
    ///
    /// Status of the mandate setup attempt
    #[prost(enumeration = "MandateStatus", tag = "2")]
    pub status: i32,
    /// Error code if the mandate setup failed
    #[prost(string, optional, tag = "3")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if the mandate setup failed
    #[prost(string, optional, tag = "4")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Mandate Details
    ///
    /// Reference to the created mandate
    #[prost(message, optional, tag = "5")]
    pub mandate_reference: ::core::option::Option<MandateReference>,
    /// Redirection and Transaction Details
    ///
    /// Data for redirecting the customer's browser
    #[prost(message, optional, tag = "6")]
    pub redirection_data: ::core::option::Option<RedirectForm>,
    /// Renamed from network_transaction_id
    #[prost(string, optional, tag = "7")]
    pub network_txn_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Renamed from connector_response_reference_id
    #[prost(message, optional, tag = "8")]
    pub response_ref_id: ::core::option::Option<Identifier>,
    /// Authorization Details
    ///
    /// Indicates if incremental authorization is allowed
    #[prost(bool, optional, tag = "9")]
    pub incremental_authorization_allowed: ::core::option::Option<bool>,
}
/// Request message for repeat payment (MIT - Merchant Initiated Transaction).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceRepeatEverythingRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Mandate Information (required for MIT)
    ///
    /// Reference to existing mandate
    #[prost(message, optional, tag = "2")]
    pub mandate_reference: ::core::option::Option<MandateReference>,
    /// Amount Information
    ///
    /// The amount for the payment in major currency units
    #[prost(int64, tag = "3")]
    pub amount: i64,
    /// The currency for the payment, in ISO 4217 three-letter code
    #[prost(enumeration = "Currency", tag = "4")]
    pub currency: i32,
    /// The minor amount for the payment (e.g., cents)
    #[prost(int64, tag = "5")]
    pub minor_amount: i64,
    /// Optional fields
    ///
    /// Merchant's reference ID for the order
    #[prost(string, optional, tag = "6")]
    pub merchant_order_reference_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Additional metadata for the connector
    #[prost(map = "string, string", tag = "7")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// URL for webhook notifications
    #[prost(string, optional, tag = "8")]
    pub webhook_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Indicates if all keys are required
    #[prost(bool, optional, tag = "9")]
    pub all_keys_required: ::core::option::Option<bool>,
}
/// Response message for repeat payment operation.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceRepeatEverythingResponse {
    /// Identification
    ///
    /// Identifier for the resource created
    #[prost(message, optional, tag = "1")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Status Information
    ///
    /// Status of the payment attempt
    #[prost(enumeration = "PaymentStatus", tag = "2")]
    pub status: i32,
    /// Error code if the payment failed
    #[prost(string, optional, tag = "3")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if the payment failed
    #[prost(string, optional, tag = "4")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Transaction Details
    ///
    /// Transaction ID from the payment network
    #[prost(string, optional, tag = "5")]
    pub network_txn_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference ID from the connector response
    #[prost(message, optional, tag = "6")]
    pub response_ref_id: ::core::option::Option<Identifier>,
    /// Raw Response
    ///
    /// Raw response from the connector for debugging
    #[prost(string, optional, tag = "7")]
    pub raw_connector_response: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request message for PaymentService.Transform RPC
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceTransformRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Request Details
    ///
    /// Details of the incoming HTTP request
    #[prost(message, optional, tag = "2")]
    pub request_details: ::core::option::Option<RequestDetails>,
    /// Security
    ///
    /// Secrets for verifying authenticity
    #[prost(message, optional, tag = "3")]
    pub webhook_secrets: ::core::option::Option<WebhookSecrets>,
}
/// Response message for PaymentService.Transform RPC
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceTransformResponse {
    /// Event Information
    ///
    /// Type of event indicated by the webhook
    #[prost(enumeration = "WebhookEventType", tag = "1")]
    pub event_type: i32,
    /// Content
    ///
    /// Content of the webhook, parsed into a specific response type
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<WebhookResponseContent>,
    /// Verification
    ///
    /// Indicates if the source was successfully verified
    #[prost(bool, tag = "3")]
    pub source_verified: bool,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "4")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Request message for synchronizing refund status.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefundServiceGetRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Renamed from connector_transaction_id
    #[prost(message, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Refund identifier
    #[prost(string, tag = "3")]
    pub refund_id: ::prost::alloc::string::String,
    /// Refund Details
    ///
    /// Reason for the refund, if provided during sync
    #[prost(string, optional, tag = "4")]
    pub refund_reason: ::core::option::Option<::prost::alloc::string::String>,
}
/// Legacy alias for backward compatibility - use RefundResponse instead
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceRefundResponse {
    /// Identification
    ///
    /// Identifier for the synchronized resource
    #[prost(message, optional, tag = "1")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Connector's ID for the refund
    #[prost(string, tag = "2")]
    pub refund_id: ::prost::alloc::string::String,
    /// Status Information
    ///
    /// Current status of the refund
    #[prost(enumeration = "RefundStatus", tag = "3")]
    pub status: i32,
    /// Error code if synchronization encountered an issue
    #[prost(string, optional, tag = "4")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if synchronization encountered an issue
    #[prost(string, optional, tag = "5")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "6")]
    pub response_ref_id: ::core::option::Option<Identifier>,
    /// Refund Details
    ///
    /// Refunded amount in major currency units
    #[prost(int64, optional, tag = "7")]
    pub refund_amount: ::core::option::Option<i64>,
    /// Refunded amount in minor currency units
    #[prost(int64, optional, tag = "8")]
    pub minor_refund_amount: ::core::option::Option<i64>,
    /// Currency of the refund
    #[prost(enumeration = "Currency", optional, tag = "9")]
    pub refund_currency: ::core::option::Option<i32>,
    /// Original payment amount in major currency units
    #[prost(int64, optional, tag = "10")]
    pub payment_amount: ::core::option::Option<i64>,
    /// Original payment amount in minor currency units
    #[prost(int64, optional, tag = "11")]
    pub minor_payment_amount: ::core::option::Option<i64>,
    /// Reason for the refund
    #[prost(string, optional, tag = "12")]
    pub refund_reason: ::core::option::Option<::prost::alloc::string::String>,
    /// Timestamps
    ///
    /// Unix timestamp when the refund was created
    #[prost(int64, optional, tag = "13")]
    pub created_at: ::core::option::Option<i64>,
    /// Unix timestamp when the refund was last updated
    #[prost(int64, optional, tag = "14")]
    pub updated_at: ::core::option::Option<i64>,
    /// Unix timestamp when the refund was processed
    #[prost(int64, optional, tag = "15")]
    pub processed_at: ::core::option::Option<i64>,
    /// Additional Context
    ///
    /// Name of the customer
    #[prost(string, optional, tag = "16")]
    pub customer_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Email address of the customer
    #[prost(string, optional, tag = "17")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Merchant's internal reference ID
    #[prost(string, optional, tag = "18")]
    pub merchant_order_reference_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Additional metadata from the connector
    #[prost(map = "string, string", tag = "19")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Refund-specific metadata from the connector
    #[prost(map = "string, string", tag = "20")]
    pub refund_metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Legacy alias for backward compatibility - use RefundResponse instead
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefundServiceGetResponse {
    /// Identification
    ///
    /// Identifier for the synchronized resource
    #[prost(message, optional, tag = "1")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Renamed from connector_refund_id
    #[prost(string, tag = "2")]
    pub refund_id: ::prost::alloc::string::String,
    /// Status Information
    ///
    /// Current status of the refund
    #[prost(enumeration = "RefundStatus", tag = "3")]
    pub status: i32,
    /// Error code if synchronization encountered an issue
    #[prost(string, optional, tag = "4")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if synchronization encountered an issue
    #[prost(string, optional, tag = "5")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Renamed from connector_response_reference_id
    #[prost(message, optional, tag = "6")]
    pub response_ref_id: ::core::option::Option<Identifier>,
    /// Refund Details
    ///
    /// Refunded amount in major currency units
    #[prost(int64, optional, tag = "7")]
    pub refund_amount: ::core::option::Option<i64>,
    /// Refunded amount in minor currency units
    #[prost(int64, optional, tag = "8")]
    pub minor_refund_amount: ::core::option::Option<i64>,
    /// Currency of the refund
    #[prost(enumeration = "Currency", optional, tag = "9")]
    pub refund_currency: ::core::option::Option<i32>,
    /// Original payment amount in major currency units
    #[prost(int64, optional, tag = "10")]
    pub payment_amount: ::core::option::Option<i64>,
    /// Original payment amount in minor currency units
    #[prost(int64, optional, tag = "11")]
    pub minor_payment_amount: ::core::option::Option<i64>,
    /// Reason for the refund
    #[prost(string, optional, tag = "12")]
    pub refund_reason: ::core::option::Option<::prost::alloc::string::String>,
    /// Timestamps
    ///
    /// Unix timestamp when the refund was created
    #[prost(int64, optional, tag = "13")]
    pub created_at: ::core::option::Option<i64>,
    /// Unix timestamp when the refund was last updated
    #[prost(int64, optional, tag = "14")]
    pub updated_at: ::core::option::Option<i64>,
    /// Unix timestamp when the refund was processed
    #[prost(int64, optional, tag = "15")]
    pub processed_at: ::core::option::Option<i64>,
    /// Additional Context
    ///
    /// Name of the customer
    #[prost(string, optional, tag = "16")]
    pub customer_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Email address of the customer
    #[prost(string, optional, tag = "17")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Merchant's internal reference ID
    #[prost(string, optional, tag = "18")]
    pub merchant_order_reference_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Additional metadata from the connector
    #[prost(map = "string, string", tag = "19")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Refund-specific metadata from the connector
    #[prost(map = "string, string", tag = "20")]
    pub refund_metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Request message for RefundService.Transform RPC
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefundServiceTransformRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Request Details
    ///
    /// Details of the incoming HTTP request
    #[prost(message, optional, tag = "2")]
    pub request_details: ::core::option::Option<RequestDetails>,
    /// Security
    ///
    /// Secrets for verifying authenticity
    #[prost(message, optional, tag = "3")]
    pub webhook_secrets: ::core::option::Option<WebhookSecrets>,
}
/// Response message for RefundService.Transform RPC
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefundServiceTransformResponse {
    /// Event Information
    ///
    /// Type of event indicated by the webhook
    #[prost(enumeration = "WebhookEventType", tag = "1")]
    pub event_type: i32,
    /// Content
    ///
    /// Content of the webhook, parsed into a specific response type
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<WebhookResponseContent>,
    /// Verification
    ///
    /// Indicates if the source was successfully verified
    #[prost(bool, tag = "3")]
    pub source_verified: bool,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "4")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Request message for submitting evidence for a dispute.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisputeServiceSubmitEvidenceRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Merchant's unique identifier for the dispute
    #[prost(message, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Merchant's unique identifier for the dispute
    #[prost(string, tag = "3")]
    pub dispute_id: ::prost::alloc::string::String,
    /// Dates
    ///
    /// Unix timestamp of service date, if applicable
    #[prost(int64, optional, tag = "4")]
    pub service_date: ::core::option::Option<i64>,
    /// Unix timestamp of shipping date, if applicable
    #[prost(int64, optional, tag = "5")]
    pub shipping_date: ::core::option::Option<i64>,
    /// Evidence
    ///
    /// Collection of evidence documents
    #[prost(message, repeated, tag = "6")]
    pub evidence_documents: ::prost::alloc::vec::Vec<EvidenceDocument>,
}
/// Response message for a submit evidence operation.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisputeServiceSubmitEvidenceResponse {
    /// Identification
    ///
    /// Connector's unique identifier for the dispute
    #[prost(string, optional, tag = "1")]
    pub dispute_id: ::core::option::Option<::prost::alloc::string::String>,
    /// IDs of the submitted evidence documents
    #[prost(string, repeated, tag = "2")]
    pub submitted_evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Status Information
    ///
    /// Status of the dispute after submitting evidence
    #[prost(enumeration = "DisputeStatus", tag = "3")]
    pub dispute_status: i32,
    /// Renamed from connector_dispute_status_code
    #[prost(string, optional, tag = "4")]
    pub connector_status_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error code if submitting evidence failed
    #[prost(string, optional, tag = "5")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if submitting evidence failed
    #[prost(string, optional, tag = "6")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "7")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Request message for retrieving dispute information.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisputeServiceGetRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Merchant's unique identifier for the dispute
    #[prost(string, optional, tag = "2")]
    pub dispute_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Connector's unique identifier
    #[prost(string, tag = "3")]
    pub connector_dispute_id: ::prost::alloc::string::String,
}
/// Legacy alias for backward compatibility - use DisputeResponse instead
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentServiceDisputeResponse {
    /// Identification
    ///
    /// Connector's unique identifier for the dispute
    #[prost(string, optional, tag = "1")]
    pub dispute_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Transaction ID associated with the dispute
    #[prost(message, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Status Information
    ///
    /// Status of the dispute
    #[prost(enumeration = "DisputeStatus", tag = "3")]
    pub dispute_status: i32,
    /// Current stage of the dispute
    #[prost(enumeration = "DisputeStage", tag = "4")]
    pub dispute_stage: i32,
    /// Connector status code
    #[prost(string, optional, tag = "5")]
    pub connector_status_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error code if retrieval failed
    #[prost(string, optional, tag = "6")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if retrieval failed
    #[prost(string, optional, tag = "7")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Dispute Details
    ///
    /// Amount in dispute (minor currency units)
    #[prost(int64, optional, tag = "8")]
    pub dispute_amount: ::core::option::Option<i64>,
    /// Currency of the disputed amount
    #[prost(enumeration = "Currency", optional, tag = "9")]
    pub dispute_currency: ::core::option::Option<i32>,
    /// Unix timestamp when dispute was created
    #[prost(int64, optional, tag = "10")]
    pub dispute_date: ::core::option::Option<i64>,
    /// Unix timestamp of service date, if applicable
    #[prost(int64, optional, tag = "11")]
    pub service_date: ::core::option::Option<i64>,
    /// Unix timestamp of shipping date, if applicable
    #[prost(int64, optional, tag = "12")]
    pub shipping_date: ::core::option::Option<i64>,
    /// Unix timestamp of due date for response to dispute
    #[prost(int64, optional, tag = "13")]
    pub due_date: ::core::option::Option<i64>,
    /// Evidence
    ///
    /// Collection of evidence documents submitted
    #[prost(message, repeated, tag = "14")]
    pub evidence_documents: ::prost::alloc::vec::Vec<EvidenceDocument>,
    /// Additional Context
    ///
    /// Reason for the dispute
    #[prost(string, optional, tag = "15")]
    pub dispute_reason: ::core::option::Option<::prost::alloc::string::String>,
    /// Message from the disputor
    #[prost(string, optional, tag = "16")]
    pub dispute_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "17")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Legacy alias for backward compatibility - use DisputeResponse instead
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisputeServiceGetResponse {
    /// Identification
    ///
    /// Connector's unique identifier for the dispute
    #[prost(string, optional, tag = "1")]
    pub dispute_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Transaction ID associated with the dispute
    #[prost(message, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Status Information
    ///
    /// Status of the dispute
    #[prost(enumeration = "DisputeStatus", tag = "3")]
    pub dispute_status: i32,
    /// Current stage of the dispute
    #[prost(enumeration = "DisputeStage", tag = "4")]
    pub dispute_stage: i32,
    /// Renamed from connector_dispute_status_code
    #[prost(string, optional, tag = "5")]
    pub connector_status_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error code if retrieval failed
    #[prost(string, optional, tag = "6")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if retrieval failed
    #[prost(string, optional, tag = "7")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Dispute Details
    ///
    /// Amount in dispute (minor currency units)
    #[prost(int64, optional, tag = "8")]
    pub dispute_amount: ::core::option::Option<i64>,
    /// Currency of the disputed amount
    #[prost(enumeration = "Currency", optional, tag = "9")]
    pub dispute_currency: ::core::option::Option<i32>,
    /// Unix timestamp when dispute was created
    #[prost(int64, optional, tag = "10")]
    pub dispute_date: ::core::option::Option<i64>,
    /// Unix timestamp of service date, if applicable
    #[prost(int64, optional, tag = "11")]
    pub service_date: ::core::option::Option<i64>,
    /// Unix timestamp of shipping date, if applicable
    #[prost(int64, optional, tag = "12")]
    pub shipping_date: ::core::option::Option<i64>,
    /// Unix timestamp of due date for response to dispute
    #[prost(int64, optional, tag = "13")]
    pub due_date: ::core::option::Option<i64>,
    /// Evidence
    ///
    /// Collection of evidence documents submitted
    #[prost(message, repeated, tag = "14")]
    pub evidence_documents: ::prost::alloc::vec::Vec<EvidenceDocument>,
    /// Additional Context
    ///
    /// Reason for the dispute
    #[prost(string, optional, tag = "15")]
    pub dispute_reason: ::core::option::Option<::prost::alloc::string::String>,
    /// Message from the disputor
    #[prost(string, optional, tag = "16")]
    pub dispute_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "17")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Request message for DisputeService.Transform RPC
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisputeServiceTransformRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Request Details
    ///
    /// Details of the incoming HTTP request
    #[prost(message, optional, tag = "2")]
    pub request_details: ::core::option::Option<RequestDetails>,
    /// Security
    ///
    /// Secrets for verifying authenticity
    #[prost(message, optional, tag = "3")]
    pub webhook_secrets: ::core::option::Option<WebhookSecrets>,
}
/// Response message for DisputeService.Transform RPC
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisputeServiceTransformResponse {
    /// Event Information
    ///
    /// Type of event indicated by the webhook
    #[prost(enumeration = "WebhookEventType", tag = "1")]
    pub event_type: i32,
    /// Content
    ///
    /// Content of the webhook, parsed into a specific response type
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<WebhookResponseContent>,
    /// Verification
    ///
    /// Indicates if the source was successfully verified
    #[prost(bool, tag = "3")]
    pub source_verified: bool,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "4")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Request message for defending a dispute.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisputeDefendRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Transaction ID to defend dispute for
    #[prost(message, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Connector's unique identifier
    #[prost(string, tag = "3")]
    pub dispute_id: ::prost::alloc::string::String,
    /// Defend Details
    ///
    /// Reason code for defending the dispute
    #[prost(string, optional, tag = "4")]
    pub reason_code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response message for defending a dispute.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisputeDefendResponse {
    /// Identification
    ///
    /// Connector's unique identifier for the dispute
    #[prost(string, tag = "1")]
    pub dispute_id: ::prost::alloc::string::String,
    /// Status Information
    ///
    /// Status of the dispute after defending
    #[prost(enumeration = "DisputeStatus", tag = "2")]
    pub dispute_status: i32,
    /// Connector status code
    #[prost(string, optional, tag = "3")]
    pub connector_status_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error code if defending failed
    #[prost(string, optional, tag = "4")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if defending failed
    #[prost(string, optional, tag = "5")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "6")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Request message for accepting a dispute.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptDisputeRequest {
    /// Identification
    ///
    /// Reference ID for tracking
    #[prost(message, optional, tag = "1")]
    pub request_ref_id: ::core::option::Option<Identifier>,
    /// Transaction ID to accept dispute for
    #[prost(message, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<Identifier>,
    /// Connector's unique identifier
    #[prost(string, tag = "3")]
    pub dispute_id: ::prost::alloc::string::String,
}
/// Response message for accepting a dispute.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptDisputeResponse {
    /// Identification
    ///
    /// Connector's unique identifier for the dispute
    #[prost(string, tag = "1")]
    pub dispute_id: ::prost::alloc::string::String,
    /// Status Information
    ///
    /// Status of the dispute after accepting
    #[prost(enumeration = "DisputeStatus", tag = "2")]
    pub dispute_status: i32,
    /// Connector status code
    #[prost(string, optional, tag = "3")]
    pub connector_status_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error code if accepting failed
    #[prost(string, optional, tag = "4")]
    pub error_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message if accepting failed
    #[prost(string, optional, tag = "5")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Reference
    ///
    /// Response reference ID for tracking
    #[prost(message, optional, tag = "6")]
    pub response_ref_id: ::core::option::Option<Identifier>,
}
/// Legacy messages for backward compatibility
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisputesSyncResponse {
    #[prost(string, tag = "1")]
    pub dispute_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub connector_response_reference_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3")]
    pub dispute_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "DisputeStatus", tag = "4")]
    pub status: i32,
    #[prost(enumeration = "DisputeStage", tag = "5")]
    pub stage: i32,
}
/// HTTP methods.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HttpMethod {
    /// Default, unspecified HTTP method.
    Unspecified = 0,
    /// HTTP GET method.
    Get = 1,
    /// HTTP POST method.
    Post = 2,
    /// HTTP PUT method.
    Put = 3,
    /// HTTP DELETE method.
    Delete = 4,
}
impl HttpMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HttpMethod::Unspecified => "HTTP_METHOD_UNSPECIFIED",
            HttpMethod::Get => "GET",
            HttpMethod::Post => "POST",
            HttpMethod::Put => "PUT",
            HttpMethod::Delete => "DELETE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HTTP_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
            "GET" => Some(Self::Get),
            "POST" => Some(Self::Post),
            "PUT" => Some(Self::Put),
            "DELETE" => Some(Self::Delete),
            _ => None,
        }
    }
}
/// Status of a payment attempt.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PaymentStatus {
    /// Default value
    AttemptStatusUnspecified = 0,
    /// Initial states
    Started = 1,
    /// Waiting for customer to provide payment method
    PaymentMethodAwaited = 22,
    /// Waiting for device data collection
    DeviceDataCollectionPending = 24,
    /// Waiting for customer confirmation
    ConfirmationAwaited = 23,
    /// Authentication flow
    AuthenticationPending = 4,
    AuthenticationSuccessful = 5,
    AuthenticationFailed = 2,
    /// Authorization flow
    Authorizing = 9,
    Authorized = 6,
    AuthorizationFailed = 7,
    /// Charging flow
    Charged = 8,
    PartialCharged = 17,
    /// Partially charged, remaining amount can be captured
    PartialChargedAndChargeable = 18,
    AutoRefunded = 16,
    /// Capture flow
    CaptureInitiated = 13,
    CaptureFailed = 14,
    /// Void flow
    VoidInitiated = 12,
    Voided = 11,
    VoidFailed = 15,
    /// Other payment flows
    ///
    /// Cash on Delivery initiated
    CodInitiated = 10,
    /// Terminal/fallback states
    RouterDeclined = 3,
    /// General pending state
    Pending = 20,
    /// General failure state
    Failure = 21,
    /// Status could not be determined
    Unresolved = 19,
}
impl PaymentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PaymentStatus::AttemptStatusUnspecified => "ATTEMPT_STATUS_UNSPECIFIED",
            PaymentStatus::Started => "STARTED",
            PaymentStatus::PaymentMethodAwaited => "PAYMENT_METHOD_AWAITED",
            PaymentStatus::DeviceDataCollectionPending => {
                "DEVICE_DATA_COLLECTION_PENDING"
            }
            PaymentStatus::ConfirmationAwaited => "CONFIRMATION_AWAITED",
            PaymentStatus::AuthenticationPending => "AUTHENTICATION_PENDING",
            PaymentStatus::AuthenticationSuccessful => "AUTHENTICATION_SUCCESSFUL",
            PaymentStatus::AuthenticationFailed => "AUTHENTICATION_FAILED",
            PaymentStatus::Authorizing => "AUTHORIZING",
            PaymentStatus::Authorized => "AUTHORIZED",
            PaymentStatus::AuthorizationFailed => "AUTHORIZATION_FAILED",
            PaymentStatus::Charged => "CHARGED",
            PaymentStatus::PartialCharged => "PARTIAL_CHARGED",
            PaymentStatus::PartialChargedAndChargeable => {
                "PARTIAL_CHARGED_AND_CHARGEABLE"
            }
            PaymentStatus::AutoRefunded => "AUTO_REFUNDED",
            PaymentStatus::CaptureInitiated => "CAPTURE_INITIATED",
            PaymentStatus::CaptureFailed => "CAPTURE_FAILED",
            PaymentStatus::VoidInitiated => "VOID_INITIATED",
            PaymentStatus::Voided => "VOIDED",
            PaymentStatus::VoidFailed => "VOID_FAILED",
            PaymentStatus::CodInitiated => "COD_INITIATED",
            PaymentStatus::RouterDeclined => "ROUTER_DECLINED",
            PaymentStatus::Pending => "PENDING",
            PaymentStatus::Failure => "FAILURE",
            PaymentStatus::Unresolved => "UNRESOLVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ATTEMPT_STATUS_UNSPECIFIED" => Some(Self::AttemptStatusUnspecified),
            "STARTED" => Some(Self::Started),
            "PAYMENT_METHOD_AWAITED" => Some(Self::PaymentMethodAwaited),
            "DEVICE_DATA_COLLECTION_PENDING" => Some(Self::DeviceDataCollectionPending),
            "CONFIRMATION_AWAITED" => Some(Self::ConfirmationAwaited),
            "AUTHENTICATION_PENDING" => Some(Self::AuthenticationPending),
            "AUTHENTICATION_SUCCESSFUL" => Some(Self::AuthenticationSuccessful),
            "AUTHENTICATION_FAILED" => Some(Self::AuthenticationFailed),
            "AUTHORIZING" => Some(Self::Authorizing),
            "AUTHORIZED" => Some(Self::Authorized),
            "AUTHORIZATION_FAILED" => Some(Self::AuthorizationFailed),
            "CHARGED" => Some(Self::Charged),
            "PARTIAL_CHARGED" => Some(Self::PartialCharged),
            "PARTIAL_CHARGED_AND_CHARGEABLE" => Some(Self::PartialChargedAndChargeable),
            "AUTO_REFUNDED" => Some(Self::AutoRefunded),
            "CAPTURE_INITIATED" => Some(Self::CaptureInitiated),
            "CAPTURE_FAILED" => Some(Self::CaptureFailed),
            "VOID_INITIATED" => Some(Self::VoidInitiated),
            "VOIDED" => Some(Self::Voided),
            "VOID_FAILED" => Some(Self::VoidFailed),
            "COD_INITIATED" => Some(Self::CodInitiated),
            "ROUTER_DECLINED" => Some(Self::RouterDeclined),
            "PENDING" => Some(Self::Pending),
            "FAILURE" => Some(Self::Failure),
            "UNRESOLVED" => Some(Self::Unresolved),
            _ => None,
        }
    }
}
/// Status of a mandate setup attempt.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MandateStatus {
    /// Default value
    Unspecified = 0,
    /// Initial states
    ///
    /// Mandate setup has been initiated
    MandateInitiated = 1,
    /// Mandate setup is pending (waiting for processing)
    MandatePending = 2,
    /// Authentication flow
    ///
    /// Waiting for customer authentication
    MandateAuthenticationPending = 3,
    /// Customer authentication successful
    MandateAuthenticationSuccessful = 4,
    /// Customer authentication failed
    MandateAuthenticationFailed = 5,
    /// Setup completion states
    ///
    /// Mandate has been successfully established
    MandateEstablished = 6,
    /// Mandate setup failed
    MandateFailed = 7,
    /// Mandate setup was cancelled
    MandateCancelled = 8,
    /// Mandate setup expired
    MandateExpired = 9,
    /// Terminal/fallback states
    ///
    /// Mandate declined by router
    MandateRouterDeclined = 10,
    /// Status could not be determined
    MandateUnresolved = 11,
}
impl MandateStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MandateStatus::Unspecified => "MANDATE_STATUS_UNSPECIFIED",
            MandateStatus::MandateInitiated => "MANDATE_INITIATED",
            MandateStatus::MandatePending => "MANDATE_PENDING",
            MandateStatus::MandateAuthenticationPending => {
                "MANDATE_AUTHENTICATION_PENDING"
            }
            MandateStatus::MandateAuthenticationSuccessful => {
                "MANDATE_AUTHENTICATION_SUCCESSFUL"
            }
            MandateStatus::MandateAuthenticationFailed => "MANDATE_AUTHENTICATION_FAILED",
            MandateStatus::MandateEstablished => "MANDATE_ESTABLISHED",
            MandateStatus::MandateFailed => "MANDATE_FAILED",
            MandateStatus::MandateCancelled => "MANDATE_CANCELLED",
            MandateStatus::MandateExpired => "MANDATE_EXPIRED",
            MandateStatus::MandateRouterDeclined => "MANDATE_ROUTER_DECLINED",
            MandateStatus::MandateUnresolved => "MANDATE_UNRESOLVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MANDATE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "MANDATE_INITIATED" => Some(Self::MandateInitiated),
            "MANDATE_PENDING" => Some(Self::MandatePending),
            "MANDATE_AUTHENTICATION_PENDING" => Some(Self::MandateAuthenticationPending),
            "MANDATE_AUTHENTICATION_SUCCESSFUL" => {
                Some(Self::MandateAuthenticationSuccessful)
            }
            "MANDATE_AUTHENTICATION_FAILED" => Some(Self::MandateAuthenticationFailed),
            "MANDATE_ESTABLISHED" => Some(Self::MandateEstablished),
            "MANDATE_FAILED" => Some(Self::MandateFailed),
            "MANDATE_CANCELLED" => Some(Self::MandateCancelled),
            "MANDATE_EXPIRED" => Some(Self::MandateExpired),
            "MANDATE_ROUTER_DECLINED" => Some(Self::MandateRouterDeclined),
            "MANDATE_UNRESOLVED" => Some(Self::MandateUnresolved),
            _ => None,
        }
    }
}
/// Status of a refund.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RefundStatus {
    /// Default value
    Unspecified = 0,
    RefundFailure = 1,
    /// Refund requires manual review
    RefundManualReview = 2,
    RefundPending = 3,
    RefundSuccess = 4,
    /// Failure at the transaction level for the refund
    RefundTransactionFailure = 5,
}
impl RefundStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RefundStatus::Unspecified => "REFUND_STATUS_UNSPECIFIED",
            RefundStatus::RefundFailure => "REFUND_FAILURE",
            RefundStatus::RefundManualReview => "REFUND_MANUAL_REVIEW",
            RefundStatus::RefundPending => "REFUND_PENDING",
            RefundStatus::RefundSuccess => "REFUND_SUCCESS",
            RefundStatus::RefundTransactionFailure => "REFUND_TRANSACTION_FAILURE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REFUND_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "REFUND_FAILURE" => Some(Self::RefundFailure),
            "REFUND_MANUAL_REVIEW" => Some(Self::RefundManualReview),
            "REFUND_PENDING" => Some(Self::RefundPending),
            "REFUND_SUCCESS" => Some(Self::RefundSuccess),
            "REFUND_TRANSACTION_FAILURE" => Some(Self::RefundTransactionFailure),
            _ => None,
        }
    }
}
/// Status of a dispute.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DisputeStatus {
    /// Default value
    Unspecified = 0,
    DisputeOpened = 1,
    DisputeExpired = 2,
    DisputeAccepted = 3,
    DisputeCancelled = 4,
    /// Dispute is being challenged with evidence
    DisputeChallenged = 5,
    DisputeWon = 6,
    DisputeLost = 7,
}
impl DisputeStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DisputeStatus::Unspecified => "DISPUTE_STATUS_UNSPECIFIED",
            DisputeStatus::DisputeOpened => "DISPUTE_OPENED",
            DisputeStatus::DisputeExpired => "DISPUTE_EXPIRED",
            DisputeStatus::DisputeAccepted => "DISPUTE_ACCEPTED",
            DisputeStatus::DisputeCancelled => "DISPUTE_CANCELLED",
            DisputeStatus::DisputeChallenged => "DISPUTE_CHALLENGED",
            DisputeStatus::DisputeWon => "DISPUTE_WON",
            DisputeStatus::DisputeLost => "DISPUTE_LOST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISPUTE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "DISPUTE_OPENED" => Some(Self::DisputeOpened),
            "DISPUTE_EXPIRED" => Some(Self::DisputeExpired),
            "DISPUTE_ACCEPTED" => Some(Self::DisputeAccepted),
            "DISPUTE_CANCELLED" => Some(Self::DisputeCancelled),
            "DISPUTE_CHALLENGED" => Some(Self::DisputeChallenged),
            "DISPUTE_WON" => Some(Self::DisputeWon),
            "DISPUTE_LOST" => Some(Self::DisputeLost),
            _ => None,
        }
    }
}
/// Method for capturing a payment.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CaptureMethod {
    /// Default value
    Unspecified = 0,
    /// Capture is done automatically after authorization.
    Automatic = 1,
    /// Capture must be triggered manually.
    Manual = 2,
    /// Multiple manual captures are possible.
    ManualMultiple = 3,
    /// Capture is scheduled for a later time.
    Scheduled = 4,
    /// Sequential automatic captures.
    SequentialAutomatic = 5,
}
impl CaptureMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CaptureMethod::Unspecified => "CAPTURE_METHOD_UNSPECIFIED",
            CaptureMethod::Automatic => "AUTOMATIC",
            CaptureMethod::Manual => "MANUAL",
            CaptureMethod::ManualMultiple => "MANUAL_MULTIPLE",
            CaptureMethod::Scheduled => "SCHEDULED",
            CaptureMethod::SequentialAutomatic => "SEQUENTIAL_AUTOMATIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CAPTURE_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
            "AUTOMATIC" => Some(Self::Automatic),
            "MANUAL" => Some(Self::Manual),
            "MANUAL_MULTIPLE" => Some(Self::ManualMultiple),
            "SCHEDULED" => Some(Self::Scheduled),
            "SEQUENTIAL_AUTOMATIC" => Some(Self::SequentialAutomatic),
            _ => None,
        }
    }
}
/// Indicates how a payment method might be used in the future.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FutureUsage {
    /// Default value
    Unspecified = 0,
    /// For merchant-initiated transactions (e.g., subscriptions).
    OffSession = 1,
    /// For customer-initiated transactions.
    OnSession = 2,
}
impl FutureUsage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FutureUsage::Unspecified => "FUTURE_USAGE_UNSPECIFIED",
            FutureUsage::OffSession => "OFF_SESSION",
            FutureUsage::OnSession => "ON_SESSION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FUTURE_USAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "OFF_SESSION" => Some(Self::OffSession),
            "ON_SESSION" => Some(Self::OnSession),
            _ => None,
        }
    }
}
/// Type of acceptance.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AcceptanceType {
    /// Default value
    Unspecified = 0,
    /// Acceptance was given online.
    Online = 1,
    /// Acceptance was given offline.
    Offline = 2,
}
impl AcceptanceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AcceptanceType::Unspecified => "ACCEPTANCE_TYPE_UNSPECIFIED",
            AcceptanceType::Online => "ONLINE",
            AcceptanceType::Offline => "OFFLINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACCEPTANCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ONLINE" => Some(Self::Online),
            "OFFLINE" => Some(Self::Offline),
            _ => None,
        }
    }
}
/// Type of authentication used for a payment.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthenticationType {
    /// Default value
    Unspecified = 0,
    /// 3D Secure authentication.
    ThreeDs = 1,
    /// No 3D Secure, or 3DS explicitly bypassed.
    NoThreeDs = 2,
}
impl AuthenticationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AuthenticationType::Unspecified => "AUTHENTICATION_TYPE_UNSPECIFIED",
            AuthenticationType::ThreeDs => "THREE_DS",
            AuthenticationType::NoThreeDs => "NO_THREE_DS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTHENTICATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "THREE_DS" => Some(Self::ThreeDs),
            "NO_THREE_DS" => Some(Self::NoThreeDs),
            _ => None,
        }
    }
}
/// Preferred payment experience for the customer.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PaymentExperience {
    /// Default value
    Unspecified = 0,
    /// Redirect customer to a URL.
    RedirectToUrl = 1,
    /// Invoke a client-side SDK.
    InvokeSdkClient = 2,
    /// Display a QR code.
    DisplayQrCode = 3,
    /// One-click payment experience.
    OneClick = 4,
    /// Link a digital wallet.
    LinkWallet = 5,
    /// Invoke a payment application.
    InvokePaymentApp = 6,
    /// Display a waiting screen.
    DisplayWaitScreen = 7,
    /// Collect an OTP from the customer.
    CollectOtp = 8,
}
impl PaymentExperience {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PaymentExperience::Unspecified => "PAYMENT_EXPERIENCE_UNSPECIFIED",
            PaymentExperience::RedirectToUrl => "REDIRECT_TO_URL",
            PaymentExperience::InvokeSdkClient => "INVOKE_SDK_CLIENT",
            PaymentExperience::DisplayQrCode => "DISPLAY_QR_CODE",
            PaymentExperience::OneClick => "ONE_CLICK",
            PaymentExperience::LinkWallet => "LINK_WALLET",
            PaymentExperience::InvokePaymentApp => "INVOKE_PAYMENT_APP",
            PaymentExperience::DisplayWaitScreen => "DISPLAY_WAIT_SCREEN",
            PaymentExperience::CollectOtp => "COLLECT_OTP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYMENT_EXPERIENCE_UNSPECIFIED" => Some(Self::Unspecified),
            "REDIRECT_TO_URL" => Some(Self::RedirectToUrl),
            "INVOKE_SDK_CLIENT" => Some(Self::InvokeSdkClient),
            "DISPLAY_QR_CODE" => Some(Self::DisplayQrCode),
            "ONE_CLICK" => Some(Self::OneClick),
            "LINK_WALLET" => Some(Self::LinkWallet),
            "INVOKE_PAYMENT_APP" => Some(Self::InvokePaymentApp),
            "DISPLAY_WAIT_SCREEN" => Some(Self::DisplayWaitScreen),
            "COLLECT_OTP" => Some(Self::CollectOtp),
            _ => None,
        }
    }
}
/// Type of event that a webhook can represent.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WebhookEventType {
    /// Default, unspecified webhook event type.
    Unspecified = 0,
    /// Webhook event related to a payment.
    WebhookPayment = 1,
    /// Webhook event related to a refund.
    WebhookRefund = 2,
    /// Webhook event related to a dispute.
    WebhookDispute = 3,
}
impl WebhookEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WebhookEventType::Unspecified => "WEBHOOK_EVENT_TYPE_UNSPECIFIED",
            WebhookEventType::WebhookPayment => "WEBHOOK_PAYMENT",
            WebhookEventType::WebhookRefund => "WEBHOOK_REFUND",
            WebhookEventType::WebhookDispute => "WEBHOOK_DISPUTE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WEBHOOK_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "WEBHOOK_PAYMENT" => Some(Self::WebhookPayment),
            "WEBHOOK_REFUND" => Some(Self::WebhookRefund),
            "WEBHOOK_DISPUTE" => Some(Self::WebhookDispute),
            _ => None,
        }
    }
}
/// Enum for currency codes (ISO 4217).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Currency {
    /// Default value
    Unspecified = 0,
    Aed = 1,
    Afn = 2,
    All = 3,
    Amd = 4,
    Ang = 5,
    Aoa = 6,
    Ars = 7,
    Aud = 8,
    Awg = 9,
    Azn = 10,
    Bam = 11,
    Bbd = 12,
    Bdt = 13,
    Bgn = 14,
    Bhd = 15,
    Bif = 16,
    Bmd = 17,
    Bnd = 18,
    Bob = 19,
    Brl = 20,
    Bsd = 21,
    Btn = 22,
    Bwp = 23,
    Byn = 24,
    Bzd = 25,
    Cad = 26,
    Cdf = 27,
    Chf = 28,
    Clf = 29,
    Clp = 30,
    Cny = 31,
    Cop = 32,
    Crc = 33,
    Cuc = 34,
    Cup = 35,
    Cve = 36,
    Czk = 37,
    Djf = 38,
    Dkk = 39,
    Dop = 40,
    Dzd = 41,
    Egp = 42,
    Ern = 43,
    Etb = 44,
    Eur = 45,
    Fjd = 46,
    Fkp = 47,
    Gbp = 48,
    Gel = 49,
    Ghs = 50,
    Gip = 51,
    Gmd = 52,
    Gnf = 53,
    Gtq = 54,
    Gyd = 55,
    Hkd = 56,
    Hnl = 57,
    Hrk = 58,
    Htg = 59,
    Huf = 60,
    Idr = 61,
    Ils = 62,
    Inr = 63,
    Iqd = 64,
    Irr = 65,
    Isk = 66,
    Jmd = 67,
    Jod = 68,
    Jpy = 69,
    Kes = 70,
    Kgs = 71,
    Khr = 72,
    Kmf = 73,
    Kpw = 74,
    Krw = 75,
    Kwd = 76,
    Kyd = 77,
    Kzt = 78,
    Lak = 79,
    Lbp = 80,
    Lkr = 81,
    Lrd = 82,
    Lsl = 83,
    Lyd = 84,
    Mad = 85,
    Mdl = 86,
    Mga = 87,
    Mkd = 88,
    Mmk = 89,
    Mnt = 90,
    Mop = 91,
    Mru = 92,
    Mur = 93,
    Mvr = 94,
    Mwk = 95,
    Mxn = 96,
    Myr = 97,
    Mzn = 98,
    Nad = 99,
    Ngn = 100,
    Nio = 101,
    Nok = 102,
    Npr = 103,
    Nzd = 104,
    Omr = 105,
    Pab = 106,
    Pen = 107,
    Pgk = 108,
    Php = 109,
    Pkr = 110,
    Pln = 111,
    Pyg = 112,
    Qar = 113,
    Ron = 114,
    Rsd = 115,
    Rub = 116,
    Rwf = 117,
    Sar = 118,
    Sbd = 119,
    Scr = 120,
    Sdg = 121,
    Sek = 122,
    Sgd = 123,
    Shp = 124,
    Sle = 125,
    Sll = 126,
    Sos = 127,
    Srd = 128,
    Ssp = 129,
    /// Obsolete, use STN
    Std = 130,
    Stn = 131,
    Svc = 132,
    Syp = 133,
    Szl = 134,
    Thb = 135,
    Tjs = 136,
    Tmt = 137,
    Tnd = 138,
    Top = 139,
    Try = 140,
    Ttd = 141,
    Twd = 142,
    Tzs = 143,
    Uah = 144,
    Ugx = 145,
    Usd = 146,
    Uyu = 147,
    Uzs = 148,
    Ves = 149,
    Vnd = 150,
    Vuv = 151,
    Wst = 152,
    Xaf = 153,
    Xcd = 154,
    Xof = 155,
    Xpf = 156,
    Yer = 157,
    Zar = 158,
    Zmw = 159,
    Zwl = 160,
}
impl Currency {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Currency::Unspecified => "CURRENCY_UNSPECIFIED",
            Currency::Aed => "AED",
            Currency::Afn => "AFN",
            Currency::All => "ALL",
            Currency::Amd => "AMD",
            Currency::Ang => "ANG",
            Currency::Aoa => "AOA",
            Currency::Ars => "ARS",
            Currency::Aud => "AUD",
            Currency::Awg => "AWG",
            Currency::Azn => "AZN",
            Currency::Bam => "BAM",
            Currency::Bbd => "BBD",
            Currency::Bdt => "BDT",
            Currency::Bgn => "BGN",
            Currency::Bhd => "BHD",
            Currency::Bif => "BIF",
            Currency::Bmd => "BMD",
            Currency::Bnd => "BND",
            Currency::Bob => "BOB",
            Currency::Brl => "BRL",
            Currency::Bsd => "BSD",
            Currency::Btn => "BTN",
            Currency::Bwp => "BWP",
            Currency::Byn => "BYN",
            Currency::Bzd => "BZD",
            Currency::Cad => "CAD",
            Currency::Cdf => "CDF",
            Currency::Chf => "CHF",
            Currency::Clf => "CLF",
            Currency::Clp => "CLP",
            Currency::Cny => "CNY",
            Currency::Cop => "COP",
            Currency::Crc => "CRC",
            Currency::Cuc => "CUC",
            Currency::Cup => "CUP",
            Currency::Cve => "CVE",
            Currency::Czk => "CZK",
            Currency::Djf => "DJF",
            Currency::Dkk => "DKK",
            Currency::Dop => "DOP",
            Currency::Dzd => "DZD",
            Currency::Egp => "EGP",
            Currency::Ern => "ERN",
            Currency::Etb => "ETB",
            Currency::Eur => "EUR",
            Currency::Fjd => "FJD",
            Currency::Fkp => "FKP",
            Currency::Gbp => "GBP",
            Currency::Gel => "GEL",
            Currency::Ghs => "GHS",
            Currency::Gip => "GIP",
            Currency::Gmd => "GMD",
            Currency::Gnf => "GNF",
            Currency::Gtq => "GTQ",
            Currency::Gyd => "GYD",
            Currency::Hkd => "HKD",
            Currency::Hnl => "HNL",
            Currency::Hrk => "HRK",
            Currency::Htg => "HTG",
            Currency::Huf => "HUF",
            Currency::Idr => "IDR",
            Currency::Ils => "ILS",
            Currency::Inr => "INR",
            Currency::Iqd => "IQD",
            Currency::Irr => "IRR",
            Currency::Isk => "ISK",
            Currency::Jmd => "JMD",
            Currency::Jod => "JOD",
            Currency::Jpy => "JPY",
            Currency::Kes => "KES",
            Currency::Kgs => "KGS",
            Currency::Khr => "KHR",
            Currency::Kmf => "KMF",
            Currency::Kpw => "KPW",
            Currency::Krw => "KRW",
            Currency::Kwd => "KWD",
            Currency::Kyd => "KYD",
            Currency::Kzt => "KZT",
            Currency::Lak => "LAK",
            Currency::Lbp => "LBP",
            Currency::Lkr => "LKR",
            Currency::Lrd => "LRD",
            Currency::Lsl => "LSL",
            Currency::Lyd => "LYD",
            Currency::Mad => "MAD",
            Currency::Mdl => "MDL",
            Currency::Mga => "MGA",
            Currency::Mkd => "MKD",
            Currency::Mmk => "MMK",
            Currency::Mnt => "MNT",
            Currency::Mop => "MOP",
            Currency::Mru => "MRU",
            Currency::Mur => "MUR",
            Currency::Mvr => "MVR",
            Currency::Mwk => "MWK",
            Currency::Mxn => "MXN",
            Currency::Myr => "MYR",
            Currency::Mzn => "MZN",
            Currency::Nad => "NAD",
            Currency::Ngn => "NGN",
            Currency::Nio => "NIO",
            Currency::Nok => "NOK",
            Currency::Npr => "NPR",
            Currency::Nzd => "NZD",
            Currency::Omr => "OMR",
            Currency::Pab => "PAB",
            Currency::Pen => "PEN",
            Currency::Pgk => "PGK",
            Currency::Php => "PHP",
            Currency::Pkr => "PKR",
            Currency::Pln => "PLN",
            Currency::Pyg => "PYG",
            Currency::Qar => "QAR",
            Currency::Ron => "RON",
            Currency::Rsd => "RSD",
            Currency::Rub => "RUB",
            Currency::Rwf => "RWF",
            Currency::Sar => "SAR",
            Currency::Sbd => "SBD",
            Currency::Scr => "SCR",
            Currency::Sdg => "SDG",
            Currency::Sek => "SEK",
            Currency::Sgd => "SGD",
            Currency::Shp => "SHP",
            Currency::Sle => "SLE",
            Currency::Sll => "SLL",
            Currency::Sos => "SOS",
            Currency::Srd => "SRD",
            Currency::Ssp => "SSP",
            Currency::Std => "STD",
            Currency::Stn => "STN",
            Currency::Svc => "SVC",
            Currency::Syp => "SYP",
            Currency::Szl => "SZL",
            Currency::Thb => "THB",
            Currency::Tjs => "TJS",
            Currency::Tmt => "TMT",
            Currency::Tnd => "TND",
            Currency::Top => "TOP",
            Currency::Try => "TRY",
            Currency::Ttd => "TTD",
            Currency::Twd => "TWD",
            Currency::Tzs => "TZS",
            Currency::Uah => "UAH",
            Currency::Ugx => "UGX",
            Currency::Usd => "USD",
            Currency::Uyu => "UYU",
            Currency::Uzs => "UZS",
            Currency::Ves => "VES",
            Currency::Vnd => "VND",
            Currency::Vuv => "VUV",
            Currency::Wst => "WST",
            Currency::Xaf => "XAF",
            Currency::Xcd => "XCD",
            Currency::Xof => "XOF",
            Currency::Xpf => "XPF",
            Currency::Yer => "YER",
            Currency::Zar => "ZAR",
            Currency::Zmw => "ZMW",
            Currency::Zwl => "ZWL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CURRENCY_UNSPECIFIED" => Some(Self::Unspecified),
            "AED" => Some(Self::Aed),
            "AFN" => Some(Self::Afn),
            "ALL" => Some(Self::All),
            "AMD" => Some(Self::Amd),
            "ANG" => Some(Self::Ang),
            "AOA" => Some(Self::Aoa),
            "ARS" => Some(Self::Ars),
            "AUD" => Some(Self::Aud),
            "AWG" => Some(Self::Awg),
            "AZN" => Some(Self::Azn),
            "BAM" => Some(Self::Bam),
            "BBD" => Some(Self::Bbd),
            "BDT" => Some(Self::Bdt),
            "BGN" => Some(Self::Bgn),
            "BHD" => Some(Self::Bhd),
            "BIF" => Some(Self::Bif),
            "BMD" => Some(Self::Bmd),
            "BND" => Some(Self::Bnd),
            "BOB" => Some(Self::Bob),
            "BRL" => Some(Self::Brl),
            "BSD" => Some(Self::Bsd),
            "BTN" => Some(Self::Btn),
            "BWP" => Some(Self::Bwp),
            "BYN" => Some(Self::Byn),
            "BZD" => Some(Self::Bzd),
            "CAD" => Some(Self::Cad),
            "CDF" => Some(Self::Cdf),
            "CHF" => Some(Self::Chf),
            "CLF" => Some(Self::Clf),
            "CLP" => Some(Self::Clp),
            "CNY" => Some(Self::Cny),
            "COP" => Some(Self::Cop),
            "CRC" => Some(Self::Crc),
            "CUC" => Some(Self::Cuc),
            "CUP" => Some(Self::Cup),
            "CVE" => Some(Self::Cve),
            "CZK" => Some(Self::Czk),
            "DJF" => Some(Self::Djf),
            "DKK" => Some(Self::Dkk),
            "DOP" => Some(Self::Dop),
            "DZD" => Some(Self::Dzd),
            "EGP" => Some(Self::Egp),
            "ERN" => Some(Self::Ern),
            "ETB" => Some(Self::Etb),
            "EUR" => Some(Self::Eur),
            "FJD" => Some(Self::Fjd),
            "FKP" => Some(Self::Fkp),
            "GBP" => Some(Self::Gbp),
            "GEL" => Some(Self::Gel),
            "GHS" => Some(Self::Ghs),
            "GIP" => Some(Self::Gip),
            "GMD" => Some(Self::Gmd),
            "GNF" => Some(Self::Gnf),
            "GTQ" => Some(Self::Gtq),
            "GYD" => Some(Self::Gyd),
            "HKD" => Some(Self::Hkd),
            "HNL" => Some(Self::Hnl),
            "HRK" => Some(Self::Hrk),
            "HTG" => Some(Self::Htg),
            "HUF" => Some(Self::Huf),
            "IDR" => Some(Self::Idr),
            "ILS" => Some(Self::Ils),
            "INR" => Some(Self::Inr),
            "IQD" => Some(Self::Iqd),
            "IRR" => Some(Self::Irr),
            "ISK" => Some(Self::Isk),
            "JMD" => Some(Self::Jmd),
            "JOD" => Some(Self::Jod),
            "JPY" => Some(Self::Jpy),
            "KES" => Some(Self::Kes),
            "KGS" => Some(Self::Kgs),
            "KHR" => Some(Self::Khr),
            "KMF" => Some(Self::Kmf),
            "KPW" => Some(Self::Kpw),
            "KRW" => Some(Self::Krw),
            "KWD" => Some(Self::Kwd),
            "KYD" => Some(Self::Kyd),
            "KZT" => Some(Self::Kzt),
            "LAK" => Some(Self::Lak),
            "LBP" => Some(Self::Lbp),
            "LKR" => Some(Self::Lkr),
            "LRD" => Some(Self::Lrd),
            "LSL" => Some(Self::Lsl),
            "LYD" => Some(Self::Lyd),
            "MAD" => Some(Self::Mad),
            "MDL" => Some(Self::Mdl),
            "MGA" => Some(Self::Mga),
            "MKD" => Some(Self::Mkd),
            "MMK" => Some(Self::Mmk),
            "MNT" => Some(Self::Mnt),
            "MOP" => Some(Self::Mop),
            "MRU" => Some(Self::Mru),
            "MUR" => Some(Self::Mur),
            "MVR" => Some(Self::Mvr),
            "MWK" => Some(Self::Mwk),
            "MXN" => Some(Self::Mxn),
            "MYR" => Some(Self::Myr),
            "MZN" => Some(Self::Mzn),
            "NAD" => Some(Self::Nad),
            "NGN" => Some(Self::Ngn),
            "NIO" => Some(Self::Nio),
            "NOK" => Some(Self::Nok),
            "NPR" => Some(Self::Npr),
            "NZD" => Some(Self::Nzd),
            "OMR" => Some(Self::Omr),
            "PAB" => Some(Self::Pab),
            "PEN" => Some(Self::Pen),
            "PGK" => Some(Self::Pgk),
            "PHP" => Some(Self::Php),
            "PKR" => Some(Self::Pkr),
            "PLN" => Some(Self::Pln),
            "PYG" => Some(Self::Pyg),
            "QAR" => Some(Self::Qar),
            "RON" => Some(Self::Ron),
            "RSD" => Some(Self::Rsd),
            "RUB" => Some(Self::Rub),
            "RWF" => Some(Self::Rwf),
            "SAR" => Some(Self::Sar),
            "SBD" => Some(Self::Sbd),
            "SCR" => Some(Self::Scr),
            "SDG" => Some(Self::Sdg),
            "SEK" => Some(Self::Sek),
            "SGD" => Some(Self::Sgd),
            "SHP" => Some(Self::Shp),
            "SLE" => Some(Self::Sle),
            "SLL" => Some(Self::Sll),
            "SOS" => Some(Self::Sos),
            "SRD" => Some(Self::Srd),
            "SSP" => Some(Self::Ssp),
            "STD" => Some(Self::Std),
            "STN" => Some(Self::Stn),
            "SVC" => Some(Self::Svc),
            "SYP" => Some(Self::Syp),
            "SZL" => Some(Self::Szl),
            "THB" => Some(Self::Thb),
            "TJS" => Some(Self::Tjs),
            "TMT" => Some(Self::Tmt),
            "TND" => Some(Self::Tnd),
            "TOP" => Some(Self::Top),
            "TRY" => Some(Self::Try),
            "TTD" => Some(Self::Ttd),
            "TWD" => Some(Self::Twd),
            "TZS" => Some(Self::Tzs),
            "UAH" => Some(Self::Uah),
            "UGX" => Some(Self::Ugx),
            "USD" => Some(Self::Usd),
            "UYU" => Some(Self::Uyu),
            "UZS" => Some(Self::Uzs),
            "VES" => Some(Self::Ves),
            "VND" => Some(Self::Vnd),
            "VUV" => Some(Self::Vuv),
            "WST" => Some(Self::Wst),
            "XAF" => Some(Self::Xaf),
            "XCD" => Some(Self::Xcd),
            "XOF" => Some(Self::Xof),
            "XPF" => Some(Self::Xpf),
            "YER" => Some(Self::Yer),
            "ZAR" => Some(Self::Zar),
            "ZMW" => Some(Self::Zmw),
            "ZWL" => Some(Self::Zwl),
            _ => None,
        }
    }
}
/// Connector enumeration.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Connector {
    /// Default value
    Unspecified = 0,
    Adyenplatform = 1,
    Aci = 2,
    Adyen = 3,
    Airwallex = 4,
    Authorizedotnet = 5,
    Bambora = 6,
    Bamboraapac = 7,
    Bankofamerica = 8,
    Billwerk = 9,
    Bitpay = 10,
    Bluesnap = 11,
    Boku = 12,
    Braintree = 13,
    Cashtocode = 14,
    Chargebee = 15,
    Checkout = 16,
    Coinbase = 17,
    Coingate = 18,
    Cryptopay = 19,
    CtpMastercard = 20,
    CtpVisa = 21,
    Cybersource = 22,
    Datatrans = 23,
    Deutschebank = 24,
    Digitalvirgo = 25,
    Dlocal = 26,
    Ebanx = 27,
    Elavon = 28,
    Fiserv = 29,
    Fiservemea = 30,
    Fiuu = 31,
    Forte = 32,
    Getnet = 33,
    Globalpay = 34,
    Globepay = 35,
    Gocardless = 36,
    Gpayments = 37,
    Hipay = 38,
    Helcim = 39,
    Inespay = 40,
    Iatapay = 41,
    Itaubank = 42,
    Jpmorgan = 43,
    Juspaythreedsserver = 44,
    Klarna = 45,
    Mifinity = 46,
    Mollie = 47,
    Moneris = 48,
    Multisafepay = 49,
    Netcetera = 50,
    Nexinets = 51,
    Nexixpay = 52,
    Nmi = 53,
    Nomupay = 54,
    Noon = 55,
    Novalnet = 56,
    Nuvei = 57,
    Opennode = 58,
    Paybox = 59,
    Payme = 60,
    Payone = 61,
    Paypal = 62,
    Paystack = 63,
    Payu = 64,
    Placetopay = 65,
    Powertranz = 66,
    Prophetpay = 67,
    Rapyd = 68,
    Razorpay = 69,
    Recurly = 70,
    Redsys = 71,
    Shift4 = 72,
    Square = 73,
    Stax = 74,
    Stripe = 75,
    Taxjar = 76,
    Threedsecureio = 77,
    Trustpay = 78,
    Tsys = 79,
    Volt = 80,
    Wellsfargo = 81,
    Wise = 82,
    Worldline = 83,
    Worldpay = 84,
    Signifyd = 85,
    Plaid = 86,
    Riskified = 87,
    Xendit = 88,
    Zen = 89,
    Zsl = 90,
    Phonepe = 91,
    Cashfree = 92,
}
impl Connector {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Connector::Unspecified => "CONNECTOR_UNSPECIFIED",
            Connector::Adyenplatform => "ADYENPLATFORM",
            Connector::Aci => "ACI",
            Connector::Adyen => "ADYEN",
            Connector::Airwallex => "AIRWALLEX",
            Connector::Authorizedotnet => "AUTHORIZEDOTNET",
            Connector::Bambora => "BAMBORA",
            Connector::Bamboraapac => "BAMBORAAPAC",
            Connector::Bankofamerica => "BANKOFAMERICA",
            Connector::Billwerk => "BILLWERK",
            Connector::Bitpay => "BITPAY",
            Connector::Bluesnap => "BLUESNAP",
            Connector::Boku => "BOKU",
            Connector::Braintree => "BRAINTREE",
            Connector::Cashtocode => "CASHTOCODE",
            Connector::Chargebee => "CHARGEBEE",
            Connector::Checkout => "CHECKOUT",
            Connector::Coinbase => "COINBASE",
            Connector::Coingate => "COINGATE",
            Connector::Cryptopay => "CRYPTOPAY",
            Connector::CtpMastercard => "CTP_MASTERCARD",
            Connector::CtpVisa => "CTP_VISA",
            Connector::Cybersource => "CYBERSOURCE",
            Connector::Datatrans => "DATATRANS",
            Connector::Deutschebank => "DEUTSCHEBANK",
            Connector::Digitalvirgo => "DIGITALVIRGO",
            Connector::Dlocal => "DLOCAL",
            Connector::Ebanx => "EBANX",
            Connector::Elavon => "ELAVON",
            Connector::Fiserv => "FISERV",
            Connector::Fiservemea => "FISERVEMEA",
            Connector::Fiuu => "FIUU",
            Connector::Forte => "FORTE",
            Connector::Getnet => "GETNET",
            Connector::Globalpay => "GLOBALPAY",
            Connector::Globepay => "GLOBEPAY",
            Connector::Gocardless => "GOCARDLESS",
            Connector::Gpayments => "GPAYMENTS",
            Connector::Hipay => "HIPAY",
            Connector::Helcim => "HELCIM",
            Connector::Inespay => "INESPAY",
            Connector::Iatapay => "IATAPAY",
            Connector::Itaubank => "ITAUBANK",
            Connector::Jpmorgan => "JPMORGAN",
            Connector::Juspaythreedsserver => "JUSPAYTHREEDSSERVER",
            Connector::Klarna => "KLARNA",
            Connector::Mifinity => "MIFINITY",
            Connector::Mollie => "MOLLIE",
            Connector::Moneris => "MONERIS",
            Connector::Multisafepay => "MULTISAFEPAY",
            Connector::Netcetera => "NETCETERA",
            Connector::Nexinets => "NEXINETS",
            Connector::Nexixpay => "NEXIXPAY",
            Connector::Nmi => "NMI",
            Connector::Nomupay => "NOMUPAY",
            Connector::Noon => "NOON",
            Connector::Novalnet => "NOVALNET",
            Connector::Nuvei => "NUVEI",
            Connector::Opennode => "OPENNODE",
            Connector::Paybox => "PAYBOX",
            Connector::Payme => "PAYME",
            Connector::Payone => "PAYONE",
            Connector::Paypal => "PAYPAL",
            Connector::Paystack => "PAYSTACK",
            Connector::Payu => "PAYU",
            Connector::Placetopay => "PLACETOPAY",
            Connector::Powertranz => "POWERTRANZ",
            Connector::Prophetpay => "PROPHETPAY",
            Connector::Rapyd => "RAPYD",
            Connector::Razorpay => "RAZORPAY",
            Connector::Recurly => "RECURLY",
            Connector::Redsys => "REDSYS",
            Connector::Shift4 => "SHIFT4",
            Connector::Square => "SQUARE",
            Connector::Stax => "STAX",
            Connector::Stripe => "STRIPE",
            Connector::Taxjar => "TAXJAR",
            Connector::Threedsecureio => "THREEDSECUREIO",
            Connector::Trustpay => "TRUSTPAY",
            Connector::Tsys => "TSYS",
            Connector::Volt => "VOLT",
            Connector::Wellsfargo => "WELLSFARGO",
            Connector::Wise => "WISE",
            Connector::Worldline => "WORLDLINE",
            Connector::Worldpay => "WORLDPAY",
            Connector::Signifyd => "SIGNIFYD",
            Connector::Plaid => "PLAID",
            Connector::Riskified => "RISKIFIED",
            Connector::Xendit => "XENDIT",
            Connector::Zen => "ZEN",
            Connector::Zsl => "ZSL",
            Connector::Phonepe => "PHONEPE",
            Connector::Cashfree => "CASHFREE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONNECTOR_UNSPECIFIED" => Some(Self::Unspecified),
            "ADYENPLATFORM" => Some(Self::Adyenplatform),
            "ACI" => Some(Self::Aci),
            "ADYEN" => Some(Self::Adyen),
            "AIRWALLEX" => Some(Self::Airwallex),
            "AUTHORIZEDOTNET" => Some(Self::Authorizedotnet),
            "BAMBORA" => Some(Self::Bambora),
            "BAMBORAAPAC" => Some(Self::Bamboraapac),
            "BANKOFAMERICA" => Some(Self::Bankofamerica),
            "BILLWERK" => Some(Self::Billwerk),
            "BITPAY" => Some(Self::Bitpay),
            "BLUESNAP" => Some(Self::Bluesnap),
            "BOKU" => Some(Self::Boku),
            "BRAINTREE" => Some(Self::Braintree),
            "CASHTOCODE" => Some(Self::Cashtocode),
            "CHARGEBEE" => Some(Self::Chargebee),
            "CHECKOUT" => Some(Self::Checkout),
            "COINBASE" => Some(Self::Coinbase),
            "COINGATE" => Some(Self::Coingate),
            "CRYPTOPAY" => Some(Self::Cryptopay),
            "CTP_MASTERCARD" => Some(Self::CtpMastercard),
            "CTP_VISA" => Some(Self::CtpVisa),
            "CYBERSOURCE" => Some(Self::Cybersource),
            "DATATRANS" => Some(Self::Datatrans),
            "DEUTSCHEBANK" => Some(Self::Deutschebank),
            "DIGITALVIRGO" => Some(Self::Digitalvirgo),
            "DLOCAL" => Some(Self::Dlocal),
            "EBANX" => Some(Self::Ebanx),
            "ELAVON" => Some(Self::Elavon),
            "FISERV" => Some(Self::Fiserv),
            "FISERVEMEA" => Some(Self::Fiservemea),
            "FIUU" => Some(Self::Fiuu),
            "FORTE" => Some(Self::Forte),
            "GETNET" => Some(Self::Getnet),
            "GLOBALPAY" => Some(Self::Globalpay),
            "GLOBEPAY" => Some(Self::Globepay),
            "GOCARDLESS" => Some(Self::Gocardless),
            "GPAYMENTS" => Some(Self::Gpayments),
            "HIPAY" => Some(Self::Hipay),
            "HELCIM" => Some(Self::Helcim),
            "INESPAY" => Some(Self::Inespay),
            "IATAPAY" => Some(Self::Iatapay),
            "ITAUBANK" => Some(Self::Itaubank),
            "JPMORGAN" => Some(Self::Jpmorgan),
            "JUSPAYTHREEDSSERVER" => Some(Self::Juspaythreedsserver),
            "KLARNA" => Some(Self::Klarna),
            "MIFINITY" => Some(Self::Mifinity),
            "MOLLIE" => Some(Self::Mollie),
            "MONERIS" => Some(Self::Moneris),
            "MULTISAFEPAY" => Some(Self::Multisafepay),
            "NETCETERA" => Some(Self::Netcetera),
            "NEXINETS" => Some(Self::Nexinets),
            "NEXIXPAY" => Some(Self::Nexixpay),
            "NMI" => Some(Self::Nmi),
            "NOMUPAY" => Some(Self::Nomupay),
            "NOON" => Some(Self::Noon),
            "NOVALNET" => Some(Self::Novalnet),
            "NUVEI" => Some(Self::Nuvei),
            "OPENNODE" => Some(Self::Opennode),
            "PAYBOX" => Some(Self::Paybox),
            "PAYME" => Some(Self::Payme),
            "PAYONE" => Some(Self::Payone),
            "PAYPAL" => Some(Self::Paypal),
            "PAYSTACK" => Some(Self::Paystack),
            "PAYU" => Some(Self::Payu),
            "PLACETOPAY" => Some(Self::Placetopay),
            "POWERTRANZ" => Some(Self::Powertranz),
            "PROPHETPAY" => Some(Self::Prophetpay),
            "RAPYD" => Some(Self::Rapyd),
            "RAZORPAY" => Some(Self::Razorpay),
            "RECURLY" => Some(Self::Recurly),
            "REDSYS" => Some(Self::Redsys),
            "SHIFT4" => Some(Self::Shift4),
            "SQUARE" => Some(Self::Square),
            "STAX" => Some(Self::Stax),
            "STRIPE" => Some(Self::Stripe),
            "TAXJAR" => Some(Self::Taxjar),
            "THREEDSECUREIO" => Some(Self::Threedsecureio),
            "TRUSTPAY" => Some(Self::Trustpay),
            "TSYS" => Some(Self::Tsys),
            "VOLT" => Some(Self::Volt),
            "WELLSFARGO" => Some(Self::Wellsfargo),
            "WISE" => Some(Self::Wise),
            "WORLDLINE" => Some(Self::Worldline),
            "WORLDPAY" => Some(Self::Worldpay),
            "SIGNIFYD" => Some(Self::Signifyd),
            "PLAID" => Some(Self::Plaid),
            "RISKIFIED" => Some(Self::Riskified),
            "XENDIT" => Some(Self::Xendit),
            "ZEN" => Some(Self::Zen),
            "ZSL" => Some(Self::Zsl),
            "PHONEPE" => Some(Self::Phonepe),
            "CASHFREE" => Some(Self::Cashfree),
            _ => None,
        }
    }
}
/// Payment method types.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PaymentMethodType {
    /// Default value
    Unspecified = 0,
    Ach = 1,
    Affirm = 2,
    AfterpayClearpay = 3,
    Alfamart = 4,
    AliPay = 5,
    AliPayHk = 6,
    Alma = 7,
    AmazonPay = 8,
    ApplePay = 9,
    Atome = 10,
    Bacs = 11,
    BancontactCard = 12,
    Becs = 13,
    Benefit = 14,
    Bizum = 15,
    Blik = 16,
    Boleto = 17,
    BcaBankTransfer = 18,
    BniVa = 19,
    BriVa = 20,
    CardRedirect = 21,
    CimbVa = 22,
    ClassicReward = 23,
    Credit = 24,
    CryptoCurrency = 25,
    Cashapp = 26,
    Dana = 27,
    DanamonVa = 28,
    Debit = 29,
    DuitNow = 30,
    Efecty = 31,
    Eft = 32,
    Eps = 33,
    Fps = 34,
    Evoucher = 35,
    Giropay = 36,
    Givex = 37,
    GooglePay = 38,
    GoPay = 39,
    Gcash = 40,
    Ideal = 41,
    Interac = 42,
    Indomaret = 43,
    KakaoPay = 44,
    LocalBankRedirect = 45,
    MandiriVa = 46,
    Knet = 47,
    MbWay = 48,
    MobilePay = 49,
    Momo = 50,
    MomoAtm = 51,
    Multibanco = 52,
    OnlineBankingThailand = 53,
    OnlineBankingCzechRepublic = 54,
    OnlineBankingFinland = 55,
    OnlineBankingFpx = 56,
    OnlineBankingPoland = 57,
    OnlineBankingSlovakia = 58,
    Oxxo = 59,
    PagoEfectivo = 60,
    PermataBankTransfer = 61,
    OpenBankingUk = 62,
    PayBright = 63,
    Paze = 64,
    Pix = 65,
    PaySafeCard = 66,
    Przelewy24 = 67,
    PromptPay = 68,
    Pse = 69,
    RedCompra = 70,
    RedPagos = 71,
    SamsungPay = 72,
    Sepa = 73,
    SepaBankTransfer = 74,
    Sofort = 75,
    Swish = 76,
    TouchNGo = 77,
    Trustly = 78,
    Twint = 79,
    UpiCollect = 80,
    UpiIntent = 81,
    Vipps = 82,
    VietQr = 83,
    Venmo = 84,
    Walley = 85,
    WeChatPay = 86,
    SevenEleven = 87,
    Lawson = 88,
    MiniStop = 89,
    FamilyMart = 90,
    Seicomart = 91,
    PayEasy = 92,
    LocalBankTransfer = 93,
    OpenBankingPis = 94,
    DirectCarrierBilling = 95,
    InstantBankTransfer = 96,
}
impl PaymentMethodType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PaymentMethodType::Unspecified => "PAYMENT_METHOD_TYPE_UNSPECIFIED",
            PaymentMethodType::Ach => "ACH",
            PaymentMethodType::Affirm => "AFFIRM",
            PaymentMethodType::AfterpayClearpay => "AFTERPAY_CLEARPAY",
            PaymentMethodType::Alfamart => "ALFAMART",
            PaymentMethodType::AliPay => "ALI_PAY",
            PaymentMethodType::AliPayHk => "ALI_PAY_HK",
            PaymentMethodType::Alma => "ALMA",
            PaymentMethodType::AmazonPay => "AMAZON_PAY",
            PaymentMethodType::ApplePay => "APPLE_PAY",
            PaymentMethodType::Atome => "ATOME",
            PaymentMethodType::Bacs => "BACS",
            PaymentMethodType::BancontactCard => "BANCONTACT_CARD",
            PaymentMethodType::Becs => "BECS",
            PaymentMethodType::Benefit => "BENEFIT",
            PaymentMethodType::Bizum => "BIZUM",
            PaymentMethodType::Blik => "BLIK",
            PaymentMethodType::Boleto => "BOLETO",
            PaymentMethodType::BcaBankTransfer => "BCA_BANK_TRANSFER",
            PaymentMethodType::BniVa => "BNI_VA",
            PaymentMethodType::BriVa => "BRI_VA",
            PaymentMethodType::CardRedirect => "CARD_REDIRECT",
            PaymentMethodType::CimbVa => "CIMB_VA",
            PaymentMethodType::ClassicReward => "CLASSIC_REWARD",
            PaymentMethodType::Credit => "CREDIT",
            PaymentMethodType::CryptoCurrency => "CRYPTO_CURRENCY",
            PaymentMethodType::Cashapp => "CASHAPP",
            PaymentMethodType::Dana => "DANA",
            PaymentMethodType::DanamonVa => "DANAMON_VA",
            PaymentMethodType::Debit => "DEBIT",
            PaymentMethodType::DuitNow => "DUIT_NOW",
            PaymentMethodType::Efecty => "EFECTY",
            PaymentMethodType::Eft => "EFT",
            PaymentMethodType::Eps => "EPS",
            PaymentMethodType::Fps => "FPS",
            PaymentMethodType::Evoucher => "EVOUCHER",
            PaymentMethodType::Giropay => "GIROPAY",
            PaymentMethodType::Givex => "GIVEX",
            PaymentMethodType::GooglePay => "GOOGLE_PAY",
            PaymentMethodType::GoPay => "GO_PAY",
            PaymentMethodType::Gcash => "GCASH",
            PaymentMethodType::Ideal => "IDEAL",
            PaymentMethodType::Interac => "INTERAC",
            PaymentMethodType::Indomaret => "INDOMARET",
            PaymentMethodType::KakaoPay => "KAKAO_PAY",
            PaymentMethodType::LocalBankRedirect => "LOCAL_BANK_REDIRECT",
            PaymentMethodType::MandiriVa => "MANDIRI_VA",
            PaymentMethodType::Knet => "KNET",
            PaymentMethodType::MbWay => "MB_WAY",
            PaymentMethodType::MobilePay => "MOBILE_PAY",
            PaymentMethodType::Momo => "MOMO",
            PaymentMethodType::MomoAtm => "MOMO_ATM",
            PaymentMethodType::Multibanco => "MULTIBANCO",
            PaymentMethodType::OnlineBankingThailand => "ONLINE_BANKING_THAILAND",
            PaymentMethodType::OnlineBankingCzechRepublic => {
                "ONLINE_BANKING_CZECH_REPUBLIC"
            }
            PaymentMethodType::OnlineBankingFinland => "ONLINE_BANKING_FINLAND",
            PaymentMethodType::OnlineBankingFpx => "ONLINE_BANKING_FPX",
            PaymentMethodType::OnlineBankingPoland => "ONLINE_BANKING_POLAND",
            PaymentMethodType::OnlineBankingSlovakia => "ONLINE_BANKING_SLOVAKIA",
            PaymentMethodType::Oxxo => "OXXO",
            PaymentMethodType::PagoEfectivo => "PAGO_EFECTIVO",
            PaymentMethodType::PermataBankTransfer => "PERMATA_BANK_TRANSFER",
            PaymentMethodType::OpenBankingUk => "OPEN_BANKING_UK",
            PaymentMethodType::PayBright => "PAY_BRIGHT",
            PaymentMethodType::Paze => "PAZE",
            PaymentMethodType::Pix => "PIX",
            PaymentMethodType::PaySafeCard => "PAY_SAFE_CARD",
            PaymentMethodType::Przelewy24 => "PRZELEWY24",
            PaymentMethodType::PromptPay => "PROMPT_PAY",
            PaymentMethodType::Pse => "PSE",
            PaymentMethodType::RedCompra => "RED_COMPRA",
            PaymentMethodType::RedPagos => "RED_PAGOS",
            PaymentMethodType::SamsungPay => "SAMSUNG_PAY",
            PaymentMethodType::Sepa => "SEPA",
            PaymentMethodType::SepaBankTransfer => "SEPA_BANK_TRANSFER",
            PaymentMethodType::Sofort => "SOFORT",
            PaymentMethodType::Swish => "SWISH",
            PaymentMethodType::TouchNGo => "TOUCH_N_GO",
            PaymentMethodType::Trustly => "TRUSTLY",
            PaymentMethodType::Twint => "TWINT",
            PaymentMethodType::UpiCollect => "UPI_COLLECT",
            PaymentMethodType::UpiIntent => "UPI_INTENT",
            PaymentMethodType::Vipps => "VIPPS",
            PaymentMethodType::VietQr => "VIET_QR",
            PaymentMethodType::Venmo => "VENMO",
            PaymentMethodType::Walley => "WALLEY",
            PaymentMethodType::WeChatPay => "WE_CHAT_PAY",
            PaymentMethodType::SevenEleven => "SEVEN_ELEVEN",
            PaymentMethodType::Lawson => "LAWSON",
            PaymentMethodType::MiniStop => "MINI_STOP",
            PaymentMethodType::FamilyMart => "FAMILY_MART",
            PaymentMethodType::Seicomart => "SEICOMART",
            PaymentMethodType::PayEasy => "PAY_EASY",
            PaymentMethodType::LocalBankTransfer => "LOCAL_BANK_TRANSFER",
            PaymentMethodType::OpenBankingPis => "OPEN_BANKING_PIS",
            PaymentMethodType::DirectCarrierBilling => "DIRECT_CARRIER_BILLING",
            PaymentMethodType::InstantBankTransfer => "INSTANT_BANK_TRANSFER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYMENT_METHOD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACH" => Some(Self::Ach),
            "AFFIRM" => Some(Self::Affirm),
            "AFTERPAY_CLEARPAY" => Some(Self::AfterpayClearpay),
            "ALFAMART" => Some(Self::Alfamart),
            "ALI_PAY" => Some(Self::AliPay),
            "ALI_PAY_HK" => Some(Self::AliPayHk),
            "ALMA" => Some(Self::Alma),
            "AMAZON_PAY" => Some(Self::AmazonPay),
            "APPLE_PAY" => Some(Self::ApplePay),
            "ATOME" => Some(Self::Atome),
            "BACS" => Some(Self::Bacs),
            "BANCONTACT_CARD" => Some(Self::BancontactCard),
            "BECS" => Some(Self::Becs),
            "BENEFIT" => Some(Self::Benefit),
            "BIZUM" => Some(Self::Bizum),
            "BLIK" => Some(Self::Blik),
            "BOLETO" => Some(Self::Boleto),
            "BCA_BANK_TRANSFER" => Some(Self::BcaBankTransfer),
            "BNI_VA" => Some(Self::BniVa),
            "BRI_VA" => Some(Self::BriVa),
            "CARD_REDIRECT" => Some(Self::CardRedirect),
            "CIMB_VA" => Some(Self::CimbVa),
            "CLASSIC_REWARD" => Some(Self::ClassicReward),
            "CREDIT" => Some(Self::Credit),
            "CRYPTO_CURRENCY" => Some(Self::CryptoCurrency),
            "CASHAPP" => Some(Self::Cashapp),
            "DANA" => Some(Self::Dana),
            "DANAMON_VA" => Some(Self::DanamonVa),
            "DEBIT" => Some(Self::Debit),
            "DUIT_NOW" => Some(Self::DuitNow),
            "EFECTY" => Some(Self::Efecty),
            "EFT" => Some(Self::Eft),
            "EPS" => Some(Self::Eps),
            "FPS" => Some(Self::Fps),
            "EVOUCHER" => Some(Self::Evoucher),
            "GIROPAY" => Some(Self::Giropay),
            "GIVEX" => Some(Self::Givex),
            "GOOGLE_PAY" => Some(Self::GooglePay),
            "GO_PAY" => Some(Self::GoPay),
            "GCASH" => Some(Self::Gcash),
            "IDEAL" => Some(Self::Ideal),
            "INTERAC" => Some(Self::Interac),
            "INDOMARET" => Some(Self::Indomaret),
            "KAKAO_PAY" => Some(Self::KakaoPay),
            "LOCAL_BANK_REDIRECT" => Some(Self::LocalBankRedirect),
            "MANDIRI_VA" => Some(Self::MandiriVa),
            "KNET" => Some(Self::Knet),
            "MB_WAY" => Some(Self::MbWay),
            "MOBILE_PAY" => Some(Self::MobilePay),
            "MOMO" => Some(Self::Momo),
            "MOMO_ATM" => Some(Self::MomoAtm),
            "MULTIBANCO" => Some(Self::Multibanco),
            "ONLINE_BANKING_THAILAND" => Some(Self::OnlineBankingThailand),
            "ONLINE_BANKING_CZECH_REPUBLIC" => Some(Self::OnlineBankingCzechRepublic),
            "ONLINE_BANKING_FINLAND" => Some(Self::OnlineBankingFinland),
            "ONLINE_BANKING_FPX" => Some(Self::OnlineBankingFpx),
            "ONLINE_BANKING_POLAND" => Some(Self::OnlineBankingPoland),
            "ONLINE_BANKING_SLOVAKIA" => Some(Self::OnlineBankingSlovakia),
            "OXXO" => Some(Self::Oxxo),
            "PAGO_EFECTIVO" => Some(Self::PagoEfectivo),
            "PERMATA_BANK_TRANSFER" => Some(Self::PermataBankTransfer),
            "OPEN_BANKING_UK" => Some(Self::OpenBankingUk),
            "PAY_BRIGHT" => Some(Self::PayBright),
            "PAZE" => Some(Self::Paze),
            "PIX" => Some(Self::Pix),
            "PAY_SAFE_CARD" => Some(Self::PaySafeCard),
            "PRZELEWY24" => Some(Self::Przelewy24),
            "PROMPT_PAY" => Some(Self::PromptPay),
            "PSE" => Some(Self::Pse),
            "RED_COMPRA" => Some(Self::RedCompra),
            "RED_PAGOS" => Some(Self::RedPagos),
            "SAMSUNG_PAY" => Some(Self::SamsungPay),
            "SEPA" => Some(Self::Sepa),
            "SEPA_BANK_TRANSFER" => Some(Self::SepaBankTransfer),
            "SOFORT" => Some(Self::Sofort),
            "SWISH" => Some(Self::Swish),
            "TOUCH_N_GO" => Some(Self::TouchNGo),
            "TRUSTLY" => Some(Self::Trustly),
            "TWINT" => Some(Self::Twint),
            "UPI_COLLECT" => Some(Self::UpiCollect),
            "UPI_INTENT" => Some(Self::UpiIntent),
            "VIPPS" => Some(Self::Vipps),
            "VIET_QR" => Some(Self::VietQr),
            "VENMO" => Some(Self::Venmo),
            "WALLEY" => Some(Self::Walley),
            "WE_CHAT_PAY" => Some(Self::WeChatPay),
            "SEVEN_ELEVEN" => Some(Self::SevenEleven),
            "LAWSON" => Some(Self::Lawson),
            "MINI_STOP" => Some(Self::MiniStop),
            "FAMILY_MART" => Some(Self::FamilyMart),
            "SEICOMART" => Some(Self::Seicomart),
            "PAY_EASY" => Some(Self::PayEasy),
            "LOCAL_BANK_TRANSFER" => Some(Self::LocalBankTransfer),
            "OPEN_BANKING_PIS" => Some(Self::OpenBankingPis),
            "DIRECT_CARRIER_BILLING" => Some(Self::DirectCarrierBilling),
            "INSTANT_BANK_TRANSFER" => Some(Self::InstantBankTransfer),
            _ => None,
        }
    }
}
/// Dispute stage enumeration.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DisputeStage {
    /// Default value
    Unspecified = 0,
    PreDispute = 1,
    ActiveDispute = 2,
    PreArbitration = 3,
}
impl DisputeStage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DisputeStage::Unspecified => "DISPUTE_STAGE_UNSPECIFIED",
            DisputeStage::PreDispute => "PRE_DISPUTE",
            DisputeStage::ActiveDispute => "ACTIVE_DISPUTE",
            DisputeStage::PreArbitration => "PRE_ARBITRATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISPUTE_STAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "PRE_DISPUTE" => Some(Self::PreDispute),
            "ACTIVE_DISPUTE" => Some(Self::ActiveDispute),
            "PRE_ARBITRATION" => Some(Self::PreArbitration),
            _ => None,
        }
    }
}
/// Country Alpha-2 code enumeration.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CountryAlpha2 {
    /// Default value must be first
    Unspecified = 0,
    Us = 1,
    Af = 2,
    Ax = 3,
    Al = 4,
    Dz = 5,
    As = 6,
    Ad = 7,
    Ao = 8,
    Ai = 9,
    Aq = 10,
    Ag = 11,
    Ar = 12,
    Am = 13,
    Aw = 14,
    Au = 15,
    At = 16,
    Az = 17,
    Bs = 18,
    Bh = 19,
    Bd = 20,
    Bb = 21,
    By = 22,
    Be = 23,
    Bz = 24,
    Bj = 25,
    Bm = 26,
    Bt = 27,
    Bo = 28,
    Bq = 29,
    Ba = 30,
    Bw = 31,
    Bv = 32,
    Br = 33,
    Io = 34,
    Bn = 35,
    Bg = 36,
    Bf = 37,
    Bi = 38,
    Kh = 39,
    Cm = 40,
    Ca = 41,
    Cv = 42,
    Ky = 43,
    Cf = 44,
    Td = 45,
    Cl = 46,
    Cn = 47,
    Cx = 48,
    Cc = 49,
    Co = 50,
    Km = 51,
    Cg = 52,
    Cd = 53,
    Ck = 54,
    Cr = 55,
    Ci = 56,
    Hr = 57,
    Cu = 58,
    Cw = 59,
    Cy = 60,
    Cz = 61,
    Dk = 62,
    Dj = 63,
    Dm = 64,
    Do = 65,
    Ec = 66,
    Eg = 67,
    Sv = 68,
    Gq = 69,
    Er = 70,
    Ee = 71,
    Et = 72,
    Fk = 73,
    Fo = 74,
    Fj = 75,
    Fi = 76,
    Fr = 77,
    Gf = 78,
    Pf = 79,
    Tf = 80,
    Ga = 81,
    Gm = 82,
    Ge = 83,
    De = 84,
    Gh = 85,
    Gi = 86,
    Gr = 87,
    Gl = 88,
    Gd = 89,
    Gp = 90,
    Gu = 91,
    Gt = 92,
    Gg = 93,
    Gn = 94,
    Gw = 95,
    Gy = 96,
    Ht = 97,
    Hm = 98,
    Va = 99,
    Hn = 100,
    Hk = 101,
    Hu = 102,
    Is = 103,
    In = 104,
    Id = 105,
    Ir = 106,
    Iq = 107,
    Ie = 108,
    Im = 109,
    Il = 110,
    It = 111,
    Jm = 112,
    Jp = 113,
    Je = 114,
    Jo = 115,
    Kz = 116,
    Ke = 117,
    Ki = 118,
    Kp = 119,
    Kr = 120,
    Kw = 121,
    Kg = 122,
    La = 123,
    Lv = 124,
    Lb = 125,
    Ls = 126,
    Lr = 127,
    Ly = 128,
    Li = 129,
    Lt = 130,
    Lu = 131,
    Mo = 132,
    Mk = 133,
    Mg = 134,
    Mw = 135,
    My = 136,
    Mv = 137,
    Ml = 138,
    Mt = 139,
    Mh = 140,
    Mq = 141,
    Mr = 142,
    Mu = 143,
    Yt = 144,
    Mx = 145,
    Fm = 146,
    Md = 147,
    Mc = 148,
    Mn = 149,
    Me = 150,
    Ms = 151,
    Ma = 152,
    Mz = 153,
    Mm = 154,
    Na = 155,
    Nr = 156,
    Np = 157,
    Nl = 158,
    Nc = 159,
    Nz = 160,
    Ni = 161,
    Ne = 162,
    Ng = 163,
    Nu = 164,
    Nf = 165,
    Mp = 166,
    No = 167,
    Om = 168,
    Pk = 169,
    Pw = 170,
    Ps = 171,
    Pa = 172,
    Pg = 173,
    Py = 174,
    Pe = 175,
    Ph = 176,
    Pn = 177,
    Pl = 178,
    Pt = 179,
    Pr = 180,
    Qa = 181,
    Re = 182,
    Ro = 183,
    Ru = 184,
    Rw = 185,
    Bl = 186,
    Sh = 187,
    Kn = 188,
    Lc = 189,
    Mf = 190,
    Pm = 191,
    Vc = 192,
    Ws = 193,
    Sm = 194,
    St = 195,
    Sa = 196,
    Sn = 197,
    Rs = 198,
    Sc = 199,
    Sl = 200,
    Sg = 201,
    Sx = 202,
    Sk = 203,
    Si = 204,
    Sb = 205,
    So = 206,
    Za = 207,
    Gs = 208,
    Ss = 209,
    Es = 210,
    Lk = 211,
    Sd = 212,
    Sr = 213,
    Sj = 214,
    Sz = 215,
    Se = 216,
    Ch = 217,
    Sy = 218,
    Tw = 219,
    Tj = 220,
    Tz = 221,
    Th = 222,
    Tl = 223,
    Tg = 224,
    Tk = 225,
    To = 226,
    Tt = 227,
    Tn = 228,
    Tr = 229,
    Tm = 230,
    Tc = 231,
    Tv = 232,
    Ug = 233,
    Ua = 234,
    Ae = 235,
    Gb = 236,
    Um = 237,
    Uy = 238,
    Uz = 239,
    Vu = 240,
    Ve = 241,
    Vn = 242,
    Vg = 243,
    Vi = 244,
    Wf = 245,
    Eh = 246,
    Ye = 247,
    Zm = 248,
    Zw = 249,
}
impl CountryAlpha2 {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CountryAlpha2::Unspecified => "COUNTRY_ALPHA2_UNSPECIFIED",
            CountryAlpha2::Us => "US",
            CountryAlpha2::Af => "AF",
            CountryAlpha2::Ax => "AX",
            CountryAlpha2::Al => "AL",
            CountryAlpha2::Dz => "DZ",
            CountryAlpha2::As => "AS",
            CountryAlpha2::Ad => "AD",
            CountryAlpha2::Ao => "AO",
            CountryAlpha2::Ai => "AI",
            CountryAlpha2::Aq => "AQ",
            CountryAlpha2::Ag => "AG",
            CountryAlpha2::Ar => "AR",
            CountryAlpha2::Am => "AM",
            CountryAlpha2::Aw => "AW",
            CountryAlpha2::Au => "AU",
            CountryAlpha2::At => "AT",
            CountryAlpha2::Az => "AZ",
            CountryAlpha2::Bs => "BS",
            CountryAlpha2::Bh => "BH",
            CountryAlpha2::Bd => "BD",
            CountryAlpha2::Bb => "BB",
            CountryAlpha2::By => "BY",
            CountryAlpha2::Be => "BE",
            CountryAlpha2::Bz => "BZ",
            CountryAlpha2::Bj => "BJ",
            CountryAlpha2::Bm => "BM",
            CountryAlpha2::Bt => "BT",
            CountryAlpha2::Bo => "BO",
            CountryAlpha2::Bq => "BQ",
            CountryAlpha2::Ba => "BA",
            CountryAlpha2::Bw => "BW",
            CountryAlpha2::Bv => "BV",
            CountryAlpha2::Br => "BR",
            CountryAlpha2::Io => "IO",
            CountryAlpha2::Bn => "BN",
            CountryAlpha2::Bg => "BG",
            CountryAlpha2::Bf => "BF",
            CountryAlpha2::Bi => "BI",
            CountryAlpha2::Kh => "KH",
            CountryAlpha2::Cm => "CM",
            CountryAlpha2::Ca => "CA",
            CountryAlpha2::Cv => "CV",
            CountryAlpha2::Ky => "KY",
            CountryAlpha2::Cf => "CF",
            CountryAlpha2::Td => "TD",
            CountryAlpha2::Cl => "CL",
            CountryAlpha2::Cn => "CN",
            CountryAlpha2::Cx => "CX",
            CountryAlpha2::Cc => "CC",
            CountryAlpha2::Co => "CO",
            CountryAlpha2::Km => "KM",
            CountryAlpha2::Cg => "CG",
            CountryAlpha2::Cd => "CD",
            CountryAlpha2::Ck => "CK",
            CountryAlpha2::Cr => "CR",
            CountryAlpha2::Ci => "CI",
            CountryAlpha2::Hr => "HR",
            CountryAlpha2::Cu => "CU",
            CountryAlpha2::Cw => "CW",
            CountryAlpha2::Cy => "CY",
            CountryAlpha2::Cz => "CZ",
            CountryAlpha2::Dk => "DK",
            CountryAlpha2::Dj => "DJ",
            CountryAlpha2::Dm => "DM",
            CountryAlpha2::Do => "DO",
            CountryAlpha2::Ec => "EC",
            CountryAlpha2::Eg => "EG",
            CountryAlpha2::Sv => "SV",
            CountryAlpha2::Gq => "GQ",
            CountryAlpha2::Er => "ER",
            CountryAlpha2::Ee => "EE",
            CountryAlpha2::Et => "ET",
            CountryAlpha2::Fk => "FK",
            CountryAlpha2::Fo => "FO",
            CountryAlpha2::Fj => "FJ",
            CountryAlpha2::Fi => "FI",
            CountryAlpha2::Fr => "FR",
            CountryAlpha2::Gf => "GF",
            CountryAlpha2::Pf => "PF",
            CountryAlpha2::Tf => "TF",
            CountryAlpha2::Ga => "GA",
            CountryAlpha2::Gm => "GM",
            CountryAlpha2::Ge => "GE",
            CountryAlpha2::De => "DE",
            CountryAlpha2::Gh => "GH",
            CountryAlpha2::Gi => "GI",
            CountryAlpha2::Gr => "GR",
            CountryAlpha2::Gl => "GL",
            CountryAlpha2::Gd => "GD",
            CountryAlpha2::Gp => "GP",
            CountryAlpha2::Gu => "GU",
            CountryAlpha2::Gt => "GT",
            CountryAlpha2::Gg => "GG",
            CountryAlpha2::Gn => "GN",
            CountryAlpha2::Gw => "GW",
            CountryAlpha2::Gy => "GY",
            CountryAlpha2::Ht => "HT",
            CountryAlpha2::Hm => "HM",
            CountryAlpha2::Va => "VA",
            CountryAlpha2::Hn => "HN",
            CountryAlpha2::Hk => "HK",
            CountryAlpha2::Hu => "HU",
            CountryAlpha2::Is => "IS",
            CountryAlpha2::In => "IN",
            CountryAlpha2::Id => "ID",
            CountryAlpha2::Ir => "IR",
            CountryAlpha2::Iq => "IQ",
            CountryAlpha2::Ie => "IE",
            CountryAlpha2::Im => "IM",
            CountryAlpha2::Il => "IL",
            CountryAlpha2::It => "IT",
            CountryAlpha2::Jm => "JM",
            CountryAlpha2::Jp => "JP",
            CountryAlpha2::Je => "JE",
            CountryAlpha2::Jo => "JO",
            CountryAlpha2::Kz => "KZ",
            CountryAlpha2::Ke => "KE",
            CountryAlpha2::Ki => "KI",
            CountryAlpha2::Kp => "KP",
            CountryAlpha2::Kr => "KR",
            CountryAlpha2::Kw => "KW",
            CountryAlpha2::Kg => "KG",
            CountryAlpha2::La => "LA",
            CountryAlpha2::Lv => "LV",
            CountryAlpha2::Lb => "LB",
            CountryAlpha2::Ls => "LS",
            CountryAlpha2::Lr => "LR",
            CountryAlpha2::Ly => "LY",
            CountryAlpha2::Li => "LI",
            CountryAlpha2::Lt => "LT",
            CountryAlpha2::Lu => "LU",
            CountryAlpha2::Mo => "MO",
            CountryAlpha2::Mk => "MK",
            CountryAlpha2::Mg => "MG",
            CountryAlpha2::Mw => "MW",
            CountryAlpha2::My => "MY",
            CountryAlpha2::Mv => "MV",
            CountryAlpha2::Ml => "ML",
            CountryAlpha2::Mt => "MT",
            CountryAlpha2::Mh => "MH",
            CountryAlpha2::Mq => "MQ",
            CountryAlpha2::Mr => "MR",
            CountryAlpha2::Mu => "MU",
            CountryAlpha2::Yt => "YT",
            CountryAlpha2::Mx => "MX",
            CountryAlpha2::Fm => "FM",
            CountryAlpha2::Md => "MD",
            CountryAlpha2::Mc => "MC",
            CountryAlpha2::Mn => "MN",
            CountryAlpha2::Me => "ME",
            CountryAlpha2::Ms => "MS",
            CountryAlpha2::Ma => "MA",
            CountryAlpha2::Mz => "MZ",
            CountryAlpha2::Mm => "MM",
            CountryAlpha2::Na => "NA",
            CountryAlpha2::Nr => "NR",
            CountryAlpha2::Np => "NP",
            CountryAlpha2::Nl => "NL",
            CountryAlpha2::Nc => "NC",
            CountryAlpha2::Nz => "NZ",
            CountryAlpha2::Ni => "NI",
            CountryAlpha2::Ne => "NE",
            CountryAlpha2::Ng => "NG",
            CountryAlpha2::Nu => "NU",
            CountryAlpha2::Nf => "NF",
            CountryAlpha2::Mp => "MP",
            CountryAlpha2::No => "NO",
            CountryAlpha2::Om => "OM",
            CountryAlpha2::Pk => "PK",
            CountryAlpha2::Pw => "PW",
            CountryAlpha2::Ps => "PS",
            CountryAlpha2::Pa => "PA",
            CountryAlpha2::Pg => "PG",
            CountryAlpha2::Py => "PY",
            CountryAlpha2::Pe => "PE",
            CountryAlpha2::Ph => "PH",
            CountryAlpha2::Pn => "PN",
            CountryAlpha2::Pl => "PL",
            CountryAlpha2::Pt => "PT",
            CountryAlpha2::Pr => "PR",
            CountryAlpha2::Qa => "QA",
            CountryAlpha2::Re => "RE",
            CountryAlpha2::Ro => "RO",
            CountryAlpha2::Ru => "RU",
            CountryAlpha2::Rw => "RW",
            CountryAlpha2::Bl => "BL",
            CountryAlpha2::Sh => "SH",
            CountryAlpha2::Kn => "KN",
            CountryAlpha2::Lc => "LC",
            CountryAlpha2::Mf => "MF",
            CountryAlpha2::Pm => "PM",
            CountryAlpha2::Vc => "VC",
            CountryAlpha2::Ws => "WS",
            CountryAlpha2::Sm => "SM",
            CountryAlpha2::St => "ST",
            CountryAlpha2::Sa => "SA",
            CountryAlpha2::Sn => "SN",
            CountryAlpha2::Rs => "RS",
            CountryAlpha2::Sc => "SC",
            CountryAlpha2::Sl => "SL",
            CountryAlpha2::Sg => "SG",
            CountryAlpha2::Sx => "SX",
            CountryAlpha2::Sk => "SK",
            CountryAlpha2::Si => "SI",
            CountryAlpha2::Sb => "SB",
            CountryAlpha2::So => "SO",
            CountryAlpha2::Za => "ZA",
            CountryAlpha2::Gs => "GS",
            CountryAlpha2::Ss => "SS",
            CountryAlpha2::Es => "ES",
            CountryAlpha2::Lk => "LK",
            CountryAlpha2::Sd => "SD",
            CountryAlpha2::Sr => "SR",
            CountryAlpha2::Sj => "SJ",
            CountryAlpha2::Sz => "SZ",
            CountryAlpha2::Se => "SE",
            CountryAlpha2::Ch => "CH",
            CountryAlpha2::Sy => "SY",
            CountryAlpha2::Tw => "TW",
            CountryAlpha2::Tj => "TJ",
            CountryAlpha2::Tz => "TZ",
            CountryAlpha2::Th => "TH",
            CountryAlpha2::Tl => "TL",
            CountryAlpha2::Tg => "TG",
            CountryAlpha2::Tk => "TK",
            CountryAlpha2::To => "TO",
            CountryAlpha2::Tt => "TT",
            CountryAlpha2::Tn => "TN",
            CountryAlpha2::Tr => "TR",
            CountryAlpha2::Tm => "TM",
            CountryAlpha2::Tc => "TC",
            CountryAlpha2::Tv => "TV",
            CountryAlpha2::Ug => "UG",
            CountryAlpha2::Ua => "UA",
            CountryAlpha2::Ae => "AE",
            CountryAlpha2::Gb => "GB",
            CountryAlpha2::Um => "UM",
            CountryAlpha2::Uy => "UY",
            CountryAlpha2::Uz => "UZ",
            CountryAlpha2::Vu => "VU",
            CountryAlpha2::Ve => "VE",
            CountryAlpha2::Vn => "VN",
            CountryAlpha2::Vg => "VG",
            CountryAlpha2::Vi => "VI",
            CountryAlpha2::Wf => "WF",
            CountryAlpha2::Eh => "EH",
            CountryAlpha2::Ye => "YE",
            CountryAlpha2::Zm => "ZM",
            CountryAlpha2::Zw => "ZW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COUNTRY_ALPHA2_UNSPECIFIED" => Some(Self::Unspecified),
            "US" => Some(Self::Us),
            "AF" => Some(Self::Af),
            "AX" => Some(Self::Ax),
            "AL" => Some(Self::Al),
            "DZ" => Some(Self::Dz),
            "AS" => Some(Self::As),
            "AD" => Some(Self::Ad),
            "AO" => Some(Self::Ao),
            "AI" => Some(Self::Ai),
            "AQ" => Some(Self::Aq),
            "AG" => Some(Self::Ag),
            "AR" => Some(Self::Ar),
            "AM" => Some(Self::Am),
            "AW" => Some(Self::Aw),
            "AU" => Some(Self::Au),
            "AT" => Some(Self::At),
            "AZ" => Some(Self::Az),
            "BS" => Some(Self::Bs),
            "BH" => Some(Self::Bh),
            "BD" => Some(Self::Bd),
            "BB" => Some(Self::Bb),
            "BY" => Some(Self::By),
            "BE" => Some(Self::Be),
            "BZ" => Some(Self::Bz),
            "BJ" => Some(Self::Bj),
            "BM" => Some(Self::Bm),
            "BT" => Some(Self::Bt),
            "BO" => Some(Self::Bo),
            "BQ" => Some(Self::Bq),
            "BA" => Some(Self::Ba),
            "BW" => Some(Self::Bw),
            "BV" => Some(Self::Bv),
            "BR" => Some(Self::Br),
            "IO" => Some(Self::Io),
            "BN" => Some(Self::Bn),
            "BG" => Some(Self::Bg),
            "BF" => Some(Self::Bf),
            "BI" => Some(Self::Bi),
            "KH" => Some(Self::Kh),
            "CM" => Some(Self::Cm),
            "CA" => Some(Self::Ca),
            "CV" => Some(Self::Cv),
            "KY" => Some(Self::Ky),
            "CF" => Some(Self::Cf),
            "TD" => Some(Self::Td),
            "CL" => Some(Self::Cl),
            "CN" => Some(Self::Cn),
            "CX" => Some(Self::Cx),
            "CC" => Some(Self::Cc),
            "CO" => Some(Self::Co),
            "KM" => Some(Self::Km),
            "CG" => Some(Self::Cg),
            "CD" => Some(Self::Cd),
            "CK" => Some(Self::Ck),
            "CR" => Some(Self::Cr),
            "CI" => Some(Self::Ci),
            "HR" => Some(Self::Hr),
            "CU" => Some(Self::Cu),
            "CW" => Some(Self::Cw),
            "CY" => Some(Self::Cy),
            "CZ" => Some(Self::Cz),
            "DK" => Some(Self::Dk),
            "DJ" => Some(Self::Dj),
            "DM" => Some(Self::Dm),
            "DO" => Some(Self::Do),
            "EC" => Some(Self::Ec),
            "EG" => Some(Self::Eg),
            "SV" => Some(Self::Sv),
            "GQ" => Some(Self::Gq),
            "ER" => Some(Self::Er),
            "EE" => Some(Self::Ee),
            "ET" => Some(Self::Et),
            "FK" => Some(Self::Fk),
            "FO" => Some(Self::Fo),
            "FJ" => Some(Self::Fj),
            "FI" => Some(Self::Fi),
            "FR" => Some(Self::Fr),
            "GF" => Some(Self::Gf),
            "PF" => Some(Self::Pf),
            "TF" => Some(Self::Tf),
            "GA" => Some(Self::Ga),
            "GM" => Some(Self::Gm),
            "GE" => Some(Self::Ge),
            "DE" => Some(Self::De),
            "GH" => Some(Self::Gh),
            "GI" => Some(Self::Gi),
            "GR" => Some(Self::Gr),
            "GL" => Some(Self::Gl),
            "GD" => Some(Self::Gd),
            "GP" => Some(Self::Gp),
            "GU" => Some(Self::Gu),
            "GT" => Some(Self::Gt),
            "GG" => Some(Self::Gg),
            "GN" => Some(Self::Gn),
            "GW" => Some(Self::Gw),
            "GY" => Some(Self::Gy),
            "HT" => Some(Self::Ht),
            "HM" => Some(Self::Hm),
            "VA" => Some(Self::Va),
            "HN" => Some(Self::Hn),
            "HK" => Some(Self::Hk),
            "HU" => Some(Self::Hu),
            "IS" => Some(Self::Is),
            "IN" => Some(Self::In),
            "ID" => Some(Self::Id),
            "IR" => Some(Self::Ir),
            "IQ" => Some(Self::Iq),
            "IE" => Some(Self::Ie),
            "IM" => Some(Self::Im),
            "IL" => Some(Self::Il),
            "IT" => Some(Self::It),
            "JM" => Some(Self::Jm),
            "JP" => Some(Self::Jp),
            "JE" => Some(Self::Je),
            "JO" => Some(Self::Jo),
            "KZ" => Some(Self::Kz),
            "KE" => Some(Self::Ke),
            "KI" => Some(Self::Ki),
            "KP" => Some(Self::Kp),
            "KR" => Some(Self::Kr),
            "KW" => Some(Self::Kw),
            "KG" => Some(Self::Kg),
            "LA" => Some(Self::La),
            "LV" => Some(Self::Lv),
            "LB" => Some(Self::Lb),
            "LS" => Some(Self::Ls),
            "LR" => Some(Self::Lr),
            "LY" => Some(Self::Ly),
            "LI" => Some(Self::Li),
            "LT" => Some(Self::Lt),
            "LU" => Some(Self::Lu),
            "MO" => Some(Self::Mo),
            "MK" => Some(Self::Mk),
            "MG" => Some(Self::Mg),
            "MW" => Some(Self::Mw),
            "MY" => Some(Self::My),
            "MV" => Some(Self::Mv),
            "ML" => Some(Self::Ml),
            "MT" => Some(Self::Mt),
            "MH" => Some(Self::Mh),
            "MQ" => Some(Self::Mq),
            "MR" => Some(Self::Mr),
            "MU" => Some(Self::Mu),
            "YT" => Some(Self::Yt),
            "MX" => Some(Self::Mx),
            "FM" => Some(Self::Fm),
            "MD" => Some(Self::Md),
            "MC" => Some(Self::Mc),
            "MN" => Some(Self::Mn),
            "ME" => Some(Self::Me),
            "MS" => Some(Self::Ms),
            "MA" => Some(Self::Ma),
            "MZ" => Some(Self::Mz),
            "MM" => Some(Self::Mm),
            "NA" => Some(Self::Na),
            "NR" => Some(Self::Nr),
            "NP" => Some(Self::Np),
            "NL" => Some(Self::Nl),
            "NC" => Some(Self::Nc),
            "NZ" => Some(Self::Nz),
            "NI" => Some(Self::Ni),
            "NE" => Some(Self::Ne),
            "NG" => Some(Self::Ng),
            "NU" => Some(Self::Nu),
            "NF" => Some(Self::Nf),
            "MP" => Some(Self::Mp),
            "NO" => Some(Self::No),
            "OM" => Some(Self::Om),
            "PK" => Some(Self::Pk),
            "PW" => Some(Self::Pw),
            "PS" => Some(Self::Ps),
            "PA" => Some(Self::Pa),
            "PG" => Some(Self::Pg),
            "PY" => Some(Self::Py),
            "PE" => Some(Self::Pe),
            "PH" => Some(Self::Ph),
            "PN" => Some(Self::Pn),
            "PL" => Some(Self::Pl),
            "PT" => Some(Self::Pt),
            "PR" => Some(Self::Pr),
            "QA" => Some(Self::Qa),
            "RE" => Some(Self::Re),
            "RO" => Some(Self::Ro),
            "RU" => Some(Self::Ru),
            "RW" => Some(Self::Rw),
            "BL" => Some(Self::Bl),
            "SH" => Some(Self::Sh),
            "KN" => Some(Self::Kn),
            "LC" => Some(Self::Lc),
            "MF" => Some(Self::Mf),
            "PM" => Some(Self::Pm),
            "VC" => Some(Self::Vc),
            "WS" => Some(Self::Ws),
            "SM" => Some(Self::Sm),
            "ST" => Some(Self::St),
            "SA" => Some(Self::Sa),
            "SN" => Some(Self::Sn),
            "RS" => Some(Self::Rs),
            "SC" => Some(Self::Sc),
            "SL" => Some(Self::Sl),
            "SG" => Some(Self::Sg),
            "SX" => Some(Self::Sx),
            "SK" => Some(Self::Sk),
            "SI" => Some(Self::Si),
            "SB" => Some(Self::Sb),
            "SO" => Some(Self::So),
            "ZA" => Some(Self::Za),
            "GS" => Some(Self::Gs),
            "SS" => Some(Self::Ss),
            "ES" => Some(Self::Es),
            "LK" => Some(Self::Lk),
            "SD" => Some(Self::Sd),
            "SR" => Some(Self::Sr),
            "SJ" => Some(Self::Sj),
            "SZ" => Some(Self::Sz),
            "SE" => Some(Self::Se),
            "CH" => Some(Self::Ch),
            "SY" => Some(Self::Sy),
            "TW" => Some(Self::Tw),
            "TJ" => Some(Self::Tj),
            "TZ" => Some(Self::Tz),
            "TH" => Some(Self::Th),
            "TL" => Some(Self::Tl),
            "TG" => Some(Self::Tg),
            "TK" => Some(Self::Tk),
            "TO" => Some(Self::To),
            "TT" => Some(Self::Tt),
            "TN" => Some(Self::Tn),
            "TR" => Some(Self::Tr),
            "TM" => Some(Self::Tm),
            "TC" => Some(Self::Tc),
            "TV" => Some(Self::Tv),
            "UG" => Some(Self::Ug),
            "UA" => Some(Self::Ua),
            "AE" => Some(Self::Ae),
            "GB" => Some(Self::Gb),
            "UM" => Some(Self::Um),
            "UY" => Some(Self::Uy),
            "UZ" => Some(Self::Uz),
            "VU" => Some(Self::Vu),
            "VE" => Some(Self::Ve),
            "VN" => Some(Self::Vn),
            "VG" => Some(Self::Vg),
            "VI" => Some(Self::Vi),
            "WF" => Some(Self::Wf),
            "EH" => Some(Self::Eh),
            "YE" => Some(Self::Ye),
            "ZM" => Some(Self::Zm),
            "ZW" => Some(Self::Zw),
            _ => None,
        }
    }
}
/// Type of evidence that can be submitted for a dispute.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EvidenceType {
    /// Default value
    Unspecified = 0,
    /// Cancellation policy document
    CancellationPolicy = 1,
    /// Communication with customer
    CustomerCommunication = 2,
    /// Customer signature document
    CustomerSignature = 3,
    /// Receipt or proof of purchase
    Receipt = 4,
    /// Refund policy document
    RefundPolicy = 5,
    /// Service documentation
    ServiceDocumentation = 6,
    /// Shipping documentation
    ShippingDocumentation = 7,
    /// Invoice showing distinct transactions
    InvoiceShowingDistinctTransactions = 8,
    /// Recurring transaction agreement
    RecurringTransactionAgreement = 9,
    /// Uncategorized evidence file
    UncategorizedFile = 10,
}
impl EvidenceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EvidenceType::Unspecified => "EVIDENCE_TYPE_UNSPECIFIED",
            EvidenceType::CancellationPolicy => "CANCELLATION_POLICY",
            EvidenceType::CustomerCommunication => "CUSTOMER_COMMUNICATION",
            EvidenceType::CustomerSignature => "CUSTOMER_SIGNATURE",
            EvidenceType::Receipt => "RECEIPT",
            EvidenceType::RefundPolicy => "REFUND_POLICY",
            EvidenceType::ServiceDocumentation => "SERVICE_DOCUMENTATION",
            EvidenceType::ShippingDocumentation => "SHIPPING_DOCUMENTATION",
            EvidenceType::InvoiceShowingDistinctTransactions => {
                "INVOICE_SHOWING_DISTINCT_TRANSACTIONS"
            }
            EvidenceType::RecurringTransactionAgreement => {
                "RECURRING_TRANSACTION_AGREEMENT"
            }
            EvidenceType::UncategorizedFile => "UNCATEGORIZED_FILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVIDENCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CANCELLATION_POLICY" => Some(Self::CancellationPolicy),
            "CUSTOMER_COMMUNICATION" => Some(Self::CustomerCommunication),
            "CUSTOMER_SIGNATURE" => Some(Self::CustomerSignature),
            "RECEIPT" => Some(Self::Receipt),
            "REFUND_POLICY" => Some(Self::RefundPolicy),
            "SERVICE_DOCUMENTATION" => Some(Self::ServiceDocumentation),
            "SHIPPING_DOCUMENTATION" => Some(Self::ShippingDocumentation),
            "INVOICE_SHOWING_DISTINCT_TRANSACTIONS" => {
                Some(Self::InvoiceShowingDistinctTransactions)
            }
            "RECURRING_TRANSACTION_AGREEMENT" => {
                Some(Self::RecurringTransactionAgreement)
            }
            "UNCATEGORIZED_FILE" => Some(Self::UncategorizedFile),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod payment_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Unified service definition for all payment related operations.
    #[derive(Debug, Clone)]
    pub struct PaymentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PaymentServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PaymentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PaymentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            PaymentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Authorizes a payment.
        pub async fn authorize(
            &mut self,
            request: impl tonic::IntoRequest<super::PaymentServiceAuthorizeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PaymentServiceAuthorizeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.PaymentService/Authorize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.PaymentService", "Authorize"));
            self.inner.unary(req, path, codec).await
        }
        /// Synchronizes the status of a payment.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::PaymentServiceGetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PaymentServiceGetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.PaymentService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("ucs.v2.PaymentService", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Voids an authorized payment.
        pub async fn void(
            &mut self,
            request: impl tonic::IntoRequest<super::PaymentServiceVoidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PaymentServiceVoidResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.PaymentService/Void",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.PaymentService", "Void"));
            self.inner.unary(req, path, codec).await
        }
        /// Captures a previously authorized payment.
        pub async fn capture(
            &mut self,
            request: impl tonic::IntoRequest<super::PaymentServiceCaptureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PaymentServiceCaptureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.PaymentService/Capture",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.PaymentService", "Capture"));
            self.inner.unary(req, path, codec).await
        }
        /// Processes a refund request.
        pub async fn refund(
            &mut self,
            request: impl tonic::IntoRequest<super::PaymentServiceRefundRequest>,
        ) -> std::result::Result<tonic::Response<super::RefundResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.PaymentService/Refund",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.PaymentService", "Refund"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets up a mandate for future payments.
        pub async fn register(
            &mut self,
            request: impl tonic::IntoRequest<super::PaymentServiceRegisterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PaymentServiceRegisterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.PaymentService/Register",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.PaymentService", "Register"));
            self.inner.unary(req, path, codec).await
        }
        /// Processes a repeat payment using existing mandate (MIT - Merchant Initiated Transaction).
        pub async fn repeat_everything(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PaymentServiceRepeatEverythingRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::PaymentServiceRepeatEverythingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.PaymentService/RepeatEverything",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.PaymentService", "RepeatEverything"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new dispute.
        pub async fn dispute(
            &mut self,
            request: impl tonic::IntoRequest<super::PaymentServiceDisputeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DisputeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.PaymentService/Dispute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.PaymentService", "Dispute"));
            self.inner.unary(req, path, codec).await
        }
        /// Handles incoming webhooks from connectors.
        /// This will delegate to the appropriate service transform based on the event type.
        pub async fn transform(
            &mut self,
            request: impl tonic::IntoRequest<super::PaymentServiceTransformRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PaymentServiceTransformResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.PaymentService/Transform",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.PaymentService", "Transform"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod refund_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for refund-specific operations.
    #[derive(Debug, Clone)]
    pub struct RefundServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RefundServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RefundServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RefundServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RefundServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Synchronizes the status of a refund.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::RefundServiceGetRequest>,
        ) -> std::result::Result<tonic::Response<super::RefundResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ucs.v2.RefundService/Get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("ucs.v2.RefundService", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Handles incoming webhooks from connectors.
        pub async fn transform(
            &mut self,
            request: impl tonic::IntoRequest<super::RefundServiceTransformRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RefundServiceTransformResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.RefundService/Transform",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.RefundService", "Transform"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod dispute_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for dispute-specific operations.
    #[derive(Debug, Clone)]
    pub struct DisputeServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DisputeServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DisputeServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DisputeServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DisputeServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Submits evidence for a dispute.
        pub async fn submit_evidence(
            &mut self,
            request: impl tonic::IntoRequest<super::DisputeServiceSubmitEvidenceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DisputeServiceSubmitEvidenceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.DisputeService/SubmitEvidence",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.DisputeService", "SubmitEvidence"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves dispute information or evidence submission status.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::DisputeServiceGetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DisputeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.DisputeService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("ucs.v2.DisputeService", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Defends a dispute with a reason code.
        pub async fn defend(
            &mut self,
            request: impl tonic::IntoRequest<super::DisputeDefendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DisputeDefendResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.DisputeService/Defend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.DisputeService", "Defend"));
            self.inner.unary(req, path, codec).await
        }
        /// Accepts a dispute.
        pub async fn accept(
            &mut self,
            request: impl tonic::IntoRequest<super::AcceptDisputeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AcceptDisputeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.DisputeService/Accept",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.DisputeService", "Accept"));
            self.inner.unary(req, path, codec).await
        }
        /// Handles incoming webhooks from connectors.
        pub async fn transform(
            &mut self,
            request: impl tonic::IntoRequest<super::DisputeServiceTransformRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DisputeServiceTransformResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ucs.v2.DisputeService/Transform",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ucs.v2.DisputeService", "Transform"));
            self.inner.unary(req, path, codec).await
        }
    }
}
