//! Patch helpers for applying partial overrides.
//!
//! Summary:
//! - Each config struct derives `config_patch_derive::Patch` to generate a `*Patch` type.
//! - Patch fields are optional; missing fields do not change the base config.
//! - Nested structs are inferred from field types; use `#[patch(patch_type = ...)]` to override.
//! - Optional fields (`Option<T>`) use three-state patches by default (missing vs null vs value).
//!   Nested optional structs can be cleared or patched by creating a default when needed.

pub use config_patch_derive::Patch;
use serde::Deserialize;

/// Apply a patch object onto `self`.
///
/// Patch structs are generated by `config_patch_derive::Patch`.
/// Missing fields in a patch mean "no change."
pub trait Patch<P> {
    fn apply(&mut self, patch: P);
}

/// Deserialize `Option<Option<T>>` while preserving "missing vs null" semantics.
///
/// This is useful in custom patch types when you need three-state behavior.
pub fn deserialize_option_option<'de, D, T>(deserializer: D) -> Result<Option<Option<T>>, D::Error>
where
    D: serde::Deserializer<'de>,
    T: Deserialize<'de>,
{
    let value = Option::<T>::deserialize(deserializer)?;
    Ok(Some(value))
}
