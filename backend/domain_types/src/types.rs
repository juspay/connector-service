use core::result::Result;
use std::{borrow::Cow, collections::HashMap, fmt::Debug, str::FromStr};

use crate::{connector_types, utils::extract_connector_request_reference_id};
use common_enums::{
    CaptureMethod, CardNetwork, CountryAlpha2, FutureUsage, PaymentMethod, PaymentMethodType,
};
use common_utils::{
    consts::{self, NO_ERROR_CODE, X_EXTERNAL_VAULT_METADATA},
    id_type::CustomerId,
    metadata::MaskedMetadata,
    pii::Email,
    Method, SecretSerdeValue,
};
use error_stack::{report, ResultExt};
use grpc_api_types::payments::{
    self as grpc_payment_types, AcceptDisputeResponse, ConnectorState, DisputeDefendRequest,
    DisputeDefendResponse, DisputeResponse, DisputeServiceSubmitEvidenceResponse,
    PaymentServiceAuthorizeRequest, PaymentServiceAuthorizeResponse, PaymentServiceCaptureResponse,
    PaymentServiceGetResponse, PaymentServiceIncrementalAuthorizationRequest,
    PaymentServiceIncrementalAuthorizationResponse, PaymentServiceRegisterRequest,
    PaymentServiceRegisterResponse, PaymentServiceRevokeMandateRequest,
    PaymentServiceSdkSessionTokenRequest, PaymentServiceSdkSessionTokenResponse,
    PaymentServiceVoidPostCaptureResponse, PaymentServiceVoidRequest, PaymentServiceVoidResponse,
    RefundResponse,
};
use hyperswitch_masking::{ExposeInterface, PeekInterface, Secret};
use serde::{Deserialize, Serialize};
use tracing::info;
use utoipa::ToSchema;

/// Extract vault-related headers from gRPC metadata
fn extract_headers_from_metadata(
    metadata: &MaskedMetadata,
) -> Option<HashMap<String, Secret<String>>> {
    let mut vault_headers = HashMap::new();

    if let Some(vault_creds) = metadata.get(X_EXTERNAL_VAULT_METADATA) {
        vault_headers.insert(X_EXTERNAL_VAULT_METADATA.to_string(), vault_creds);
    }

    if vault_headers.is_empty() {
        None
    } else {
        Some(vault_headers)
    }
}

impl ForeignTryFrom<(Secret<String>, &'static str)> for SecretSerdeValue {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (secret, field_name): (Secret<String>, &'static str),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let raw = secret.expose();
        serde_json::from_str(&raw).map(Self::new).change_context(
            ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: format!("INVALID {}", field_name.to_uppercase()),
                error_identifier: 400,
                error_message: format!("Failed to parse {}", field_name.to_lowercase()),
                error_object: None,
            }),
        )
    }
}

// For decoding connector_meta_data and Engine trait - base64 crate no longer needed here
use crate::{
    connector_flow::{
        Accept, Authorize, Capture, CreateConnectorCustomer, CreateOrder, CreateSessionToken,
        DefendDispute, IncrementalAuthorization, PSync, PaymentMethodToken, RSync, Refund,
        RepeatPayment, SdkSessionToken, SetupMandate, SubmitEvidence, Void, VoidPC,
    },
    connector_types::{
        AcceptDisputeData, AccessTokenRequestData, AccessTokenResponseData, ApplePayPaymentRequest,
        ApplePaySessionResponse, BillingDescriptor, ConnectorCustomerData,
        ConnectorMandateReferenceId, ConnectorResponseHeaders, ContinueRedirectionResponse,
        DisputeDefendData, DisputeFlowData, DisputeResponseData, DisputeWebhookDetailsResponse,
        GpayAllowedPaymentMethods, GpayBillingAddressFormat, GpaySessionTokenResponse,
        MandateReferenceId, MandateRevokeRequestData, MultipleCaptureRequestData,
        NetworkTokenWithNTIRef, NextActionCall, PaymentCreateOrderData, PaymentCreateOrderResponse,
        PaymentFlowData, PaymentMethodTokenResponse, PaymentMethodTokenizationData,
        PaymentVoidData, PaymentsAuthenticateData, PaymentsAuthorizeData, PaymentsCaptureData,
        PaymentsIncrementalAuthorizationData, PaymentsPostAuthenticateData,
        PaymentsPreAuthenticateData, PaymentsResponseData, PaymentsSdkSessionTokenData,
        PaymentsSyncData, PaypalFlow, PaypalTransactionInfo, RawConnectorRequestResponse,
        RedirectDetailsResponse, RefundFlowData, RefundSyncData, RefundWebhookDetailsResponse,
        RefundsData, RefundsResponseData, RepeatPaymentData, ResponseId, SessionToken,
        SessionTokenRequestData, SessionTokenResponseData, SetupMandateRequestData,
        SubmitEvidenceData, WebhookDetailsResponse,
    },
    errors::{ApiError, ApplicationErrorResponse},
    mandates::{self, MandateData},
    payment_address::{
        Address, AddressDetails, OrderDetailsWithAmount, PaymentAddress, PhoneDetails,
    },
    payment_method_data,
    payment_method_data::{
        DefaultPCIHolder, PaymentMethodData, PaymentMethodDataTypes, RawCardNumber,
        VaultTokenHolder,
    },
    router_data::{
        self, AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,
        RecurringMandatePaymentData,
    },
    router_data_v2::RouterDataV2,
    router_request_types,
    router_request_types::BrowserInformation,
    router_response_types,
    utils::{extract_merchant_id_from_metadata, ForeignFrom, ForeignTryFrom},
};

#[derive(
    Clone,
    serde::Deserialize,
    serde::Serialize,
    Debug,
    Default,
    PartialEq,
    config_patch_derive::Patch,
)]
pub struct Connectors {
    // Added pub
    pub adyen: ConnectorParams,
    pub forte: ConnectorParams,
    pub razorpay: ConnectorParams,
    pub razorpayv2: ConnectorParams,
    pub fiserv: ConnectorParams,
    pub elavon: ConnectorParams, // Add your connector params
    pub xendit: ConnectorParams,
    pub checkout: ConnectorParams,
    pub authorizedotnet: ConnectorParams, // Add your connector params
    pub mifinity: ConnectorParams,
    pub phonepe: ConnectorParams,
    pub cashfree: ConnectorParams,
    pub paytm: ConnectorParams,
    pub fiuu: ConnectorParams,
    pub payu: ConnectorParams,
    pub cashtocode: ConnectorParams,
    pub novalnet: ConnectorParams,
    pub nexinets: ConnectorParams,
    pub noon: ConnectorParams,
    pub braintree: ConnectorParams,
    pub volt: ConnectorParams,
    pub calida: ConnectorParams,
    pub cryptopay: ConnectorParams,
    pub helcim: ConnectorParams,
    pub dlocal: ConnectorParams,
    pub placetopay: ConnectorParams,
    pub rapyd: ConnectorParams,
    pub aci: ConnectorParams,
    pub trustpay: ConnectorParamsWithMoreUrls,
    pub stripe: ConnectorParams,
    pub cybersource: ConnectorParams,
    pub worldpay: ConnectorParams,
    pub worldpayvantiv: ConnectorParams,
    pub multisafepay: ConnectorParams,
    pub payload: ConnectorParams,
    pub fiservemea: ConnectorParams,
    pub paysafe: ConnectorParams,
    pub datatrans: ConnectorParams,
    pub bluesnap: ConnectorParams,
    pub authipay: ConnectorParams,
    pub bamboraapac: ConnectorParams,
    pub silverflow: ConnectorParams,
    pub celero: ConnectorParams,
    pub paypal: ConnectorParams,
    pub stax: ConnectorParams,
    pub billwerk: ConnectorParams,
    pub hipay: ConnectorParams,
    pub trustpayments: ConnectorParams,
    pub globalpay: ConnectorParams,
    pub nuvei: ConnectorParams,
    pub iatapay: ConnectorParams,
    pub jpmorgan: ConnectorParams,
    pub nmi: ConnectorParams,
    pub shift4: ConnectorParams,
    pub paybox: ConnectorParams,
    pub barclaycard: ConnectorParams,
    pub redsys: ConnectorParams,
    pub nexixpay: ConnectorParams,
    pub mollie: ConnectorParams,
    pub airwallex: ConnectorParams,
    pub worldpayxml: ConnectorParams,
    pub tsys: ConnectorParams,
    pub bankofamerica: ConnectorParams,
    pub powertranz: ConnectorParams,
    pub getnet: ConnectorParams,
    pub bambora: ConnectorParams,
    pub payme: ConnectorParams,
    pub revolut: ConnectorParams,
    pub gigadat: ConnectorParams,
    pub loonio: ConnectorParams,
    pub wellsfargo: ConnectorParams,
    pub hyperpg: ConnectorParams,
    pub zift: ConnectorParams,
}

#[derive(Clone, Deserialize, Serialize, Debug, Default, PartialEq, config_patch_derive::Patch)]
pub struct ConnectorParams {
    /// base url
    #[serde(default)]
    pub base_url: String,
    #[serde(default)]
    pub dispute_base_url: Option<String>,
    #[serde(default)]
    pub secondary_base_url: Option<String>,
    #[serde(default)]
    pub third_base_url: Option<String>,
}

impl ConnectorParams {
    pub fn new(base_url: String, dispute_base_url: Option<String>) -> Self {
        Self {
            base_url,
            dispute_base_url,
            secondary_base_url: None,
            third_base_url: None,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, Clone, Default, PartialEq, config_patch_derive::Patch)]
pub struct ConnectorParamsWithMoreUrls {
    /// base url
    pub base_url: String,
    /// base url for bank redirects
    pub base_url_bank_redirects: String,
}

// Trait to provide access to connectors field
pub trait HasConnectors {
    fn connectors(&self) -> &Connectors;
}

impl HasConnectors for PaymentFlowData {
    fn connectors(&self) -> &Connectors {
        &self.connectors
    }
}

impl HasConnectors for RefundFlowData {
    fn connectors(&self) -> &Connectors {
        &self.connectors
    }
}

impl HasConnectors for DisputeFlowData {
    fn connectors(&self) -> &Connectors {
        &self.connectors
    }
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq, Hash, config_patch_derive::Patch)]
pub struct Proxy {
    pub http_url: Option<String>,
    pub https_url: Option<String>,
    pub idle_pool_connection_timeout: Option<u64>,
    pub bypass_proxy_urls: Vec<String>,
    pub mitm_proxy_enabled: bool,
    pub mitm_ca_cert: Option<String>,
}

impl Proxy {
    pub fn cache_key(&self, should_bypass_proxy: bool) -> Option<Self> {
        // Return Some(self) if there's an actual proxy configuration
        // let sbp = self.bypass_proxy_urls.contains(&url.to_string());
        if should_bypass_proxy || (self.http_url.is_none() && self.https_url.is_none()) {
            None
        } else {
            Some(self.clone())
        }
    }

    pub fn is_proxy_configured(&self, should_bypass_proxy: bool) -> bool {
        should_bypass_proxy || (self.http_url.is_none() && self.https_url.is_none())
    }
}

impl ForeignTryFrom<grpc_api_types::payments::CaptureMethod> for CaptureMethod {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::CaptureMethod,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::CaptureMethod::Automatic => Ok(Self::Automatic),
            grpc_api_types::payments::CaptureMethod::Manual => Ok(Self::Manual),
            grpc_api_types::payments::CaptureMethod::ManualMultiple => Ok(Self::ManualMultiple),
            grpc_api_types::payments::CaptureMethod::Scheduled => Ok(Self::Scheduled),
            _ => Ok(Self::Automatic),
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::ThreeDsCompletionIndicator>
    for connector_types::ThreeDsCompletionIndicator
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::ThreeDsCompletionIndicator,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::ThreeDsCompletionIndicator::Success => Ok(Self::Success),
            grpc_api_types::payments::ThreeDsCompletionIndicator::Failure => Ok(Self::Failure),
            _ => Ok(Self::NotAvailable),
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::CardNetwork> for CardNetwork {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        network: grpc_api_types::payments::CardNetwork,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match network {
            grpc_api_types::payments::CardNetwork::Visa => Ok(Self::Visa),
            grpc_api_types::payments::CardNetwork::Mastercard => Ok(Self::Mastercard),
            grpc_api_types::payments::CardNetwork::Amex => Ok(Self::AmericanExpress),
            grpc_api_types::payments::CardNetwork::Jcb => Ok(Self::JCB),
            grpc_api_types::payments::CardNetwork::Diners => Ok(Self::DinersClub),
            grpc_api_types::payments::CardNetwork::Discover => Ok(Self::Discover),
            grpc_api_types::payments::CardNetwork::CartesBancaires => Ok(Self::CartesBancaires),
            grpc_api_types::payments::CardNetwork::Unionpay => Ok(Self::UnionPay),
            grpc_api_types::payments::CardNetwork::Rupay => Ok(Self::RuPay),
            grpc_api_types::payments::CardNetwork::Maestro => Ok(Self::Maestro),
            grpc_api_types::payments::CardNetwork::InteracCard => Ok(Self::Interac),
            grpc_api_types::payments::CardNetwork::Star => Ok(Self::Star),
            grpc_api_types::payments::CardNetwork::Pulse => Ok(Self::Pulse),
            grpc_api_types::payments::CardNetwork::Accel => Ok(Self::Accel),
            grpc_api_types::payments::CardNetwork::Nyce => Ok(Self::Nyce),
            grpc_api_types::payments::CardNetwork::Unspecified => {
                Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "UNSPECIFIED_CARD_NETWORK".to_owned(),
                    error_identifier: 401,
                    error_message: "Card network must be specified".to_owned(),
                    error_object: None,
                })
                .into())
            }
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::Tokenization> for common_enums::Tokenization {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::Tokenization,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::Tokenization::SkipPsp => Ok(Self::SkipPsp),
            grpc_api_types::payments::Tokenization::TokenizeAtPsp => Ok(Self::TokenizeAtPsp),
            grpc_api_types::payments::Tokenization::Unspecified => {
                Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "UNSPECIFIED_TOKENIZATION_STRATEGY".to_owned(),
                    error_identifier: 400,
                    error_message: "Tokenization strategy must be specified".to_owned(),
                    error_object: None,
                })
                .into())
            }
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentExperience>
    for common_enums::PaymentExperience
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentExperience,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::PaymentExperience::RedirectToUrl => Ok(Self::RedirectToUrl),
            grpc_api_types::payments::PaymentExperience::InvokeSdkClient => {
                Ok(Self::InvokeSdkClient)
            }
            grpc_api_types::payments::PaymentExperience::DisplayQrCode => Ok(Self::DisplayQrCode),
            grpc_api_types::payments::PaymentExperience::OneClick => Ok(Self::OneClick),
            grpc_api_types::payments::PaymentExperience::LinkWallet => Ok(Self::LinkWallet),
            grpc_api_types::payments::PaymentExperience::InvokePaymentApp => {
                Ok(Self::InvokePaymentApp)
            }
            grpc_api_types::payments::PaymentExperience::DisplayWaitScreen => {
                Ok(Self::DisplayWaitScreen)
            }
            grpc_api_types::payments::PaymentExperience::CollectOtp => Ok(Self::CollectOtp),
            grpc_api_types::payments::PaymentExperience::Unspecified => {
                Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "UNSPECIFIED_PAYMENT_EXPERIENCE".to_owned(),
                    error_identifier: 401,
                    error_message: "Payment experience must be specified".to_owned(),
                    error_object: None,
                })
                .into())
            }
        }
    }
}

// Helper function to extract and convert UPI source from gRPC type
fn convert_upi_source(
    source_option: Option<i32>,
) -> Result<Option<payment_method_data::UpiSource>, error_stack::Report<ApplicationErrorResponse>> {
    source_option
        .map(|source| {
            grpc_api_types::payments::UpiSource::try_from(source)
                .map_err(|_| {
                    error_stack::report!(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_UPI_SOURCE".to_owned(),
                        error_identifier: 400,
                        error_message: "Invalid UPI source value".to_owned(),
                        error_object: None,
                    }))
                })
                .and_then(payment_method_data::UpiSource::foreign_try_from)
        })
        .transpose()
}

impl ForeignTryFrom<grpc_api_types::payments::UpiSource> for payment_method_data::UpiSource {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::UpiSource,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::UpiSource::UpiCc => Ok(Self::UpiCc),
            grpc_api_types::payments::UpiSource::UpiCl => Ok(Self::UpiCl),
            grpc_api_types::payments::UpiSource::UpiAccount => Ok(Self::UpiAccount),
            grpc_api_types::payments::UpiSource::UpiCcCl => Ok(Self::UpiCcCl),
            grpc_api_types::payments::UpiSource::UpiPpi => Ok(Self::UpiPpi),
            grpc_api_types::payments::UpiSource::UpiVoucher => Ok(Self::UpiVoucher),
        }
    }
}

impl ForeignFrom<payment_method_data::UpiSource> for grpc_api_types::payments::UpiSource {
    fn foreign_from(value: payment_method_data::UpiSource) -> Self {
        match value {
            payment_method_data::UpiSource::UpiCc => Self::UpiCc,
            payment_method_data::UpiSource::UpiCl => Self::UpiCl,
            payment_method_data::UpiSource::UpiAccount => Self::UpiAccount,
            payment_method_data::UpiSource::UpiCcCl => Self::UpiCcCl,
            payment_method_data::UpiSource::UpiPpi => Self::UpiPpi,
            payment_method_data::UpiSource::UpiVoucher => Self::UpiVoucher,
        }
    }
}

impl<
        T: PaymentMethodDataTypes
            + Default
            + Debug
            + Send
            + Eq
            + PartialEq
            + Serialize
            + serde::de::DeserializeOwned
            + Clone
            + CardConversionHelper<T>,
    > ForeignTryFrom<grpc_api_types::payments::PaymentMethod> for PaymentMethodData<T>
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentMethod,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        tracing::info!("PaymentMethod data received: {:?}", value);

        match value.payment_method {
            Some(data) => match data {
                // ============================================================================
                // CARD METHODS
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Card(card_details) => {
                    let card = payment_method_data::Card::<T>::foreign_try_from(card_details)?;
                    Ok(Self::Card(card))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::CardProxy(
                    card_details,
                ) => {
                    let card = payment_method_data::Card::<T>::foreign_try_from(card_details)?;
                    Ok(Self::Card(card))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::CardRedirect(
                    card_redirect,
                ) => {
                    let card_redirect_data = match card_redirect.r#type() {
                        grpc_api_types::payments::card_redirect::CardRedirectType::Knet => {
                            payment_method_data::CardRedirectData::Knet {}
                        }
                        grpc_api_types::payments::card_redirect::CardRedirectType::Benefit => {
                            payment_method_data::CardRedirectData::Benefit {}
                        }
                        grpc_api_types::payments::card_redirect::CardRedirectType::MomoAtm => {
                            payment_method_data::CardRedirectData::MomoAtm {}
                        }
                        grpc_api_types::payments::card_redirect::CardRedirectType::CardRedirect => {
                            payment_method_data::CardRedirectData::CardRedirect {}
                        }
                        grpc_api_types::payments::card_redirect::CardRedirectType::Unspecified => {
                            return Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "UNSPECIFIED_CARD_REDIRECT_TYPE".to_owned(),
                                error_identifier: 400,
                                error_message: "Card redirect type cannot be unspecified".to_owned(),
                                error_object: None,
                            })))
                        }
                    };
                    Ok(Self::CardRedirect(card_redirect_data))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::Token(_token) => {
                    Ok(Self::CardToken(payment_method_data::CardToken {
                        card_holder_name: None,
                        card_cvc: None,
                    }))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::UpiCollect(
                    upi_collect,
                ) => {
                    let upi_source = convert_upi_source(upi_collect.upi_source)?;
                    Ok(PaymentMethodData::Upi(
                        payment_method_data::UpiData::UpiCollect(
                            payment_method_data::UpiCollectData {
                                vpa_id: upi_collect.vpa_id.map(|vpa| vpa.expose().into()),
                                upi_source,
                            },
                        ),
                    ))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::UpiIntent(upi_intent) => {
                    let upi_source = convert_upi_source(upi_intent.upi_source)?;
                    Ok(PaymentMethodData::Upi(
                        payment_method_data::UpiData::UpiIntent(
                            payment_method_data::UpiIntentData { upi_source },
                        ),
                    ))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::UpiQr(upi_qr) => {
                    let upi_source = convert_upi_source(upi_qr.upi_source)?;
                    Ok(PaymentMethodData::Upi(
                        crate::payment_method_data::UpiData::UpiQr(
                            crate::payment_method_data::UpiQrData { upi_source },
                        ),
                    ))
                }
                // ============================================================================
                // REWARD METHODS - Flattened direct variants
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::ClassicReward(_) => {
                    Ok(Self::Reward)
                }
                grpc_api_types::payments::payment_method::PaymentMethod::EVoucher(_) => {
                    Ok(Self::Reward)
                }
                // ============================================================================
                // DIGITAL WALLETS - Direct conversions
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Bluecode(_) => Ok(
                    Self::Wallet(payment_method_data::WalletData::BluecodeRedirect {}),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::RevolutPay(_) => {
                    Ok(Self::Wallet(payment_method_data::WalletData::RevolutPay(
                        payment_method_data::RevolutPayData {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::AliPayRedirect(_) => Ok(
                    Self::Wallet(payment_method_data::WalletData::AliPayRedirect(
                        payment_method_data::AliPayRedirection {},
                    )),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::AmazonPayRedirect(_) => {
                    Ok(Self::Wallet(
                        payment_method_data::WalletData::AmazonPayRedirect(Box::new(
                            payment_method_data::AmazonPayRedirectData {},
                        )),
                    ))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::CashappQr(_) => {
                    Ok(Self::Wallet(payment_method_data::WalletData::CashappQr(
                        Box::new(payment_method_data::CashappQr {}),
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::WeChatPayQr(_) => {
                    Ok(Self::Wallet(payment_method_data::WalletData::WeChatPayQr(
                        Box::new(payment_method_data::WeChatPayQr {}),
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::Mifinity(
                    mifinity_data,
                ) => Ok(Self::Wallet(payment_method_data::WalletData::Mifinity(
                    payment_method_data::MifinityData {
                        date_of_birth: Secret::<time::Date>::foreign_try_from(
                            mifinity_data
                                .date_of_birth
                                .ok_or(ApplicationErrorResponse::BadRequest(ApiError {
                                    sub_code: "MISSING_DATE_OF_BIRTH".to_owned(),
                                    error_identifier: 400,
                                    error_message: "Missing Date of Birth".to_owned(),
                                    error_object: None,
                                }))?
                                .expose(),
                        )?,
                        language_preference: mifinity_data.language_preference,
                    },
                ))),
                grpc_api_types::payments::payment_method::PaymentMethod::ApplePay(apple_wallet) => {
                    let payment_data = apple_wallet.payment_data.ok_or_else(|| {
                        ApplicationErrorResponse::BadRequest(ApiError {
                            sub_code: "MISSING_APPLE_PAY_PAYMENT_DATA".to_owned(),
                            error_identifier: 400,
                            error_message: "Apple Pay payment data is required".to_owned(),
                            error_object: None,
                        })
                    })?;

                    let applepay_payment_data = match payment_data.payment_data {
                                Some(grpc_api_types::payments::apple_wallet::payment_data::PaymentData::EncryptedData(encrypted_data)) => {
                                    Ok(payment_method_data::ApplePayPaymentData::Encrypted(encrypted_data))
                                },
                                Some(grpc_api_types::payments::apple_wallet::payment_data::PaymentData::DecryptedData(decrypted_data)) => {
                                    let decrypted_payment_data = decrypted_data.payment_data.ok_or(
                                        ApplicationErrorResponse::BadRequest(ApiError {
                                            sub_code: "MISSING_DECRYPTED_PAYMENT_DATA".to_owned(),
                                            error_identifier: 400,
                                            error_message: "Apple Pay decrypted payment data is required".to_owned(),
                                            error_object: None,
                                        })
                                    )?;

                                    Ok(payment_method_data::ApplePayPaymentData::Decrypted(
                                        payment_method_data::ApplePayPredecryptData {
                                            application_primary_account_number: decrypted_data.application_primary_account_number.ok_or(
                                                ApplicationErrorResponse::BadRequest(ApiError {
                                                    sub_code: "MISSING_APPLICATION_PRIMARY_ACCOUNT_NUMBER".to_owned(),
                                                    error_identifier: 400,
                                                    error_message: "Apple Pay payment data application primary account number is required".to_owned(),
                                                    error_object: None,
                                                })
                                            )?,
                                            application_expiration_month: decrypted_data.application_expiration_month.ok_or(
                                                ApplicationErrorResponse::BadRequest(ApiError {
                                                    sub_code: "MISSING_APPLICATION_EXPIRATION_MONTH".to_owned(),
                                                    error_identifier: 400,
                                                    error_message: "Apple Pay payment data application expiration month is required".to_owned(),
                                                    error_object: None,
                                                })
                                            )?,
                                            application_expiration_year: decrypted_data.application_expiration_year.ok_or(
                                                ApplicationErrorResponse::BadRequest(ApiError {
                                                    sub_code: "MISSING_APPLICATION_EXPIRATION_YEAR".to_owned(),
                                                    error_identifier: 400,
                                                    error_message: "Apple Pay payment data application expiration year is required".to_owned(),
                                                    error_object: None,
                                                })
                                            )?,
                                            payment_data: payment_method_data::ApplePayCryptogramData {
                                                online_payment_cryptogram: decrypted_payment_data.online_payment_cryptogram.ok_or(
                                                    ApplicationErrorResponse::BadRequest(ApiError {
                                                        sub_code: "MISSING_ONLINE_PAYMENT_CRYPTOGRAM".to_owned(),
                                                        error_identifier: 400,
                                                        error_message: "Apple Pay payment data online payment cryptogram is required".to_owned(),
                                                        error_object: None,
                                                    })
                                                )?,
                                                eci_indicator: decrypted_payment_data.eci_indicator,
                                            },
                                        }
                                    ))
                                },
                                None => Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                                        sub_code: "MISSING_APPLE_PAY_DATA".to_owned(),
                                        error_identifier: 400,
                                        error_message: "Apple Pay payment data is required".to_owned(),
                                        error_object: None,
                                    })))
                            }?;

                    let payment_method = apple_wallet.payment_method.ok_or_else(|| {
                        ApplicationErrorResponse::BadRequest(ApiError {
                            sub_code: "MISSING_APPLE_PAY_PAYMENT_METHOD".to_owned(),
                            error_identifier: 400,
                            error_message: "Apple Pay payment method is required".to_owned(),
                            error_object: None,
                        })
                    })?;

                    let wallet_data = payment_method_data::ApplePayWalletData {
                        payment_data: applepay_payment_data,
                        payment_method: payment_method_data::ApplepayPaymentMethod {
                            display_name: payment_method.display_name,
                            network: payment_method.network,
                            pm_type: payment_method.r#type,
                        },
                        transaction_identifier: apple_wallet.transaction_identifier,
                    };
                    Ok(Self::Wallet(payment_method_data::WalletData::ApplePay(
                        wallet_data,
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::GooglePay(
                    google_wallet,
                ) => {
                    let info = google_wallet.info.ok_or_else(|| {
                        ApplicationErrorResponse::BadRequest(ApiError {
                            sub_code: "MISSING_GOOGLE_PAY_INFO".to_owned(),
                            error_identifier: 400,
                            error_message: "Google Pay payment method info is required".to_owned(),
                            error_object: None,
                        })
                    })?;

                    let tokenization_data = google_wallet.tokenization_data.ok_or_else(|| {
                        ApplicationErrorResponse::BadRequest(ApiError {
                            sub_code: "MISSING_GOOGLE_PAY_TOKENIZATION_DATA".to_owned(),
                            error_identifier: 400,
                            error_message: "Google Pay tokenization data is required".to_owned(),
                            error_object: None,
                        })
                    })?;

                    // Handle the new oneof tokenization_data structure
                    let gpay_tokenization_data = match tokenization_data.tokenization_data {
                                Some(grpc_api_types::payments::google_wallet::tokenization_data::TokenizationData::DecryptedData(predecrypt_data)) => {
                                    Ok(payment_method_data::GpayTokenizationData::Decrypted(
                                        payment_method_data::GPayPredecryptData {
                                            card_exp_month: predecrypt_data.card_exp_month.ok_or(
                                                ApplicationErrorResponse::BadRequest(ApiError {
                                                    sub_code: "MISSING_CARD_EXP_MONTH".to_owned(),
                                                    error_identifier: 400,
                                                    error_message: "Google Pay tokenization data card exp month is required".to_owned(),
                                                    error_object: None,
                                                })
                                            )?,
                                            card_exp_year: predecrypt_data.card_exp_year.ok_or(
                                                ApplicationErrorResponse::BadRequest(ApiError {
                                                    sub_code: "MISSING_CARD_EXP_YEAR".to_owned(),
                                                    error_identifier: 400,
                                                    error_message: "Google Pay tokenization data card exp year is required".to_owned(),
                                                    error_object: None,
                                                })
                                            )?,
                                            application_primary_account_number: predecrypt_data.application_primary_account_number.ok_or(
                                                ApplicationErrorResponse::BadRequest(ApiError {
                                                    sub_code: "MISSING_APPLICATION_PRIMARY_ACCOUNT_NUMBER".to_owned(),
                                                    error_identifier: 400,
                                                    error_message: "Google Pay tokenization data application primary account number is required".to_owned(),
                                                    error_object: None,
                                                })
                                            )?,
                                            cryptogram: predecrypt_data.cryptogram,
                                            eci_indicator: predecrypt_data.eci_indicator,
                                        }
                                    ))
                                },
                                Some(grpc_api_types::payments::google_wallet::tokenization_data::TokenizationData::EncryptedData(encrypted_data)) => {
                                    Ok(payment_method_data::GpayTokenizationData::Encrypted(
                                        payment_method_data::GpayEcryptedTokenizationData {
                                            token_type: encrypted_data.token_type,
                                            token: encrypted_data.token,
                                        }
                                    ))
                                },
                                None => Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                                        sub_code: "MISSING_GOOGLE_PAY_TOKENIZATION_DATA".to_owned(),
                                        error_identifier: 400,
                                        error_message: "Google Pay tokenization data variant is required".to_owned(),
                                        error_object: None,
                                    })))
                            }?;

                    let wallet_data = payment_method_data::GooglePayWalletData {
                        pm_type: google_wallet.r#type,
                        description: google_wallet.description,
                        info: payment_method_data::GooglePayPaymentMethodInfo {
                            card_network: info.card_network,
                            card_details: info.card_details,
                            assurance_details: info.assurance_details.map(|details| {
                                payment_method_data::GooglePayAssuranceDetails {
                                    card_holder_authenticated: details.card_holder_authenticated,
                                    account_verified: details.account_verified,
                                }
                            }),
                        },
                        tokenization_data: gpay_tokenization_data,
                    };
                    Ok(Self::Wallet(payment_method_data::WalletData::GooglePay(
                        wallet_data,
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::GooglePayThirdPartySdk(
                    google_pay_sdk_wallet,
                ) => Ok(Self::Wallet(
                    payment_method_data::WalletData::GooglePayThirdPartySdk(Box::new(
                        payment_method_data::GooglePayThirdPartySdkData {
                            token: google_pay_sdk_wallet.token.map(|t| Secret::new(t.expose())),
                        },
                    )),
                )),
                grpc_api_types::payments::payment_method::PaymentMethod::ApplePayThirdPartySdk(
                    apple_pay_sdk_wallet,
                ) => Ok(Self::Wallet(
                    payment_method_data::WalletData::ApplePayThirdPartySdk(Box::new(
                        payment_method_data::ApplePayThirdPartySdkData {
                            token: apple_pay_sdk_wallet.token.map(|t| Secret::new(t.expose())),
                        },
                    )),
                )),
                grpc_api_types::payments::payment_method::PaymentMethod::PaypalSdk(
                    paypal_sdk_wallet,
                ) => Ok(Self::Wallet(payment_method_data::WalletData::PaypalSdk(
                    payment_method_data::PayPalWalletData {
                        token: paypal_sdk_wallet
                            .token
                            .ok_or_else(|| {
                                ApplicationErrorResponse::BadRequest(ApiError {
                                    sub_code: "MISSING_PAYPAL_SDK_TOKEN".to_owned(),
                                    error_identifier: 400,
                                    error_message: "PayPal SDK token is required".to_owned(),
                                    error_object: None,
                                })
                            })?
                            .expose(),
                    },
                ))),
                grpc_api_types::payments::payment_method::PaymentMethod::PaypalRedirect(
                    paypal_redirect,
                ) => Ok(Self::Wallet(
                    payment_method_data::WalletData::PaypalRedirect(
                        payment_method_data::PaypalRedirection {
                            email: match paypal_redirect.email {
                                Some(ref email_str) => Some(
                                    Email::try_from(email_str.clone().expose()).change_context(
                                        ApplicationErrorResponse::BadRequest(ApiError {
                                            sub_code: "INVALID_EMAIL_FORMAT".to_owned(),
                                            error_identifier: 400,
                                            error_message: "Invalid email".to_owned(),
                                            error_object: None,
                                        }),
                                    )?,
                                ),
                                None => None,
                            },
                        },
                    ),
                )),
                // ============================================================================
                // BANK TRANSFERS - Direct variants
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::InstantBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::InstantBankTransfer {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::AchBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::AchBankTransfer {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::SepaBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::SepaBankTransfer {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::BacsBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::BacsBankTransfer {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::MultibancoBankTransfer(
                    _,
                ) => Ok(Self::BankTransfer(Box::new(
                    payment_method_data::BankTransferData::MultibancoBankTransfer {},
                ))),
                grpc_api_types::payments::payment_method::PaymentMethod::InstantBankTransferFinland(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::InstantBankTransferFinland {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::InstantBankTransferPoland(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::InstantBankTransferPoland {},
                    )))
                }
                // ============================================================================
                // ONLINE BANKING - Direct variants
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::OpenBankingUk(
                    open_banking_uk,
                ) => Ok(Self::BankRedirect(
                    payment_method_data::BankRedirectData::OpenBankingUk {
                        issuer: open_banking_uk
                            .issuer
                            .and_then(|i| common_enums::BankNames::from_str(&i).ok()),
                        country: open_banking_uk
                            .country
                            .and_then(|c| CountryAlpha2::from_str(&c).ok()),
                    },
                )),
                grpc_api_types::payments::payment_method::PaymentMethod::OpenBanking(_) => {
                    Ok(PaymentMethodData::BankRedirect(
                        payment_method_data::BankRedirectData::OpenBanking {},
                    ))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::OnlineBankingFpx(fpx) => {
                    Ok(Self::BankRedirect(
                        payment_method_data::BankRedirectData::OnlineBankingFpx {
                            issuer: common_enums::BankNames::foreign_try_from(fpx.issuer())?,
                        },
                    ))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::Ideal(ideal) => Ok(
                    Self::BankRedirect(payment_method_data::BankRedirectData::Ideal {
                        bank_name: match ideal.bank_name() {
                            grpc_payment_types::BankNames::Unspecified => None,
                            _ => Some(common_enums::BankNames::foreign_try_from(
                                ideal.bank_name(),
                            )?),
                        },
                    }),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::Giropay(giropay) => Ok(
                    Self::BankRedirect(payment_method_data::BankRedirectData::Giropay {
                        country: match giropay.country() {
                            grpc_payment_types::CountryAlpha2::Unspecified => None,
                            _ => Some(CountryAlpha2::foreign_try_from(giropay.country())?),
                        },
                        bank_account_bic: giropay.bank_account_bic,
                        bank_account_iban: giropay.bank_account_iban,
                    }),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::Eps(eps) => Ok(
                    Self::BankRedirect(payment_method_data::BankRedirectData::Eps {
                        bank_name: match eps.bank_name() {
                            grpc_payment_types::BankNames::Unspecified => None,
                            _ => Some(common_enums::BankNames::foreign_try_from(eps.bank_name())?),
                        },
                        country: match eps.country() {
                            grpc_payment_types::CountryAlpha2::Unspecified => None,
                            _ => Some(CountryAlpha2::foreign_try_from(eps.country())?),
                        },
                    }),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::Sofort(sofort) => Ok(
                    Self::BankRedirect(payment_method_data::BankRedirectData::Sofort {
                        country: match sofort.country() {
                            grpc_payment_types::CountryAlpha2::Unspecified => None,
                            _ => Some(CountryAlpha2::foreign_try_from(sofort.country())?),
                        },
                        preferred_language: sofort.preferred_language,
                    }),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::Przelewy24(przelewy24) => {
                    Ok(Self::BankRedirect(
                        payment_method_data::BankRedirectData::Przelewy24 {
                            bank_name: match przelewy24.bank_name() {
                                grpc_payment_types::BankNames::Unspecified => None,
                                _ => Some(common_enums::BankNames::foreign_try_from(
                                    przelewy24.bank_name(),
                                )?),
                            },
                        },
                    ))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::BancontactCard(
                    bancontactcard,
                ) => Ok(Self::BankRedirect(
                    payment_method_data::BankRedirectData::BancontactCard {
                        card_number: bancontactcard.card_number,
                        card_exp_month: bancontactcard.card_exp_month,
                        card_exp_year: bancontactcard.card_exp_year,
                        card_holder_name: bancontactcard.card_holder_name,
                    },
                )),
                grpc_payment_types::payment_method::PaymentMethod::Blik(blik) => Ok(
                    Self::BankRedirect(payment_method_data::BankRedirectData::Blik {
                        blik_code: blik.blik_code,
                    }),
                ),
                grpc_payment_types::payment_method::PaymentMethod::Interac(interac) => Ok(
                    Self::BankRedirect(payment_method_data::BankRedirectData::Interac {
                        country: match interac.country() {
                            grpc_payment_types::CountryAlpha2::Unspecified => None,
                            _ => Some(CountryAlpha2::foreign_try_from(interac.country())?),
                        },
                        email: match interac.email {
                            Some(ref email_str) => Some(
                                Email::try_from(email_str.clone().expose()).change_context(
                                    ApplicationErrorResponse::BadRequest(ApiError {
                                        sub_code: "INVALID_EMAIL_FORMAT".to_owned(),
                                        error_identifier: 400,
                                        error_message: "Invalid email for Interac".to_owned(),
                                        error_object: None,
                                    }),
                                )?,
                            ),
                            None => None,
                        },
                    }),
                ),
                // ============================================================================
                // MOBILE PAYMENTS - Direct variants
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::DuitNow(_) => {
                    Ok(Self::RealTimePayment(Box::new(
                        payment_method_data::RealTimePaymentData::DuitNow {},
                    )))
                }
                // ============================================================================
                // BUY NOW, PAY LATER - Direct variants
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Affirm(_) => Ok(
                    Self::PayLater(payment_method_data::PayLaterData::AffirmRedirect {}),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::AfterpayClearpay(_) => Ok(
                    Self::PayLater(payment_method_data::PayLaterData::AfterpayClearpayRedirect {}),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::Klarna(_) => Ok(
                    Self::PayLater(payment_method_data::PayLaterData::KlarnaRedirect {}),
                ),
                // ============================================================================
                // DIRECT DEBIT - Direct variants
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Ach(ach) => Ok(
                    Self::BankDebit(payment_method_data::BankDebitData::AchBankDebit {
                        bank_name: match ach.bank_name() {
                            grpc_payment_types::BankNames::Unspecified => None,
                            _ => Some(common_enums::BankNames::foreign_try_from(ach.bank_name())?),
                        },
                        bank_type: match ach.bank_type() {
                            grpc_payment_types::BankType::Unspecified => None,
                            _ => Some(common_enums::BankType::foreign_try_from(ach.bank_type())?),
                        },
                        bank_holder_type: match ach.bank_holder_type() {
                            grpc_payment_types::BankHolderType::Unspecified => None,
                            _ => Some(common_enums::BankHolderType::foreign_try_from(
                                ach.bank_holder_type(),
                            )?),
                        },
                        card_holder_name: ach.card_holder_name,
                        bank_account_holder_name: ach.bank_account_holder_name,
                        account_number: ach.account_number.ok_or(
                            ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "MISSING_ACH_ACCOUNT_NUMBER".to_owned(),
                                error_identifier: 400,
                                error_message: "ACH account number is required".to_owned(),
                                error_object: None,
                            }),
                        )?,
                        routing_number: ach.routing_number.ok_or(
                            ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "MISSING_ACH_ROUTING_NUMBER".to_owned(),
                                error_identifier: 400,
                                error_message: "ACH routing number is required".to_owned(),
                                error_object: None,
                            }),
                        )?,
                    }),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::Sepa(sepa) => Ok(
                    Self::BankDebit(payment_method_data::BankDebitData::SepaBankDebit {
                        iban: sepa
                            .iban
                            .ok_or(ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "MISSING_SEPA_IBAN".to_owned(),
                                error_identifier: 400,
                                error_message: "SEPA IBAN is required".to_owned(),
                                error_object: None,
                            }))?,
                        bank_account_holder_name: sepa.bank_account_holder_name,
                    }),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::Bacs(bacs) => Ok(
                    Self::BankDebit(payment_method_data::BankDebitData::BacsBankDebit {
                        account_number: bacs.account_number.ok_or(
                            ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "MISSING_BACS_ACCOUNT_NUMBER".to_owned(),
                                error_identifier: 400,
                                error_message: "BACS account number is required".to_owned(),
                                error_object: None,
                            }),
                        )?,
                        sort_code: bacs.sort_code.ok_or(ApplicationErrorResponse::BadRequest(
                            ApiError {
                                sub_code: "MISSING_BACS_SORT_CODE".to_owned(),
                                error_identifier: 400,
                                error_message: "BACS sort code is required".to_owned(),
                                error_object: None,
                            },
                        ))?,
                        bank_account_holder_name: bacs.bank_account_holder_name,
                    }),
                ),
                grpc_api_types::payments::payment_method::PaymentMethod::Becs(becs) => Ok(
                    Self::BankDebit(payment_method_data::BankDebitData::BecsBankDebit {
                        account_number: becs.account_number.ok_or(
                            ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "MISSING_BECS_ACCOUNT_NUMBER".to_owned(),
                                error_identifier: 400,
                                error_message: "BECS account number is required".to_owned(),
                                error_object: None,
                            }),
                        )?,
                        bsb_number: becs.bsb_number.ok_or(ApplicationErrorResponse::BadRequest(
                            ApiError {
                                sub_code: "MISSING_BECS_BSB_NUMBER".to_owned(),
                                error_identifier: 400,
                                error_message: "BECS BSB number is required".to_owned(),
                                error_object: None,
                            },
                        ))?,
                        bank_account_holder_name: becs.bank_account_holder_name,
                    }),
                ),
                // ============================================================================
                // CRYPTOCURRENCY - Direct variant
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Crypto(
                    crypto_currency,
                ) => Ok(Self::Crypto(payment_method_data::CryptoData {
                    pay_currency: crypto_currency.pay_currency,
                    network: crypto_currency.network,
                })),

                // ============================================================================
                // NETWORK TRANSACTION METHODS - New variants for recurring payments
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::CardDetailsForNetworkTransactionId(
                    card_details_for_nti,
                ) => {
                    let card_number = card_details_for_nti.card_number
                        .ok_or_else(|| ApplicationErrorResponse::BadRequest(ApiError {
                            sub_code: "MISSING_CARD_NUMBER".to_owned(),
                            error_identifier: 400,
                            error_message: "Missing card number for network transaction ID".to_owned(),
                            error_object: None,
                        }))?;

                    Ok(Self::CardDetailsForNetworkTransactionId(
                        payment_method_data::CardDetailsForNetworkTransactionId {
                            card_number,
                            card_exp_month: card_details_for_nti.card_exp_month.ok_or_else(|| ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "MISSING_CARD_EXP_MONTH".to_owned(),
                                error_identifier: 400,
                                error_message: "Missing card expiration month".to_owned(),
                                error_object: None,
                            }))?,
                            card_exp_year: card_details_for_nti.card_exp_year.ok_or_else(|| ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "MISSING_CARD_EXP_YEAR".to_owned(),
                                error_identifier: 400,
                                error_message: "Missing card expiration year".to_owned(),
                                error_object: None,
                            }))?,
                            card_issuer: card_details_for_nti.card_issuer,
                            card_network: card_details_for_nti
                                .card_network
                                .and_then(|network_i32| grpc_payment_types::CardNetwork::try_from(network_i32).ok())
                                .and_then(|network| CardNetwork::foreign_try_from(network).ok()),
                            card_type: card_details_for_nti.card_type,
                            card_issuing_country: card_details_for_nti.card_issuing_country,
                            bank_code: card_details_for_nti.bank_code,
                            nick_name: card_details_for_nti.nick_name,
                            card_holder_name: card_details_for_nti.card_holder_name,
                        },
                    ))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::NetworkToken(
                    network_token_data,
                ) => {
                    let token_number = network_token_data.token_number
                        .ok_or_else(|| ApplicationErrorResponse::BadRequest(ApiError {
                            sub_code: "MISSING_NETWORK_TOKEN".to_owned(),
                            error_identifier: 400,
                            error_message: "Missing network token".to_owned(),
                            error_object: None,
                        }))?;

                    Ok(Self::NetworkToken(payment_method_data::NetworkTokenData {
                        token_number,
                        token_exp_month: network_token_data.token_exp_month.ok_or_else(|| ApplicationErrorResponse::BadRequest(ApiError {
                            sub_code: "MISSING_TOKEN_EXP_MONTH".to_owned(),
                            error_identifier: 400,
                            error_message: "Missing token expiration month".to_owned(),
                            error_object: None,
                        }))?,
                        token_exp_year: network_token_data.token_exp_year.ok_or_else(|| ApplicationErrorResponse::BadRequest(ApiError {
                            sub_code: "MISSING_TOKEN_EXP_YEAR".to_owned(),
                            error_identifier: 400,
                            error_message: "Missing token expiration year".to_owned(),
                            error_object: None,
                        }))?,
                        token_cryptogram: network_token_data.token_cryptogram,
                        card_issuer: network_token_data.card_issuer,
                        card_network: network_token_data
                            .card_network
                            .and_then(|network_i32| grpc_payment_types::CardNetwork::try_from(network_i32).ok())
                            .and_then(|network| CardNetwork::foreign_try_from(network).ok()),
                        card_type: network_token_data
                            .card_type,
                        card_issuing_country: network_token_data
                            .card_issuing_country,
                        bank_code: network_token_data.bank_code,
                        nick_name: network_token_data.nick_name,
                        eci: network_token_data.eci,
                    }))
                }

                // ============================================================================
                // BANK REDIRECT - Trustly
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Trustly(trustly_data) => {
                    let country = match trustly_data.country() {
                        grpc_payment_types::CountryAlpha2::Unspecified => None,
                        country_code => Some(CountryAlpha2::foreign_try_from(country_code)?),
                    };
                    Ok(Self::BankRedirect(
                        payment_method_data::BankRedirectData::Trustly { country },
                    ))
                }

                // ============================================================================
                // INDONESIAN BANK TRANSFERS - Doku Integration
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Pix(pix_data) => {
                    // Parse expiry_date from ISO 8601 string if provided
                    let expiry_date = pix_data
                        .expiry_date
                        .as_ref()
                        .and_then(|date_str| {
                            time::PrimitiveDateTime::parse(
                                date_str,
                                &time::format_description::well_known::Iso8601::DEFAULT,
                            )
                            .ok()
                        });

                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::Pix {
                            pix_key: pix_data.pix_key,
                            cpf: pix_data.cpf,
                            cnpj: pix_data.cnpj,
                            source_bank_account_id: None,
                            destination_bank_account_id: None,
                            expiry_date,
                        },
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::PermataBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::PermataBankTransfer {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::BcaBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::BcaBankTransfer {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::BniVaBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::BniVaBankTransfer {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::BriVaBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::BriVaBankTransfer {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::CimbVaBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::CimbVaBankTransfer {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::DanamonVaBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::DanamonVaBankTransfer {},
                    )))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::MandiriVaBankTransfer(_) => {
                    Ok(Self::BankTransfer(Box::new(
                        payment_method_data::BankTransferData::MandiriVaBankTransfer {},
                    )))
                }

                grpc_api_types::payments::payment_method::PaymentMethod::Givex(givex_data) => {
                    Ok(Self::GiftCard(Box::new(
                        payment_method_data::GiftCardData::Givex(payment_method_data::GiftCardDetails {
                            number: givex_data.number.ok_or_else(|| ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "MISSING_GIVEX_NUMBER".to_owned(),
                                error_identifier: 400,
                                error_message: "Missing Givex gift card number".to_owned(),
                                error_object: None,
                            }))?,
                            cvc: givex_data.cvc.ok_or_else(|| ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "MISSING_GIVEX_CVC".to_owned(),
                                error_identifier: 400,
                                error_message: "Missing Givex gift card CVC".to_owned(),
                                error_object: None,
                            }))?,
                        }),
                    )))
                }

                grpc_api_types::payments::payment_method::PaymentMethod::PaySafeCard(_) => {
                    Ok(Self::GiftCard(Box::new(
                        payment_method_data::GiftCardData::PaySafeCard {},
                    )))
                }

                _ => Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "UNSUPPORTED_PAYMENT_METHOD".to_owned(),
                    error_identifier: 400,
                    error_message: "This payment method type is not yet supported".to_owned(),
                    error_object: None,
                }))),
            },
            None => Err(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                error_identifier: 400,
                error_message: "Payment method data is required".to_owned(),
                error_object: None,
            })
            .into()),
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::BankType> for common_enums::BankType {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::BankType,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::BankType::Checking => Ok(common_enums::BankType::Checking),
            grpc_api_types::payments::BankType::Savings => Ok(common_enums::BankType::Savings),
            grpc_api_types::payments::BankType::Unspecified => {
                Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_BANK_TYPE".to_owned(),
                    error_identifier: 400,
                    error_message: "Invalid bank type".to_owned(),
                    error_object: None,
                }))?
            }
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::BankHolderType> for common_enums::BankHolderType {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::BankHolderType,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::BankHolderType::Personal => {
                Ok(common_enums::BankHolderType::Personal)
            }
            grpc_api_types::payments::BankHolderType::Business => {
                Ok(common_enums::BankHolderType::Business)
            }
            grpc_api_types::payments::BankHolderType::Unspecified => {
                Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_BANK_HOLDER_TYPE".to_owned(),
                    error_identifier: 400,
                    error_message: "Invalid bank holder type".to_owned(),
                    error_object: None,
                }))?
            }
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentMethodType> for Option<PaymentMethodType> {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentMethodType,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::PaymentMethodType::Unspecified => Ok(None),
            grpc_api_types::payments::PaymentMethodType::Credit => {
                Ok(Some(PaymentMethodType::Card))
            }
            grpc_api_types::payments::PaymentMethodType::Debit => Ok(Some(PaymentMethodType::Card)),
            grpc_api_types::payments::PaymentMethodType::UpiCollect => {
                Ok(Some(PaymentMethodType::UpiCollect))
            }
            grpc_api_types::payments::PaymentMethodType::UpiIntent => {
                Ok(Some(PaymentMethodType::UpiIntent))
            }
            grpc_api_types::payments::PaymentMethodType::UpiQr => {
                Ok(Some(PaymentMethodType::UpiIntent))
            } // UpiQr not yet implemented, fallback to UpiIntent
            grpc_api_types::payments::PaymentMethodType::ClassicReward => {
                Ok(Some(PaymentMethodType::ClassicReward))
            }
            grpc_api_types::payments::PaymentMethodType::Evoucher => {
                Ok(Some(PaymentMethodType::Evoucher))
            }
            grpc_api_types::payments::PaymentMethodType::ApplePay => {
                Ok(Some(PaymentMethodType::ApplePay))
            }
            grpc_api_types::payments::PaymentMethodType::GooglePay => {
                Ok(Some(PaymentMethodType::GooglePay))
            }
            grpc_api_types::payments::PaymentMethodType::AmazonPay => {
                Ok(Some(PaymentMethodType::AmazonPay))
            }
            grpc_api_types::payments::PaymentMethodType::RevolutPay => {
                Ok(Some(PaymentMethodType::RevolutPay))
            }
            grpc_api_types::payments::PaymentMethodType::PayPal => {
                Ok(Some(PaymentMethodType::Paypal))
            }
            grpc_api_types::payments::PaymentMethodType::WeChatPay => {
                Ok(Some(PaymentMethodType::WeChatPay))
            }
            grpc_api_types::payments::PaymentMethodType::AliPay => {
                Ok(Some(PaymentMethodType::AliPay))
            }
            grpc_api_types::payments::PaymentMethodType::Cashapp => {
                Ok(Some(PaymentMethodType::Cashapp))
            }
            grpc_api_types::payments::PaymentMethodType::SepaBankTransfer => {
                Ok(Some(PaymentMethodType::SepaBankTransfer))
            }
            grpc_api_types::payments::PaymentMethodType::InstantBankTransfer => {
                Ok(Some(PaymentMethodType::InstantBankTransfer))
            }
            grpc_api_types::payments::PaymentMethodType::InstantBankTransferFinland => {
                Ok(Some(PaymentMethodType::InstantBankTransferFinland))
            }
            grpc_api_types::payments::PaymentMethodType::InstantBankTransferPoland => {
                Ok(Some(PaymentMethodType::InstantBankTransferPoland))
            }
            _ => Err(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_PAYMENT_METHOD_TYPE".to_owned(),
                error_identifier: 400,
                error_message: "This payment method type is not yet supported".to_owned(),
                error_object: None,
            })
            .into()),
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentMethod> for Option<PaymentMethodType> {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentMethod,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value.payment_method {
            Some(data) => match data {
                // ============================================================================
                // CARD METHODS
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Card(_) => {
                    Ok(Some(PaymentMethodType::Card))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::CardProxy(_) => {
                    Ok(Some(PaymentMethodType::Card))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::CardRedirect(card_redirect) => {
    match card_redirect.r#type() {
                        grpc_api_types::payments::card_redirect::CardRedirectType::Knet => {
                            Ok(Some(PaymentMethodType::Knet))
                        }
                        grpc_api_types::payments::card_redirect::CardRedirectType::Benefit => {
                            Ok(Some(PaymentMethodType::Benefit))
                        }
                        grpc_api_types::payments::card_redirect::CardRedirectType::MomoAtm => {
                            Ok(Some(PaymentMethodType::MomoAtm))
                        }
                        grpc_api_types::payments::card_redirect::CardRedirectType::CardRedirect => {
                            Ok(Some(PaymentMethodType::CardRedirect))
                        }
                        grpc_api_types::payments::card_redirect::CardRedirectType::Unspecified => {
                            Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                                sub_code: "UNSPECIFIED_CARD_REDIRECT_TYPE".to_owned(),
                                error_identifier: 400,
                                error_message: "Card redirect type cannot be unspecified".to_owned(),
                                error_object: None,
                            })))
                        }
                    }
                }
                grpc_api_types::payments::payment_method::PaymentMethod::Token(_) => {
                    Ok(None)
                },
                grpc_api_types::payments::payment_method::PaymentMethod::UpiCollect(_) => Ok(Some(PaymentMethodType::UpiCollect)),
                grpc_api_types::payments::payment_method::PaymentMethod::UpiIntent(_) => Ok(Some(PaymentMethodType::UpiIntent)),
                grpc_api_types::payments::payment_method::PaymentMethod::UpiQr(_) => Ok(Some(PaymentMethodType::UpiIntent)), // UpiQr not yet implemented, fallback to UpiIntent
                // ============================================================================
                // REWARD METHODS - Flattened direct variants
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::ClassicReward(_) => {
                    Ok(Some(PaymentMethodType::ClassicReward))
                },
                grpc_api_types::payments::payment_method::PaymentMethod::EVoucher(_) => {
                    Ok(Some(PaymentMethodType::Evoucher))
                },
                // ============================================================================
                // DIGITAL WALLETS - PaymentMethodType mappings
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::ApplePay(_) => Ok(Some(PaymentMethodType::ApplePay)),
                grpc_api_types::payments::payment_method::PaymentMethod::GooglePay(_) => Ok(Some(PaymentMethodType::GooglePay)),
                grpc_api_types::payments::payment_method::PaymentMethod::ApplePayThirdPartySdk(_) => Ok(Some(PaymentMethodType::ApplePay)),
                grpc_api_types::payments::payment_method::PaymentMethod::GooglePayThirdPartySdk(_) => Ok(Some(PaymentMethodType::GooglePay)),
                grpc_api_types::payments::payment_method::PaymentMethod::PaypalSdk(_) => Ok(Some(PaymentMethodType::Paypal)),
                grpc_api_types::payments::payment_method::PaymentMethod::AmazonPayRedirect(_) => Ok(Some(PaymentMethodType::AmazonPay)),
                grpc_api_types::payments::payment_method::PaymentMethod::CashappQr(_) => Ok(Some(PaymentMethodType::Cashapp)),
                grpc_api_types::payments::payment_method::PaymentMethod::PaypalRedirect(_) => Ok(Some(PaymentMethodType::Paypal)),
                grpc_api_types::payments::payment_method::PaymentMethod::WeChatPayQr(_) => Ok(Some(PaymentMethodType::WeChatPay)),
                grpc_api_types::payments::payment_method::PaymentMethod::AliPayRedirect(_) => Ok(Some(PaymentMethodType::AliPay)),
                grpc_api_types::payments::payment_method::PaymentMethod::RevolutPay(_) => Ok(Some(PaymentMethodType::RevolutPay)),
                grpc_api_types::payments::payment_method::PaymentMethod::Mifinity(_) => Ok(Some(PaymentMethodType::Mifinity)),
                grpc_api_types::payments::payment_method::PaymentMethod::Bluecode(_) => Ok(Some(PaymentMethodType::Bluecode)),
                // ============================================================================
                // BANK TRANSFERS - PaymentMethodType mappings
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::InstantBankTransfer(_) => Ok(Some(PaymentMethodType::InstantBankTransfer)),
                grpc_api_types::payments::payment_method::PaymentMethod::AchBankTransfer(_) => Ok(Some(PaymentMethodType::Ach)),
                grpc_api_types::payments::payment_method::PaymentMethod::SepaBankTransfer(_) => Ok(Some(PaymentMethodType::SepaBankTransfer)),
                grpc_api_types::payments::payment_method::PaymentMethod::BacsBankTransfer(_) => Ok(Some(PaymentMethodType::Bacs)),
                grpc_api_types::payments::payment_method::PaymentMethod::MultibancoBankTransfer(_) => Ok(Some(PaymentMethodType::Multibanco)),
                grpc_api_types::payments::payment_method::PaymentMethod::InstantBankTransferFinland(_) => Ok(Some(PaymentMethodType::InstantBankTransferFinland)),
                grpc_api_types::payments::payment_method::PaymentMethod::InstantBankTransferPoland(_) => Ok(Some(PaymentMethodType::InstantBankTransferPoland)),
                // ============================================================================
                // ONLINE BANKING - PaymentMethodType mappings
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::OpenBankingUk(_) => Ok(Some(PaymentMethodType::OpenBankingUk)),
                grpc_api_types::payments::payment_method::PaymentMethod::OpenBanking(_) => Ok(Some(PaymentMethodType::OpenBanking)),
                grpc_api_types::payments::payment_method::PaymentMethod::OnlineBankingFpx(_) => Ok(Some(PaymentMethodType::OnlineBankingFpx)),
                grpc_api_types::payments::payment_method::PaymentMethod::Ideal(_) => Ok(Some(PaymentMethodType::Ideal)),
                grpc_api_types::payments::payment_method::PaymentMethod::Giropay(_) => Ok(Some(PaymentMethodType::Giropay)),
                grpc_api_types::payments::payment_method::PaymentMethod::Eps(_) => Ok(Some(PaymentMethodType::Eps)),
                grpc_api_types::payments::payment_method::PaymentMethod::Przelewy24(_) => Ok(Some(PaymentMethodType::Przelewy24)),
                grpc_api_types::payments::payment_method::PaymentMethod::BancontactCard(_) => Ok(Some(PaymentMethodType::BancontactCard)),
                grpc_api_types::payments::payment_method::PaymentMethod::Blik(_) => Ok(Some(PaymentMethodType::Blik)),
                grpc_api_types::payments::payment_method::PaymentMethod::Sofort(_) => Ok(Some(PaymentMethodType::Sofort)),
                // ============================================================================
                // MOBILE & CRYPTO PAYMENTS - PaymentMethodType mappings
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::DuitNow(_) => Ok(Some(PaymentMethodType::DuitNow)),
                grpc_api_types::payments::payment_method::PaymentMethod::Crypto(_) => Ok(Some(PaymentMethodType::CryptoCurrency)),
                                // ============================================================================
                // BUY NOW, PAY LATER - PaymentMethodType mappings
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Affirm(_) => Ok(Some(PaymentMethodType::Affirm)),
                grpc_api_types::payments::payment_method::PaymentMethod::AfterpayClearpay(_) => Ok(Some(PaymentMethodType::AfterpayClearpay)),
                grpc_api_types::payments::payment_method::PaymentMethod::Klarna(_) => Ok(Some(PaymentMethodType::Klarna)),
                // ============================================================================
                // DIRECT DEBIT - PaymentMethodType mappings
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Ach(_) => Ok(Some(PaymentMethodType::Ach)),
                grpc_api_types::payments::payment_method::PaymentMethod::Sepa(_) => Ok(Some(PaymentMethodType::Sepa)),
                grpc_api_types::payments::payment_method::PaymentMethod::Bacs(_) => Ok(Some(PaymentMethodType::Bacs)),
                grpc_api_types::payments::payment_method::PaymentMethod::Becs(_) => Ok(Some(PaymentMethodType::Becs)),
                // ============================================================================
                // NETWORK TRANSACTION METHODS - recurring payments
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::CardDetailsForNetworkTransactionId(_) => Ok(Some(PaymentMethodType::Card)),
                grpc_api_types::payments::payment_method::PaymentMethod::NetworkToken(_) => Ok(Some(PaymentMethodType::Card)),
                // ============================================================================
                // GIFT CARDS
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Givex(_) => {
                    Ok(Some(PaymentMethodType::Givex))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::PaySafeCard(_) => {
                    Ok(Some(PaymentMethodType::PaySafeCard))
                }
                // ============================================================================
                // UNSUPPORTED ONLINE BANKING - Direct error generation
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::OnlineBankingThailand(_) => {
                    Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "UNSUPPORTED_PAYMENT_METHOD".to_owned(),
                        error_identifier: 400,
                        error_message: "Thai online banking is not yet supported".to_owned(),
                        error_object: None,
                    })))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::OnlineBankingCzechRepublic(_) => {
                    Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "UNSUPPORTED_PAYMENT_METHOD".to_owned(),
                        error_identifier: 400,
                        error_message: "Czech online banking is not yet supported".to_owned(),
                        error_object: None,
                    })))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::OnlineBankingFinland(_) => {
                    Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "UNSUPPORTED_PAYMENT_METHOD".to_owned(),
                        error_identifier: 400,
                        error_message: "Finnish online banking is not yet supported".to_owned(),
                        error_object: None,
                    })))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::OnlineBankingPoland(_) => {
                    Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "UNSUPPORTED_PAYMENT_METHOD".to_owned(),
                        error_identifier: 400,
                        error_message: "Polish online banking is not yet supported".to_owned(),
                        error_object: None,
                    })))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::OnlineBankingSlovakia(_) => {
                    Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "UNSUPPORTED_PAYMENT_METHOD".to_owned(),
                        error_identifier: 400,
                        error_message: "Slovak online banking is not yet supported".to_owned(),
                        error_object: None,
                    })))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::OpenBankingPis(_) => {
                    Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "UNSUPPORTED_PAYMENT_METHOD".to_owned(),
                        error_identifier: 400,
                        error_message: "Open Banking PIS is not yet supported".to_owned(),
                        error_object: None,
                    })))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::LocalBankRedirect(_) => {
                    Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "UNSUPPORTED_PAYMENT_METHOD".to_owned(),
                        error_identifier: 400,
                        error_message: "Local bank redirect is not yet supported".to_owned(),
                        error_object: None,
                    })))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::Trustly(_) => {
                    Ok(Some(PaymentMethodType::Trustly))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::Pse(_) => {
                    Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "UNSUPPORTED_PAYMENT_METHOD".to_owned(),
                        error_identifier: 400,
                        error_message: "PSE is not yet supported".to_owned(),
                        error_object: None,
                    })))
                }
                grpc_api_types::payments::payment_method::PaymentMethod::Interac(_) => {
                    Ok(Some(PaymentMethodType::Interac))
                }
                // ============================================================================
                // INDONESIAN BANK TRANSFERS - PaymentMethodType mappings
                // ============================================================================
                grpc_api_types::payments::payment_method::PaymentMethod::Pix(_) => Ok(Some(PaymentMethodType::Pix)),
                grpc_api_types::payments::payment_method::PaymentMethod::PermataBankTransfer(_) => Ok(Some(PaymentMethodType::PermataBankTransfer)),
                grpc_api_types::payments::payment_method::PaymentMethod::BcaBankTransfer(_) => Ok(Some(PaymentMethodType::BcaBankTransfer)),
                grpc_api_types::payments::payment_method::PaymentMethod::BniVaBankTransfer(_) => Ok(Some(PaymentMethodType::BniVa)),
                grpc_api_types::payments::payment_method::PaymentMethod::BriVaBankTransfer(_) => Ok(Some(PaymentMethodType::BriVa)),
                grpc_api_types::payments::payment_method::PaymentMethod::CimbVaBankTransfer(_) => Ok(Some(PaymentMethodType::CimbVa)),
                grpc_api_types::payments::payment_method::PaymentMethod::DanamonVaBankTransfer(_) => Ok(Some(PaymentMethodType::DanamonVa)),
                grpc_api_types::payments::payment_method::PaymentMethod::MandiriVaBankTransfer(_) => Ok(Some(PaymentMethodType::MandiriVa)),
            },
            None => Err(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                error_identifier: 400,
                error_message: "Payment method data is required".to_owned(),
                error_object: None,
            })
            .into()),
        }
    }
}

// Helper trait for generic card conversion
pub trait CardConversionHelper<T: PaymentMethodDataTypes> {
    fn convert_card_details(
        card: grpc_api_types::payments::CardDetails,
    ) -> Result<payment_method_data::Card<T>, error_stack::Report<ApplicationErrorResponse>>;
}

// Implementation for DefaultPCIHolder
impl CardConversionHelper<Self> for DefaultPCIHolder {
    fn convert_card_details(
        card: grpc_api_types::payments::CardDetails,
    ) -> Result<payment_method_data::Card<Self>, error_stack::Report<ApplicationErrorResponse>>
    {
        let card_network = match card.card_network() {
            grpc_api_types::payments::CardNetwork::Unspecified => None,
            _ => Some(CardNetwork::foreign_try_from(card.card_network())?),
        };
        Ok(payment_method_data::Card {
            card_number: RawCardNumber::<Self>(card.card_number.ok_or(
                ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "MISSING_CARD_NUMBER".to_owned(),
                    error_identifier: 400,
                    error_message: "Missing card number".to_owned(),
                    error_object: None,
                }),
            )?),
            card_exp_month: card
                .card_exp_month
                .ok_or(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "MISSING_EXP_MONTH".to_owned(),
                    error_identifier: 400,
                    error_message: "Missing Card Expiry Month".to_owned(),
                    error_object: None,
                }))?,
            card_exp_year: card
                .card_exp_year
                .ok_or(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "MISSING_EXP_YEAR".to_owned(),
                    error_identifier: 400,
                    error_message: "Missing Card Expiry Year".to_owned(),
                    error_object: None,
                }))?,
            card_cvc: card
                .card_cvc
                .ok_or(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "MISSING_CVC".to_owned(),
                    error_identifier: 400,
                    error_message: "Missing CVC".to_owned(),
                    error_object: None,
                }))?,
            card_issuer: card.card_issuer,
            card_network,
            card_type: card.card_type,
            card_issuing_country: card.card_issuing_country_alpha2,
            bank_code: card.bank_code,
            nick_name: card.nick_name.map(|name| name.into()),
            card_holder_name: card.card_holder_name,
            co_badged_card_data: None,
        })
    }
}

// Implementation for VaultTokenHolder
impl CardConversionHelper<Self> for VaultTokenHolder {
    fn convert_card_details(
        card: grpc_api_types::payments::CardDetails,
    ) -> Result<payment_method_data::Card<Self>, error_stack::Report<ApplicationErrorResponse>>
    {
        Ok(payment_method_data::Card {
            card_number: RawCardNumber(
                card.card_number
                    .ok_or(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "MISSING_CARD_NUMBER".to_owned(),
                        error_identifier: 400,
                        error_message: "Missing card number".to_owned(),
                        error_object: None,
                    }))
                    .map(|cn| cn.get_card_no())?,
            ),
            card_exp_month: card
                .card_exp_month
                .ok_or(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "MISSING_EXP_MONTH".to_owned(),
                    error_identifier: 400,
                    error_message: "Missing Card Expiry Month".to_owned(),
                    error_object: None,
                }))?,
            card_exp_year: card
                .card_exp_year
                .ok_or(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "MISSING_EXP_YEAR".to_owned(),
                    error_identifier: 400,
                    error_message: "Missing Card Expiry Year".to_owned(),
                    error_object: None,
                }))?,
            card_cvc: card
                .card_cvc
                .ok_or(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "MISSING_CVC".to_owned(),
                    error_identifier: 400,
                    error_message: "Missing CVC".to_owned(),
                    error_object: None,
                }))?,
            card_issuer: card.card_issuer,
            card_network: None,
            card_type: card.card_type,
            card_issuing_country: card.card_issuing_country_alpha2,
            bank_code: card.bank_code,
            nick_name: card.nick_name.map(|name| name.into()),
            card_holder_name: card.card_holder_name,
            co_badged_card_data: None,
        })
    }
}

// Generic ForeignTryFrom implementation using the helper trait
impl<T> ForeignTryFrom<grpc_api_types::payments::CardDetails> for payment_method_data::Card<T>
where
    T: PaymentMethodDataTypes
        + Default
        + Debug
        + Send
        + Eq
        + PartialEq
        + Serialize
        + serde::de::DeserializeOwned
        + Clone
        + CardConversionHelper<T>,
{
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        card: grpc_api_types::payments::CardDetails,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        T::convert_card_details(card)
    }
}

impl ForeignTryFrom<grpc_api_types::payments::Currency> for common_enums::Currency {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::Currency,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::Currency::Aed => Ok(Self::AED),
            grpc_api_types::payments::Currency::All => Ok(Self::ALL),
            grpc_api_types::payments::Currency::Amd => Ok(Self::AMD),
            grpc_api_types::payments::Currency::Ang => Ok(Self::ANG),
            grpc_api_types::payments::Currency::Aoa => Ok(Self::AOA),
            grpc_api_types::payments::Currency::Ars => Ok(Self::ARS),
            grpc_api_types::payments::Currency::Aud => Ok(Self::AUD),
            grpc_api_types::payments::Currency::Awg => Ok(Self::AWG),
            grpc_api_types::payments::Currency::Azn => Ok(Self::AZN),
            grpc_api_types::payments::Currency::Bam => Ok(Self::BAM),
            grpc_api_types::payments::Currency::Bbd => Ok(Self::BBD),
            grpc_api_types::payments::Currency::Bdt => Ok(Self::BDT),
            grpc_api_types::payments::Currency::Bgn => Ok(Self::BGN),
            grpc_api_types::payments::Currency::Bhd => Ok(Self::BHD),
            grpc_api_types::payments::Currency::Bif => Ok(Self::BIF),
            grpc_api_types::payments::Currency::Bmd => Ok(Self::BMD),
            grpc_api_types::payments::Currency::Bnd => Ok(Self::BND),
            grpc_api_types::payments::Currency::Bob => Ok(Self::BOB),
            grpc_api_types::payments::Currency::Brl => Ok(Self::BRL),
            grpc_api_types::payments::Currency::Bsd => Ok(Self::BSD),
            grpc_api_types::payments::Currency::Bwp => Ok(Self::BWP),
            grpc_api_types::payments::Currency::Byn => Ok(Self::BYN),
            grpc_api_types::payments::Currency::Bzd => Ok(Self::BZD),
            grpc_api_types::payments::Currency::Cad => Ok(Self::CAD),
            grpc_api_types::payments::Currency::Chf => Ok(Self::CHF),
            grpc_api_types::payments::Currency::Clp => Ok(Self::CLP),
            grpc_api_types::payments::Currency::Cny => Ok(Self::CNY),
            grpc_api_types::payments::Currency::Cop => Ok(Self::COP),
            grpc_api_types::payments::Currency::Crc => Ok(Self::CRC),
            grpc_api_types::payments::Currency::Cup => Ok(Self::CUP),
            grpc_api_types::payments::Currency::Cve => Ok(Self::CVE),
            grpc_api_types::payments::Currency::Czk => Ok(Self::CZK),
            grpc_api_types::payments::Currency::Djf => Ok(Self::DJF),
            grpc_api_types::payments::Currency::Dkk => Ok(Self::DKK),
            grpc_api_types::payments::Currency::Dop => Ok(Self::DOP),
            grpc_api_types::payments::Currency::Dzd => Ok(Self::DZD),
            grpc_api_types::payments::Currency::Egp => Ok(Self::EGP),
            grpc_api_types::payments::Currency::Etb => Ok(Self::ETB),
            grpc_api_types::payments::Currency::Eur => Ok(Self::EUR),
            grpc_api_types::payments::Currency::Fjd => Ok(Self::FJD),
            grpc_api_types::payments::Currency::Fkp => Ok(Self::FKP),
            grpc_api_types::payments::Currency::Gbp => Ok(Self::GBP),
            grpc_api_types::payments::Currency::Gel => Ok(Self::GEL),
            grpc_api_types::payments::Currency::Ghs => Ok(Self::GHS),
            grpc_api_types::payments::Currency::Gip => Ok(Self::GIP),
            grpc_api_types::payments::Currency::Gmd => Ok(Self::GMD),
            grpc_api_types::payments::Currency::Gnf => Ok(Self::GNF),
            grpc_api_types::payments::Currency::Gtq => Ok(Self::GTQ),
            grpc_api_types::payments::Currency::Gyd => Ok(Self::GYD),
            grpc_api_types::payments::Currency::Hkd => Ok(Self::HKD),
            grpc_api_types::payments::Currency::Hnl => Ok(Self::HNL),
            grpc_api_types::payments::Currency::Hrk => Ok(Self::HRK),
            grpc_api_types::payments::Currency::Htg => Ok(Self::HTG),
            grpc_api_types::payments::Currency::Huf => Ok(Self::HUF),
            grpc_api_types::payments::Currency::Idr => Ok(Self::IDR),
            grpc_api_types::payments::Currency::Ils => Ok(Self::ILS),
            grpc_api_types::payments::Currency::Inr => Ok(Self::INR),
            grpc_api_types::payments::Currency::Iqd => Ok(Self::IQD),
            grpc_api_types::payments::Currency::Jmd => Ok(Self::JMD),
            grpc_api_types::payments::Currency::Jod => Ok(Self::JOD),
            grpc_api_types::payments::Currency::Jpy => Ok(Self::JPY),
            grpc_api_types::payments::Currency::Kes => Ok(Self::KES),
            grpc_api_types::payments::Currency::Kgs => Ok(Self::KGS),
            grpc_api_types::payments::Currency::Khr => Ok(Self::KHR),
            grpc_api_types::payments::Currency::Kmf => Ok(Self::KMF),
            grpc_api_types::payments::Currency::Krw => Ok(Self::KRW),
            grpc_api_types::payments::Currency::Kwd => Ok(Self::KWD),
            grpc_api_types::payments::Currency::Kyd => Ok(Self::KYD),
            grpc_api_types::payments::Currency::Kzt => Ok(Self::KZT),
            grpc_api_types::payments::Currency::Lak => Ok(Self::LAK),
            grpc_api_types::payments::Currency::Lbp => Ok(Self::LBP),
            grpc_api_types::payments::Currency::Lkr => Ok(Self::LKR),
            grpc_api_types::payments::Currency::Lrd => Ok(Self::LRD),
            grpc_api_types::payments::Currency::Lsl => Ok(Self::LSL),
            grpc_api_types::payments::Currency::Lyd => Ok(Self::LYD),
            grpc_api_types::payments::Currency::Mad => Ok(Self::MAD),
            grpc_api_types::payments::Currency::Mdl => Ok(Self::MDL),
            grpc_api_types::payments::Currency::Mga => Ok(Self::MGA),
            grpc_api_types::payments::Currency::Mkd => Ok(Self::MKD),
            grpc_api_types::payments::Currency::Mmk => Ok(Self::MMK),
            grpc_api_types::payments::Currency::Mnt => Ok(Self::MNT),
            grpc_api_types::payments::Currency::Mop => Ok(Self::MOP),
            grpc_api_types::payments::Currency::Mru => Ok(Self::MRU),
            grpc_api_types::payments::Currency::Mur => Ok(Self::MUR),
            grpc_api_types::payments::Currency::Mvr => Ok(Self::MVR),
            grpc_api_types::payments::Currency::Mwk => Ok(Self::MWK),
            grpc_api_types::payments::Currency::Mxn => Ok(Self::MXN),
            grpc_api_types::payments::Currency::Myr => Ok(Self::MYR),
            grpc_api_types::payments::Currency::Mzn => Ok(Self::MZN),
            grpc_api_types::payments::Currency::Nad => Ok(Self::NAD),
            grpc_api_types::payments::Currency::Ngn => Ok(Self::NGN),
            grpc_api_types::payments::Currency::Nio => Ok(Self::NIO),
            grpc_api_types::payments::Currency::Nok => Ok(Self::NOK),
            grpc_api_types::payments::Currency::Npr => Ok(Self::NPR),
            grpc_api_types::payments::Currency::Nzd => Ok(Self::NZD),
            grpc_api_types::payments::Currency::Omr => Ok(Self::OMR),
            grpc_api_types::payments::Currency::Pab => Ok(Self::PAB),
            grpc_api_types::payments::Currency::Pen => Ok(Self::PEN),
            grpc_api_types::payments::Currency::Pgk => Ok(Self::PGK),
            grpc_api_types::payments::Currency::Php => Ok(Self::PHP),
            grpc_api_types::payments::Currency::Pkr => Ok(Self::PKR),
            grpc_api_types::payments::Currency::Pln => Ok(Self::PLN),
            grpc_api_types::payments::Currency::Pyg => Ok(Self::PYG),
            grpc_api_types::payments::Currency::Qar => Ok(Self::QAR),
            grpc_api_types::payments::Currency::Ron => Ok(Self::RON),
            grpc_api_types::payments::Currency::Rsd => Ok(Self::RSD),
            grpc_api_types::payments::Currency::Rub => Ok(Self::RUB),
            grpc_api_types::payments::Currency::Rwf => Ok(Self::RWF),
            grpc_api_types::payments::Currency::Sar => Ok(Self::SAR),
            grpc_api_types::payments::Currency::Sbd => Ok(Self::SBD),
            grpc_api_types::payments::Currency::Scr => Ok(Self::SCR),
            grpc_api_types::payments::Currency::Sek => Ok(Self::SEK),
            grpc_api_types::payments::Currency::Sgd => Ok(Self::SGD),
            grpc_api_types::payments::Currency::Shp => Ok(Self::SHP),
            grpc_api_types::payments::Currency::Sle => Ok(Self::SLE),
            grpc_api_types::payments::Currency::Sll => Ok(Self::SLL),
            grpc_api_types::payments::Currency::Sos => Ok(Self::SOS),
            grpc_api_types::payments::Currency::Srd => Ok(Self::SRD),
            grpc_api_types::payments::Currency::Ssp => Ok(Self::SSP),
            grpc_api_types::payments::Currency::Stn => Ok(Self::STN),
            grpc_api_types::payments::Currency::Svc => Ok(Self::SVC),
            grpc_api_types::payments::Currency::Szl => Ok(Self::SZL),
            grpc_api_types::payments::Currency::Thb => Ok(Self::THB),
            grpc_api_types::payments::Currency::Tnd => Ok(Self::TND),
            grpc_api_types::payments::Currency::Top => Ok(Self::TOP),
            grpc_api_types::payments::Currency::Try => Ok(Self::TRY),
            grpc_api_types::payments::Currency::Ttd => Ok(Self::TTD),
            grpc_api_types::payments::Currency::Twd => Ok(Self::TWD),
            grpc_api_types::payments::Currency::Tzs => Ok(Self::TZS),
            grpc_api_types::payments::Currency::Uah => Ok(Self::UAH),
            grpc_api_types::payments::Currency::Ugx => Ok(Self::UGX),
            grpc_api_types::payments::Currency::Usd => Ok(Self::USD),
            grpc_api_types::payments::Currency::Uyu => Ok(Self::UYU),
            grpc_api_types::payments::Currency::Uzs => Ok(Self::UZS),
            grpc_api_types::payments::Currency::Ves => Ok(Self::VES),
            grpc_api_types::payments::Currency::Vnd => Ok(Self::VND),
            grpc_api_types::payments::Currency::Vuv => Ok(Self::VUV),
            grpc_api_types::payments::Currency::Wst => Ok(Self::WST),
            grpc_api_types::payments::Currency::Xaf => Ok(Self::XAF),
            grpc_api_types::payments::Currency::Xcd => Ok(Self::XCD),
            grpc_api_types::payments::Currency::Xof => Ok(Self::XOF),
            grpc_api_types::payments::Currency::Xpf => Ok(Self::XPF),
            grpc_api_types::payments::Currency::Yer => Ok(Self::YER),
            grpc_api_types::payments::Currency::Zar => Ok(Self::ZAR),
            grpc_api_types::payments::Currency::Zmw => Ok(Self::ZMW),
            _ => Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "unsupported_currency".to_string(),
                error_identifier: 4001,
                error_message: format!("Currency {value:?} is not supported"),
                error_object: None,
            }))),
        }
    }
}

impl<
        T: PaymentMethodDataTypes
            + Default
            + Debug
            + Send
            + Eq
            + PartialEq
            + Serialize
            + serde::de::DeserializeOwned
            + Clone
            + CardConversionHelper<T>,
    > ForeignTryFrom<PaymentServiceAuthorizeRequest> for PaymentsAuthorizeData<T>
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: PaymentServiceAuthorizeRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let email: Option<Email> = match value.email {
            Some(ref email_str) => {
                Some(Email::try_from(email_str.clone().expose()).map_err(|_| {
                    error_stack::Report::new(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_EMAIL_FORMAT".to_owned(),
                        error_identifier: 400,

                        error_message: "Invalid email".to_owned(),
                        error_object: None,
                    }))
                })?)
            }
            None => None,
        };
        let merchant_config_currency = common_enums::Currency::foreign_try_from(value.currency())?;

        // Store merchant_account_metadata for connector use
        let merchant_account_metadata = value
            .clone()
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;
        let merchant_account_id = merchant_account_metadata
            .as_ref()
            .and_then(|m: &Secret<serde_json::Value>| m.peek().get("merchant_account_id"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let setup_future_usage = match value.setup_future_usage() {
            grpc_payment_types::FutureUsage::Unspecified => None,
            _ => Some(FutureUsage::foreign_try_from(value.setup_future_usage())?),
        };

        let customer_acceptance = value.customer_acceptance.clone();
        let authentication_data = value
            .authentication_data
            .clone()
            .map(router_request_types::AuthenticationData::try_from)
            .transpose()?;

        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);
        let shipping_cost = Some(common_utils::types::MinorUnit::new(value.shipping_cost()));
        // Connector testing data should be sent as a separate field (for adyen) (to be implemented)
        // For now, set to None as Hyperswitch needs to be updated to send this data properly
        let connector_testing_data: Option<Secret<serde_json::Value>> = None;

        let billing_descriptor = value
            .billing_descriptor
            .as_ref()
            .map(|descriptor| {
                BillingDescriptor::from((
                    descriptor,
                    value.statement_descriptor_name.clone(),
                    value.statement_descriptor_suffix.clone(),
                ))
            })
            .or_else(|| {
                // Only build a fallback if at least one descriptor exists
                if value.statement_descriptor_name.is_some()
                    || value.statement_descriptor_suffix.is_some()
                {
                    Some(BillingDescriptor {
                        name: None,
                        city: None,
                        phone: None,
                        reference: None,
                        statement_descriptor: value.statement_descriptor_name.clone(),
                        statement_descriptor_suffix: value.statement_descriptor_suffix.clone(),
                    })
                } else {
                    None
                }
            });

        let payment_channel = match value.payment_channel() {
            grpc_payment_types::PaymentChannel::Unspecified => None,
            _ => Some(common_enums::PaymentChannel::foreign_try_from(
                value.payment_channel(),
            )?),
        };
        let tokenization = match value.tokenization_strategy {
            None => None,
            Some(_) => Some(common_enums::Tokenization::foreign_try_from(
                value.tokenization_strategy(),
            )?),
        };

        Ok(Self {
            authentication_data,
            capture_method: Some(CaptureMethod::foreign_try_from(value.capture_method())?),
            payment_method_data: PaymentMethodData::<T>::foreign_try_from(
                value.payment_method.clone().ok_or_else(|| {
                    ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                        error_identifier: 400,
                        error_message: "Payment method data is required".to_owned(),
                        error_object: None,
                    })
                })?,
            )
            .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                error_identifier: 400,
                error_message: "Payment method data construction failed".to_owned(),
                error_object: None,
            }))?,
            amount: common_utils::types::MinorUnit::new(value.amount),
            currency: common_enums::Currency::foreign_try_from(value.currency())?,
            confirm: true,
            webhook_url: value.webhook_url.clone(),
            browser_info: value
                .browser_info
                .as_ref()
                .cloned()
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            payment_method_type: <Option<PaymentMethodType>>::foreign_try_from(
                value.payment_method.clone().ok_or_else(|| {
                    ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                        error_identifier: 400,
                        error_message: "Payment method data is required".to_owned(),
                        error_object: None,
                    })
                })?,
            )?,
            minor_amount: common_utils::types::MinorUnit::new(value.minor_amount),
            email,
            customer_name: None,
            billing_descriptor,
            router_return_url: value.return_url.clone(),
            complete_authorize_url: value.complete_authorize_url,
            setup_future_usage,
            mandate_id: None,
            off_session: value.off_session,
            order_category: value.order_category,
            session_token: None,
            access_token,
            customer_acceptance: customer_acceptance
                .map(mandates::CustomerAcceptance::foreign_try_from)
                .transpose()?,
            enrolled_for_3ds: value.enrolled_for_3ds,
            related_transaction_id: None,
            payment_experience: None,
            customer_id: value
                .customer_id
                .clone()
                .map(|customer_id| CustomerId::try_from(Cow::from(customer_id)))
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_CUSTOMER_ID".to_owned(),
                    error_identifier: 400,
                    error_message: "Failed to parse Customer Id".to_owned(),
                    error_object: None,
                }))?,
            request_incremental_authorization: value.request_incremental_authorization,
            metadata: value
                .metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "metadata")))
                .transpose()?,
            merchant_order_reference_id: value.merchant_order_reference_id,
            order_tax_amount: None,
            shipping_cost,
            merchant_account_id,
            integrity_object: None,
            merchant_config_currency: Some(merchant_config_currency),
            all_keys_required: None, // Field not available in new proto structure
            split_payments: None,
            enable_overcapture: None,
            setup_mandate_details: value
                .setup_mandate_details
                .map(MandateData::foreign_try_from)
                .transpose()?,
            request_extended_authorization: value.request_extended_authorization,
            merchant_account_metadata,
            connector_testing_data,
            payment_channel,
            enable_partial_authorization: value.enable_partial_authorization,
            locale: value.locale.clone(),
            // Below fields are set in AuthorizeOnly Flow
            continue_redirection_url: None,
            redirect_response: None,
            threeds_method_comp_ind: None,
            tokenization,
        })
    }
}

impl<
        T: PaymentMethodDataTypes
            + Default
            + Debug
            + Send
            + Eq
            + PartialEq
            + Serialize
            + serde::de::DeserializeOwned
            + Clone
            + CardConversionHelper<T>,
    > ForeignTryFrom<grpc_api_types::payments::PaymentServiceAuthorizeOnlyRequest>
    for PaymentsAuthorizeData<T>
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceAuthorizeOnlyRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let email: Option<Email> = match value.email {
            Some(ref email_str) => {
                Some(Email::try_from(email_str.clone().expose()).map_err(|_| {
                    error_stack::Report::new(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_EMAIL_FORMAT".to_owned(),
                        error_identifier: 400,

                        error_message: "Invalid email".to_owned(),
                        error_object: None,
                    }))
                })?)
            }
            None => None,
        };
        let merchant_config_currency = common_enums::Currency::foreign_try_from(value.currency())?;
        // Store merchant_account_metadata for connector use
        let merchant_account_metadata = value
            .clone()
            .merchant_account_metadata
            .map(|m| SecretSerdeValue::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;
        let merchant_account_id = merchant_account_metadata
            .as_ref()
            .and_then(|m| m.peek().get("merchant_account_id"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let setup_future_usage = match value.setup_future_usage() {
            grpc_payment_types::FutureUsage::Unspecified => None,
            _ => Some(FutureUsage::foreign_try_from(value.setup_future_usage())?),
        };

        let customer_acceptance = value.customer_acceptance.clone();
        let authentication_data = value
            .authentication_data
            .clone()
            .map(router_request_types::AuthenticationData::try_from)
            .transpose()?;

        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);
        let shipping_cost = Some(common_utils::types::MinorUnit::new(value.shipping_cost()));
        // Connector testing data should be sent as a separate field (for adyen) (to be implemented)
        // For now, set to None as Hyperswitch needs to be updated to send this data properly
        let connector_testing_data: Option<Secret<serde_json::Value>> = None;

        let billing_descriptor = value
            .billing_descriptor
            .as_ref()
            .map(|descriptor| {
                BillingDescriptor::from((
                    descriptor,
                    value.statement_descriptor_name.clone(),
                    value.statement_descriptor_suffix.clone(),
                ))
            })
            .or_else(|| {
                // Only build a fallback if at least one descriptor exists
                if value.statement_descriptor_name.is_some()
                    || value.statement_descriptor_suffix.is_some()
                {
                    Some(BillingDescriptor {
                        name: None,
                        city: None,
                        phone: None,
                        reference: None,
                        statement_descriptor: value.statement_descriptor_name.clone(),
                        statement_descriptor_suffix: value.statement_descriptor_suffix.clone(),
                    })
                } else {
                    None
                }
            });

        let payment_channel = match value.payment_channel() {
            grpc_payment_types::PaymentChannel::Unspecified => None,
            _ => Some(common_enums::PaymentChannel::foreign_try_from(
                value.payment_channel(),
            )?),
        };

        let redirect_response = value
            .redirection_response
            .clone()
            .map(|redirection_response| ContinueRedirectionResponse {
                params: redirection_response.params.map(Secret::new),
                payload: Some(Secret::new(serde_json::Value::Object(
                    redirection_response
                        .payload
                        .into_iter()
                        .map(|(k, v)| (k, serde_json::Value::String(v)))
                        .collect(),
                ))),
            });
        let tokenization = match value.tokenization_strategy {
            None => None,
            Some(_) => Some(common_enums::Tokenization::foreign_try_from(
                value.tokenization_strategy(),
            )?),
        };

        Ok(Self {
            authentication_data,
            capture_method: Some(CaptureMethod::foreign_try_from(value.capture_method())?),
            payment_method_data: PaymentMethodData::<T>::foreign_try_from(
                value.payment_method.clone().ok_or_else(|| {
                    ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                        error_identifier: 400,
                        error_message: "Payment method data is required".to_owned(),
                        error_object: None,
                    })
                })?,
            )
            .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                error_identifier: 400,
                error_message: "Payment method data construction failed".to_owned(),
                error_object: None,
            }))?,
            amount: common_utils::types::MinorUnit::new(value.amount),
            currency: common_enums::Currency::foreign_try_from(value.currency())?,
            confirm: true,
            webhook_url: value.webhook_url.clone(),
            browser_info: value
                .browser_info
                .as_ref()
                .cloned()
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            payment_method_type: <Option<PaymentMethodType>>::foreign_try_from(
                value.payment_method.clone().ok_or_else(|| {
                    ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                        error_identifier: 400,
                        error_message: "Payment method data is required".to_owned(),
                        error_object: None,
                    })
                })?,
            )?,
            minor_amount: common_utils::types::MinorUnit::new(value.minor_amount),
            email,
            customer_name: None,
            billing_descriptor,
            router_return_url: value.return_url.clone(),
            complete_authorize_url: value.complete_authorize_url,
            setup_future_usage,
            mandate_id: None,
            off_session: value.off_session,
            order_category: value.order_category,
            session_token: None,
            access_token,
            customer_acceptance: customer_acceptance
                .map(mandates::CustomerAcceptance::foreign_try_from)
                .transpose()?,
            enrolled_for_3ds: value.enrolled_for_3ds,
            related_transaction_id: None,
            payment_experience: None,
            customer_id: value
                .customer_id
                .clone()
                .map(|customer_id| CustomerId::try_from(Cow::from(customer_id)))
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_CUSTOMER_ID".to_owned(),
                    error_identifier: 400,
                    error_message: "Failed to parse Customer Id".to_owned(),
                    error_object: None,
                }))?,
            request_incremental_authorization: value.request_incremental_authorization,
            metadata: value
                .metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "metadata")))
                .transpose()?,
            merchant_order_reference_id: value.merchant_order_reference_id,
            order_tax_amount: None,
            shipping_cost,
            merchant_account_id,
            integrity_object: None,
            merchant_config_currency: Some(merchant_config_currency),
            all_keys_required: None, // Field not available in new proto structure
            split_payments: None,
            enable_overcapture: None,
            setup_mandate_details: value
                .setup_mandate_details
                .map(MandateData::foreign_try_from)
                .transpose()?,
            request_extended_authorization: value.request_extended_authorization,
            merchant_account_metadata,
            connector_testing_data,
            payment_channel,
            enable_partial_authorization: value.enable_partial_authorization,
            locale: value.locale.clone(),
            continue_redirection_url: value
                .continue_redirection_url
                .map(|url_str| {
                    url::Url::parse(&url_str).change_context(ApplicationErrorResponse::BadRequest(
                        ApiError {
                            sub_code: "INVALID_URL".to_owned(),
                            error_identifier: 400,
                            error_message: "Invalid continue redirection URL".to_owned(),
                            error_object: None,
                        },
                    ))
                })
                .transpose()?,
            redirect_response,
            threeds_method_comp_ind: value.threeds_completion_indicator.and_then(|value| {
                grpc_api_types::payments::ThreeDsCompletionIndicator::try_from(value)
                    .ok()
                    .and_then(|indicator| {
                        connector_types::ThreeDsCompletionIndicator::foreign_try_from(indicator)
                            .ok()
                    })
            }),
            tokenization,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentAddress> for PaymentAddress {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentAddress,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let shipping = match value.shipping_address {
            Some(address) => Some(Address::foreign_try_from(address)?),
            None => None,
        };

        let billing = match value.billing_address.clone() {
            Some(address) => Some(Address::foreign_try_from(address)?),
            None => None,
        };

        let payment_method_billing = match value.billing_address {
            Some(address) => Some(Address::foreign_try_from(address)?),
            None => None,
        };

        Ok(Self::new(
            shipping,
            billing,
            payment_method_billing,
            Some(false), // should_unify_address set to false
        ))
    }
}

impl ForeignTryFrom<grpc_api_types::payments::Address> for Address {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::Address,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let email = match value.email.clone() {
            Some(email) => Some(Email::from_str(&email.expose()).change_context(
                ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_EMAIL".to_owned(),
                    error_identifier: 400,
                    error_message: "Invalid email".to_owned(),
                    error_object: None,
                }),
            )?),
            None => None,
        };
        Ok(Self {
            address: Some(AddressDetails::foreign_try_from(value.clone())?),
            phone: value.phone_number.map(|phone_number| PhoneDetails {
                number: Some(phone_number),
                country_code: value.phone_country_code,
            }),
            email,
        })
    }
}

impl ForeignTryFrom<common_enums::Currency> for grpc_api_types::payments::Currency {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        currency: common_enums::Currency,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let grpc_currency = Self::from_str_name(&currency.to_string()).ok_or_else(|| {
            ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_CURRENCY".to_owned(),
                error_identifier: 400,
                error_message: "Failed to parse Currency".to_owned(),
                error_object: None,
            })
        })?;
        Ok(grpc_currency)
    }
}

impl ForeignTryFrom<CountryAlpha2> for grpc_api_types::payments::CountryAlpha2 {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(country: CountryAlpha2) -> Result<Self, error_stack::Report<Self::Error>> {
        let grpc_country = Self::from_str_name(&country.to_string()).ok_or_else(|| {
            ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_CURRENCY".to_owned(),
                error_identifier: 400,
                error_message: "Failed to parse Currency".to_owned(),
                error_object: None,
            })
        })?;
        Ok(grpc_country)
    }
}

impl ForeignTryFrom<grpc_api_types::payments::CountryAlpha2> for CountryAlpha2 {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::CountryAlpha2,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::CountryAlpha2::Us => Ok(Self::US),
            grpc_api_types::payments::CountryAlpha2::Af => Ok(Self::AF),
            grpc_api_types::payments::CountryAlpha2::Ax => Ok(Self::AX),
            grpc_api_types::payments::CountryAlpha2::Al => Ok(Self::AL),
            grpc_api_types::payments::CountryAlpha2::Dz => Ok(Self::DZ),
            grpc_api_types::payments::CountryAlpha2::As => Ok(Self::AS),
            grpc_api_types::payments::CountryAlpha2::Ad => Ok(Self::AD),
            grpc_api_types::payments::CountryAlpha2::Ao => Ok(Self::AO),
            grpc_api_types::payments::CountryAlpha2::Ai => Ok(Self::AI),
            grpc_api_types::payments::CountryAlpha2::Aq => Ok(Self::AQ),
            grpc_api_types::payments::CountryAlpha2::Ag => Ok(Self::AG),
            grpc_api_types::payments::CountryAlpha2::Ar => Ok(Self::AR),
            grpc_api_types::payments::CountryAlpha2::Am => Ok(Self::AM),
            grpc_api_types::payments::CountryAlpha2::Aw => Ok(Self::AW),
            grpc_api_types::payments::CountryAlpha2::Au => Ok(Self::AU),
            grpc_api_types::payments::CountryAlpha2::At => Ok(Self::AT),
            grpc_api_types::payments::CountryAlpha2::Az => Ok(Self::AZ),
            grpc_api_types::payments::CountryAlpha2::Bs => Ok(Self::BS),
            grpc_api_types::payments::CountryAlpha2::Bh => Ok(Self::BH),
            grpc_api_types::payments::CountryAlpha2::Bd => Ok(Self::BD),
            grpc_api_types::payments::CountryAlpha2::Bb => Ok(Self::BB),
            grpc_api_types::payments::CountryAlpha2::By => Ok(Self::BY),
            grpc_api_types::payments::CountryAlpha2::Be => Ok(Self::BE),
            grpc_api_types::payments::CountryAlpha2::Bz => Ok(Self::BZ),
            grpc_api_types::payments::CountryAlpha2::Bj => Ok(Self::BJ),
            grpc_api_types::payments::CountryAlpha2::Bm => Ok(Self::BM),
            grpc_api_types::payments::CountryAlpha2::Bt => Ok(Self::BT),
            grpc_api_types::payments::CountryAlpha2::Bo => Ok(Self::BO),
            grpc_api_types::payments::CountryAlpha2::Bq => Ok(Self::BQ),
            grpc_api_types::payments::CountryAlpha2::Ba => Ok(Self::BA),
            grpc_api_types::payments::CountryAlpha2::Bw => Ok(Self::BW),
            grpc_api_types::payments::CountryAlpha2::Bv => Ok(Self::BV),
            grpc_api_types::payments::CountryAlpha2::Br => Ok(Self::BR),
            grpc_api_types::payments::CountryAlpha2::Io => Ok(Self::IO),
            grpc_api_types::payments::CountryAlpha2::Bn => Ok(Self::BN),
            grpc_api_types::payments::CountryAlpha2::Bg => Ok(Self::BG),
            grpc_api_types::payments::CountryAlpha2::Bf => Ok(Self::BF),
            grpc_api_types::payments::CountryAlpha2::Bi => Ok(Self::BI),
            grpc_api_types::payments::CountryAlpha2::Kh => Ok(Self::KH),
            grpc_api_types::payments::CountryAlpha2::Cm => Ok(Self::CM),
            grpc_api_types::payments::CountryAlpha2::Ca => Ok(Self::CA),
            grpc_api_types::payments::CountryAlpha2::Cv => Ok(Self::CV),
            grpc_api_types::payments::CountryAlpha2::Ky => Ok(Self::KY),
            grpc_api_types::payments::CountryAlpha2::Cf => Ok(Self::CF),
            grpc_api_types::payments::CountryAlpha2::Td => Ok(Self::TD),
            grpc_api_types::payments::CountryAlpha2::Cl => Ok(Self::CL),
            grpc_api_types::payments::CountryAlpha2::Cn => Ok(Self::CN),
            grpc_api_types::payments::CountryAlpha2::Cx => Ok(Self::CX),
            grpc_api_types::payments::CountryAlpha2::Cc => Ok(Self::CC),
            grpc_api_types::payments::CountryAlpha2::Co => Ok(Self::CO),
            grpc_api_types::payments::CountryAlpha2::Km => Ok(Self::KM),
            grpc_api_types::payments::CountryAlpha2::Cg => Ok(Self::CG),
            grpc_api_types::payments::CountryAlpha2::Cd => Ok(Self::CD),
            grpc_api_types::payments::CountryAlpha2::Ck => Ok(Self::CK),
            grpc_api_types::payments::CountryAlpha2::Cr => Ok(Self::CR),
            grpc_api_types::payments::CountryAlpha2::Ci => Ok(Self::CI),
            grpc_api_types::payments::CountryAlpha2::Hr => Ok(Self::HR),
            grpc_api_types::payments::CountryAlpha2::Cu => Ok(Self::CU),
            grpc_api_types::payments::CountryAlpha2::Cw => Ok(Self::CW),
            grpc_api_types::payments::CountryAlpha2::Cy => Ok(Self::CY),
            grpc_api_types::payments::CountryAlpha2::Cz => Ok(Self::CZ),
            grpc_api_types::payments::CountryAlpha2::Dk => Ok(Self::DK),
            grpc_api_types::payments::CountryAlpha2::Dj => Ok(Self::DJ),
            grpc_api_types::payments::CountryAlpha2::Dm => Ok(Self::DM),
            grpc_api_types::payments::CountryAlpha2::Do => Ok(Self::DO),
            grpc_api_types::payments::CountryAlpha2::Ec => Ok(Self::EC),
            grpc_api_types::payments::CountryAlpha2::Eg => Ok(Self::EG),
            grpc_api_types::payments::CountryAlpha2::Sv => Ok(Self::SV),
            grpc_api_types::payments::CountryAlpha2::Gq => Ok(Self::GQ),
            grpc_api_types::payments::CountryAlpha2::Er => Ok(Self::ER),
            grpc_api_types::payments::CountryAlpha2::Ee => Ok(Self::EE),
            grpc_api_types::payments::CountryAlpha2::Et => Ok(Self::ET),
            grpc_api_types::payments::CountryAlpha2::Fk => Ok(Self::FK),
            grpc_api_types::payments::CountryAlpha2::Fo => Ok(Self::FO),
            grpc_api_types::payments::CountryAlpha2::Fj => Ok(Self::FJ),
            grpc_api_types::payments::CountryAlpha2::Fi => Ok(Self::FI),
            grpc_api_types::payments::CountryAlpha2::Fr => Ok(Self::FR),
            grpc_api_types::payments::CountryAlpha2::Gf => Ok(Self::GF),
            grpc_api_types::payments::CountryAlpha2::Pf => Ok(Self::PF),
            grpc_api_types::payments::CountryAlpha2::Tf => Ok(Self::TF),
            grpc_api_types::payments::CountryAlpha2::Ga => Ok(Self::GA),
            grpc_api_types::payments::CountryAlpha2::Gm => Ok(Self::GM),
            grpc_api_types::payments::CountryAlpha2::Ge => Ok(Self::GE),
            grpc_api_types::payments::CountryAlpha2::De => Ok(Self::DE),
            grpc_api_types::payments::CountryAlpha2::Gh => Ok(Self::GH),
            grpc_api_types::payments::CountryAlpha2::Gi => Ok(Self::GI),
            grpc_api_types::payments::CountryAlpha2::Gr => Ok(Self::GR),
            grpc_api_types::payments::CountryAlpha2::Gl => Ok(Self::GL),
            grpc_api_types::payments::CountryAlpha2::Gd => Ok(Self::GD),
            grpc_api_types::payments::CountryAlpha2::Gp => Ok(Self::GP),
            grpc_api_types::payments::CountryAlpha2::Gu => Ok(Self::GU),
            grpc_api_types::payments::CountryAlpha2::Gt => Ok(Self::GT),
            grpc_api_types::payments::CountryAlpha2::Gg => Ok(Self::GG),
            grpc_api_types::payments::CountryAlpha2::Gn => Ok(Self::GN),
            grpc_api_types::payments::CountryAlpha2::Gw => Ok(Self::GW),
            grpc_api_types::payments::CountryAlpha2::Gy => Ok(Self::GY),
            grpc_api_types::payments::CountryAlpha2::Ht => Ok(Self::HT),
            grpc_api_types::payments::CountryAlpha2::Hm => Ok(Self::HM),
            grpc_api_types::payments::CountryAlpha2::Va => Ok(Self::VA),
            grpc_api_types::payments::CountryAlpha2::Hn => Ok(Self::HN),
            grpc_api_types::payments::CountryAlpha2::Hk => Ok(Self::HK),
            grpc_api_types::payments::CountryAlpha2::Hu => Ok(Self::HU),
            grpc_api_types::payments::CountryAlpha2::Is => Ok(Self::IS),
            grpc_api_types::payments::CountryAlpha2::In => Ok(Self::IN),
            grpc_api_types::payments::CountryAlpha2::Id => Ok(Self::ID),
            grpc_api_types::payments::CountryAlpha2::Ir => Ok(Self::IR),
            grpc_api_types::payments::CountryAlpha2::Iq => Ok(Self::IQ),
            grpc_api_types::payments::CountryAlpha2::Ie => Ok(Self::IE),
            grpc_api_types::payments::CountryAlpha2::Im => Ok(Self::IM),
            grpc_api_types::payments::CountryAlpha2::Il => Ok(Self::IL),
            grpc_api_types::payments::CountryAlpha2::It => Ok(Self::IT),
            grpc_api_types::payments::CountryAlpha2::Jm => Ok(Self::JM),
            grpc_api_types::payments::CountryAlpha2::Jp => Ok(Self::JP),
            grpc_api_types::payments::CountryAlpha2::Je => Ok(Self::JE),
            grpc_api_types::payments::CountryAlpha2::Jo => Ok(Self::JO),
            grpc_api_types::payments::CountryAlpha2::Kz => Ok(Self::KZ),
            grpc_api_types::payments::CountryAlpha2::Ke => Ok(Self::KE),
            grpc_api_types::payments::CountryAlpha2::Ki => Ok(Self::KI),
            grpc_api_types::payments::CountryAlpha2::Kp => Ok(Self::KP),
            grpc_api_types::payments::CountryAlpha2::Kr => Ok(Self::KR),
            grpc_api_types::payments::CountryAlpha2::Kw => Ok(Self::KW),
            grpc_api_types::payments::CountryAlpha2::Kg => Ok(Self::KG),
            grpc_api_types::payments::CountryAlpha2::La => Ok(Self::LA),
            grpc_api_types::payments::CountryAlpha2::Lv => Ok(Self::LV),
            grpc_api_types::payments::CountryAlpha2::Lb => Ok(Self::LB),
            grpc_api_types::payments::CountryAlpha2::Ls => Ok(Self::LS),
            grpc_api_types::payments::CountryAlpha2::Lr => Ok(Self::LR),
            grpc_api_types::payments::CountryAlpha2::Ly => Ok(Self::LY),
            grpc_api_types::payments::CountryAlpha2::Li => Ok(Self::LI),
            grpc_api_types::payments::CountryAlpha2::Lt => Ok(Self::LT),
            grpc_api_types::payments::CountryAlpha2::Lu => Ok(Self::LU),
            grpc_api_types::payments::CountryAlpha2::Mo => Ok(Self::MO),
            grpc_api_types::payments::CountryAlpha2::Mk => Ok(Self::MK),
            grpc_api_types::payments::CountryAlpha2::Mg => Ok(Self::MG),
            grpc_api_types::payments::CountryAlpha2::Mw => Ok(Self::MW),
            grpc_api_types::payments::CountryAlpha2::My => Ok(Self::MY),
            grpc_api_types::payments::CountryAlpha2::Mv => Ok(Self::MV),
            grpc_api_types::payments::CountryAlpha2::Ml => Ok(Self::ML),
            grpc_api_types::payments::CountryAlpha2::Mt => Ok(Self::MT),
            grpc_api_types::payments::CountryAlpha2::Mh => Ok(Self::MH),
            grpc_api_types::payments::CountryAlpha2::Mq => Ok(Self::MQ),
            grpc_api_types::payments::CountryAlpha2::Mr => Ok(Self::MR),
            grpc_api_types::payments::CountryAlpha2::Mu => Ok(Self::MU),
            grpc_api_types::payments::CountryAlpha2::Yt => Ok(Self::YT),
            grpc_api_types::payments::CountryAlpha2::Mx => Ok(Self::MX),
            grpc_api_types::payments::CountryAlpha2::Fm => Ok(Self::FM),
            grpc_api_types::payments::CountryAlpha2::Md => Ok(Self::MD),
            grpc_api_types::payments::CountryAlpha2::Mc => Ok(Self::MC),
            grpc_api_types::payments::CountryAlpha2::Mn => Ok(Self::MN),
            grpc_api_types::payments::CountryAlpha2::Me => Ok(Self::ME),
            grpc_api_types::payments::CountryAlpha2::Ms => Ok(Self::MS),
            grpc_api_types::payments::CountryAlpha2::Ma => Ok(Self::MA),
            grpc_api_types::payments::CountryAlpha2::Mz => Ok(Self::MZ),
            grpc_api_types::payments::CountryAlpha2::Mm => Ok(Self::MM),
            grpc_api_types::payments::CountryAlpha2::Na => Ok(Self::NA),
            grpc_api_types::payments::CountryAlpha2::Nr => Ok(Self::NR),
            grpc_api_types::payments::CountryAlpha2::Np => Ok(Self::NP),
            grpc_api_types::payments::CountryAlpha2::Nl => Ok(Self::NL),
            grpc_api_types::payments::CountryAlpha2::Nc => Ok(Self::NC),
            grpc_api_types::payments::CountryAlpha2::Nz => Ok(Self::NZ),
            grpc_api_types::payments::CountryAlpha2::Ni => Ok(Self::NI),
            grpc_api_types::payments::CountryAlpha2::Ne => Ok(Self::NE),
            grpc_api_types::payments::CountryAlpha2::Ng => Ok(Self::NG),
            grpc_api_types::payments::CountryAlpha2::Nu => Ok(Self::NU),
            grpc_api_types::payments::CountryAlpha2::Nf => Ok(Self::NF),
            grpc_api_types::payments::CountryAlpha2::Mp => Ok(Self::MP),
            grpc_api_types::payments::CountryAlpha2::No => Ok(Self::NO),
            grpc_api_types::payments::CountryAlpha2::Om => Ok(Self::OM),
            grpc_api_types::payments::CountryAlpha2::Pk => Ok(Self::PK),
            grpc_api_types::payments::CountryAlpha2::Pw => Ok(Self::PW),
            grpc_api_types::payments::CountryAlpha2::Ps => Ok(Self::PS),
            grpc_api_types::payments::CountryAlpha2::Pa => Ok(Self::PA),
            grpc_api_types::payments::CountryAlpha2::Pg => Ok(Self::PG),
            grpc_api_types::payments::CountryAlpha2::Py => Ok(Self::PY),
            grpc_api_types::payments::CountryAlpha2::Pe => Ok(Self::PE),
            grpc_api_types::payments::CountryAlpha2::Ph => Ok(Self::PH),
            grpc_api_types::payments::CountryAlpha2::Pn => Ok(Self::PN),
            grpc_api_types::payments::CountryAlpha2::Pl => Ok(Self::PL),
            grpc_api_types::payments::CountryAlpha2::Pt => Ok(Self::PT),
            grpc_api_types::payments::CountryAlpha2::Pr => Ok(Self::PR),
            grpc_api_types::payments::CountryAlpha2::Qa => Ok(Self::QA),
            grpc_api_types::payments::CountryAlpha2::Re => Ok(Self::RE),
            grpc_api_types::payments::CountryAlpha2::Ro => Ok(Self::RO),
            grpc_api_types::payments::CountryAlpha2::Ru => Ok(Self::RU),
            grpc_api_types::payments::CountryAlpha2::Rw => Ok(Self::RW),
            grpc_api_types::payments::CountryAlpha2::Bl => Ok(Self::BL),
            grpc_api_types::payments::CountryAlpha2::Sh => Ok(Self::SH),
            grpc_api_types::payments::CountryAlpha2::Kn => Ok(Self::KN),
            grpc_api_types::payments::CountryAlpha2::Lc => Ok(Self::LC),
            grpc_api_types::payments::CountryAlpha2::Mf => Ok(Self::MF),
            grpc_api_types::payments::CountryAlpha2::Pm => Ok(Self::PM),
            grpc_api_types::payments::CountryAlpha2::Vc => Ok(Self::VC),
            grpc_api_types::payments::CountryAlpha2::Ws => Ok(Self::WS),
            grpc_api_types::payments::CountryAlpha2::Sm => Ok(Self::SM),
            grpc_api_types::payments::CountryAlpha2::St => Ok(Self::ST),
            grpc_api_types::payments::CountryAlpha2::Sa => Ok(Self::SA),
            grpc_api_types::payments::CountryAlpha2::Sn => Ok(Self::SN),
            grpc_api_types::payments::CountryAlpha2::Rs => Ok(Self::RS),
            grpc_api_types::payments::CountryAlpha2::Sc => Ok(Self::SC),
            grpc_api_types::payments::CountryAlpha2::Sl => Ok(Self::SL),
            grpc_api_types::payments::CountryAlpha2::Sg => Ok(Self::SG),
            grpc_api_types::payments::CountryAlpha2::Sx => Ok(Self::SX),
            grpc_api_types::payments::CountryAlpha2::Sk => Ok(Self::SK),
            grpc_api_types::payments::CountryAlpha2::Si => Ok(Self::SI),
            grpc_api_types::payments::CountryAlpha2::Sb => Ok(Self::SB),
            grpc_api_types::payments::CountryAlpha2::So => Ok(Self::SO),
            grpc_api_types::payments::CountryAlpha2::Za => Ok(Self::ZA),
            grpc_api_types::payments::CountryAlpha2::Gs => Ok(Self::GS),
            grpc_api_types::payments::CountryAlpha2::Ss => Ok(Self::SS),
            grpc_api_types::payments::CountryAlpha2::Es => Ok(Self::ES),
            grpc_api_types::payments::CountryAlpha2::Lk => Ok(Self::LK),
            grpc_api_types::payments::CountryAlpha2::Sd => Ok(Self::SD),
            grpc_api_types::payments::CountryAlpha2::Sr => Ok(Self::SR),
            grpc_api_types::payments::CountryAlpha2::Sj => Ok(Self::SJ),
            grpc_api_types::payments::CountryAlpha2::Sz => Ok(Self::SZ),
            grpc_api_types::payments::CountryAlpha2::Se => Ok(Self::SE),
            grpc_api_types::payments::CountryAlpha2::Ch => Ok(Self::CH),
            grpc_api_types::payments::CountryAlpha2::Sy => Ok(Self::SY),
            grpc_api_types::payments::CountryAlpha2::Tw => Ok(Self::TW),
            grpc_api_types::payments::CountryAlpha2::Tj => Ok(Self::TJ),
            grpc_api_types::payments::CountryAlpha2::Tz => Ok(Self::TZ),
            grpc_api_types::payments::CountryAlpha2::Th => Ok(Self::TH),
            grpc_api_types::payments::CountryAlpha2::Tl => Ok(Self::TL),
            grpc_api_types::payments::CountryAlpha2::Tg => Ok(Self::TG),
            grpc_api_types::payments::CountryAlpha2::Tk => Ok(Self::TK),
            grpc_api_types::payments::CountryAlpha2::To => Ok(Self::TO),
            grpc_api_types::payments::CountryAlpha2::Tt => Ok(Self::TT),
            grpc_api_types::payments::CountryAlpha2::Tn => Ok(Self::TN),
            grpc_api_types::payments::CountryAlpha2::Tr => Ok(Self::TR),
            grpc_api_types::payments::CountryAlpha2::Tm => Ok(Self::TM),
            grpc_api_types::payments::CountryAlpha2::Tc => Ok(Self::TC),
            grpc_api_types::payments::CountryAlpha2::Tv => Ok(Self::TV),
            grpc_api_types::payments::CountryAlpha2::Ug => Ok(Self::UG),
            grpc_api_types::payments::CountryAlpha2::Ua => Ok(Self::UA),
            grpc_api_types::payments::CountryAlpha2::Ae => Ok(Self::AE),
            grpc_api_types::payments::CountryAlpha2::Gb => Ok(Self::GB),
            grpc_api_types::payments::CountryAlpha2::Um => Ok(Self::UM),
            grpc_api_types::payments::CountryAlpha2::Uy => Ok(Self::UY),
            grpc_api_types::payments::CountryAlpha2::Uz => Ok(Self::UZ),
            grpc_api_types::payments::CountryAlpha2::Vu => Ok(Self::VU),
            grpc_api_types::payments::CountryAlpha2::Ve => Ok(Self::VE),
            grpc_api_types::payments::CountryAlpha2::Vn => Ok(Self::VN),
            grpc_api_types::payments::CountryAlpha2::Vg => Ok(Self::VG),
            grpc_api_types::payments::CountryAlpha2::Vi => Ok(Self::VI),
            grpc_api_types::payments::CountryAlpha2::Wf => Ok(Self::WF),
            grpc_api_types::payments::CountryAlpha2::Eh => Ok(Self::EH),
            grpc_api_types::payments::CountryAlpha2::Ye => Ok(Self::YE),
            grpc_api_types::payments::CountryAlpha2::Zm => Ok(Self::ZM),
            grpc_api_types::payments::CountryAlpha2::Zw => Ok(Self::ZW),
            grpc_api_types::payments::CountryAlpha2::Unspecified => Ok(Self::US), // Default to US if unspecified
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::Address> for AddressDetails {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::Address,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let country_code = value.country_alpha2_code();
        let country = if matches!(
            country_code,
            grpc_api_types::payments::CountryAlpha2::Unspecified
        ) {
            None
        } else {
            Some(CountryAlpha2::foreign_try_from(country_code)?)
        };

        Ok(Self {
            country,
            city: value.city,
            line1: value.line1,
            line2: value.line2,
            line3: value.line3,
            zip: value.zip_code,
            state: value.state,
            first_name: value.first_name,
            last_name: value.last_name,
            origin_zip: None,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::OrderDetailsWithAmount> for OrderDetailsWithAmount {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        item: grpc_api_types::payments::OrderDetailsWithAmount,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            product_name: item.product_name,
            quantity: u16::try_from(item.quantity).change_context(
                ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_QUANTITY".to_owned(),
                    error_identifier: 400,
                    error_message: "Quantity value is out of range for u16".to_owned(),
                    error_object: None,
                }),
            )?,
            amount: common_utils::types::MinorUnit::new(item.amount),
            tax_rate: item.tax_rate,
            total_tax_amount: item
                .total_tax_amount
                .map(common_utils::types::MinorUnit::new),
            requires_shipping: item.requires_shipping,
            product_img_link: item.product_img_link,
            product_id: item.product_id,
            category: item.category,
            sub_category: item.sub_category,
            brand: item.brand,
            description: item.description,
            unit_of_measure: item.unit_of_measure,
            product_type: item
                .product_type
                .and_then(|pt| grpc_api_types::payments::ProductType::try_from(pt).ok())
                .map(|grpc_product_type| {
                    common_enums::ProductType::foreign_from(grpc_product_type)
                }),
            product_tax_code: item.product_tax_code,
            commodity_code: None,
            sku: None,
            upc: None,
            unit_discount_amount: None,
            total_amount: None,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_payment_types::PaymentServiceCreateAccessTokenRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_payment_types::PaymentServiceCreateAccessTokenRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // For access token creation operations, address information is typically not available or required
        let address: PaymentAddress = PaymentAddress::new(
            None,        // shipping
            None,        // billing
            None,        // payment_method_billing
            Some(false), // should_unify_address = false for access token operations
        );

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        // Extract connector_meta_data from merchant_account_metadata
        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card, // Default for access token operations
            address,
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ), // No request_ref_id available for access token requests
            customer_id: None,
            connector_customer: None,
            description: None,
            return_url: None,
            connector_meta_data,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token: None,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

// PhoneDetails conversion removed - phone info is now embedded in Address

impl ForeignTryFrom<(PaymentServiceAuthorizeRequest, Connectors, &MaskedMetadata)>
    for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            PaymentServiceAuthorizeRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let address = match &value.address {
            // Borrow value.address
            Some(address_value) => {
                // address_value is &grpc_api_types::payments::PaymentAddress
                PaymentAddress::foreign_try_from(
                    (*address_value).clone(), // Clone the grpc_api_types::payments::PaymentAddress
                )?
            }
            None => {
                return Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_ADDRESS".to_owned(),
                    error_identifier: 400,
                    error_message: "Address is required".to_owned(),
                    error_object: None,
                }))?
            }
        };

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        // Extract specific headers for vault and other integrations
        let vault_headers = extract_headers_from_metadata(metadata);

        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;

        let order_details = (!value.order_details.is_empty())
            .then(|| {
                value
                    .order_details
                    .into_iter()
                    .map(OrderDetailsWithAmount::foreign_try_from)
                    .collect::<Result<Vec<_>, _>>()
            })
            .transpose()?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::foreign_try_from(
                value.payment_method.unwrap_or_default(),
            )?, // Use direct enum
            address,
            auth_type: common_enums::AuthenticationType::foreign_try_from(
                grpc_api_types::payments::AuthenticationType::try_from(value.auth_type)
                    .unwrap_or_default(),
            )?, // Use direct enum
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: value
                .customer_id
                .clone()
                .map(|customer_id| CustomerId::try_from(Cow::from(customer_id)))
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_CUSTOMER_ID".to_owned(),
                    error_identifier: 400,
                    error_message: "Failed to parse Customer Id".to_owned(),
                    error_object: None,
                }))?,
            connector_customer: value.connector_customer_id,
            description: value.description,
            return_url: value.return_url.clone(),
            connector_meta_data,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token: None,
            session_token: None,
            reference_id: value.connector_order_reference_id.clone(),
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            connector_response: None,
            vault_headers,
            recurring_mandate_payment_data: None,
            order_details,

            minor_amount_authorized: None,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceAuthorizeOnlyRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceAuthorizeOnlyRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let address = match &value.address {
            // Borrow value.address
            Some(address_value) => {
                // address_value is &grpc_api_types::payments::PaymentAddress
                PaymentAddress::foreign_try_from(
                    (*address_value).clone(), // Clone the grpc_api_types::payments::PaymentAddress
                )?
            }
            None => {
                return Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_ADDRESS".to_owned(),
                    error_identifier: 400,
                    error_message: "Address is required".to_owned(),
                    error_object: None,
                }))?
            }
        };

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        // Extract specific headers for vault and other integrations
        let vault_headers = extract_headers_from_metadata(metadata);

        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;

        let order_details = (!value.order_details.is_empty())
            .then(|| {
                value
                    .order_details
                    .into_iter()
                    .map(OrderDetailsWithAmount::foreign_try_from)
                    .collect::<Result<Vec<_>, _>>()
            })
            .transpose()?;
        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);
        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::foreign_try_from(
                value.payment_method.unwrap_or_default(),
            )?, // Use direct enum
            address,
            auth_type: common_enums::AuthenticationType::foreign_try_from(
                grpc_api_types::payments::AuthenticationType::try_from(value.auth_type)
                    .unwrap_or_default(),
            )?, // Use direct enum
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: value
                .customer_id
                .clone()
                .map(|customer_id| CustomerId::try_from(Cow::from(customer_id)))
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_CUSTOMER_ID".to_owned(),
                    error_identifier: 400,
                    error_message: "Failed to parse Customer Id".to_owned(),
                    error_object: None,
                }))?,
            connector_customer: value.connector_customer_id,
            description: value.description,
            return_url: value.return_url.clone(),
            connector_meta_data,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token,
            session_token: value.session_token,
            reference_id: value.connector_order_reference_id.clone(),
            payment_method_token: value
                .payment_method_token
                .map(|pmt| router_data::PaymentMethodToken::Token(Secret::new(pmt))),
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            connector_response: None,
            vault_headers,
            recurring_mandate_payment_data: None,
            order_details,

            minor_amount_authorized: None,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceRepeatEverythingRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceRepeatEverythingRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let address = match &value.address {
            // Borrow value.address
            Some(address_value) => {
                // address_value is &grpc_api_types::payments::PaymentAddress
                PaymentAddress::foreign_try_from(
                    (*address_value).clone(), // Clone the grpc_api_types::payments::PaymentAddress
                )?
            }
            None => {
                // For repeat payment operations, address information is typically not available or required
                PaymentAddress::new(
                    None,        // shipping
                    None,        // billing
                    None,        // payment_method_billing
                    Some(false), // should_unify_address = false for repeat operations
                )
            }
        };

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        // Extract access_token from state field
        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card, //TODO
            address,
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: value.connector_customer_id,
            description: value.description,
            return_url: None,
            connector_meta_data: value
                .merchant_account_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
                .transpose()?,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            connector_response: None,
            vault_headers: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceGetRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceGetRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // For sync operations, address information is typically not available or required
        let address: PaymentAddress = PaymentAddress::new(
            None,        // shipping
            None,        // billing
            None,        // payment_method_billing
            Some(false), // should_unify_address = false for sync operations
        );

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card, //TODO
            address,
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description: None,
            return_url: None,
            connector_meta_data: value
                .merchant_account_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
                .transpose()?,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token,
            session_token: None,
            reference_id: value.connector_order_reference_id.clone(),
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl ForeignTryFrom<(PaymentServiceVoidRequest, Connectors, &MaskedMetadata)> for PaymentFlowData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (PaymentServiceVoidRequest, Connectors, &MaskedMetadata),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // For void operations, address information is typically not available or required
        // Since this is a PaymentServiceVoidRequest, we use default address values
        let address: PaymentAddress = PaymentAddress::new(
            None,        // shipping
            None,        // billing
            None,        // payment_method_billing
            Some(false), // should_unify_address = false for void operations
        );

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;
        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);
        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card, //TODO
            address,
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description: None,
            return_url: None,
            connector_meta_data,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl ForeignTryFrom<ResponseId> for grpc_api_types::payments::Identifier {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(value: ResponseId) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(match value {
            ResponseId::ConnectorTransactionId(id) => Self {
                id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
            },
            ResponseId::EncodedData(data) => Self {
                id_type: Some(grpc_api_types::payments::identifier::IdType::EncodedData(
                    data,
                )),
            },
            ResponseId::NoResponseId => Self {
                id_type: Some(grpc_api_types::payments::identifier::IdType::NoResponseIdMarker(())),
            },
        })
    }
}

impl ForeignTryFrom<router_request_types::AuthenticationData>
    for grpc_api_types::payments::AuthenticationData
{
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: router_request_types::AuthenticationData,
    ) -> error_stack::Result<Self, Self::Error> {
        use hyperswitch_masking::ExposeInterface;
        let trans_status = value
            .trans_status
            .map(|ts| grpc_api_types::payments::TransactionStatus::foreign_from(ts).into());
        let exemption_indicator = value
            .exemption_indicator
            .map(|ei| grpc_api_types::payments::ExemptionIndicator::foreign_from(ei).into());
        Ok(Self {
            ucaf_collection_indicator: value.ucaf_collection_indicator,
            eci: value.eci,
            cavv: value.cavv.map(|cavv| cavv.expose()),
            threeds_server_transaction_id: value.threeds_server_transaction_id.map(|id| {
                grpc_api_types::payments::Identifier {
                    id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                }
            }),
            message_version: value.message_version.map(|v| v.to_string()),
            ds_transaction_id: value.ds_trans_id,
            trans_status,
            acs_transaction_id: value.acs_transaction_id,
            transaction_id: value.transaction_id,
            exemption_indicator,
            network_params: value
                .network_params
                .map(grpc_api_types::payments::NetworkParams::foreign_from),
        })
    }
}

impl ForeignFrom<common_enums::TransactionStatus> for grpc_api_types::payments::TransactionStatus {
    fn foreign_from(from: common_enums::TransactionStatus) -> Self {
        match from {
            common_enums::TransactionStatus::Success => Self::Success,
            common_enums::TransactionStatus::Failure => Self::Failure,
            common_enums::TransactionStatus::VerificationNotPerformed => {
                Self::VerificationNotPerformed
            }
            common_enums::TransactionStatus::NotVerified => Self::NotVerified,
            common_enums::TransactionStatus::Rejected => Self::Rejected,
            common_enums::TransactionStatus::ChallengeRequired => Self::ChallengeRequired,
            common_enums::TransactionStatus::ChallengeRequiredDecoupledAuthentication => {
                Self::ChallengeRequiredDecoupledAuthentication
            }
            common_enums::TransactionStatus::InformationOnly => Self::InformationOnly,
        }
    }
}

impl ForeignFrom<grpc_api_types::payments::TransactionStatus> for common_enums::TransactionStatus {
    fn foreign_from(value: grpc_api_types::payments::TransactionStatus) -> Self {
        match value {
            grpc_api_types::payments::TransactionStatus::Success => Self::Success,
            grpc_api_types::payments::TransactionStatus::Failure => Self::Failure,
            grpc_api_types::payments::TransactionStatus::VerificationNotPerformed => Self::VerificationNotPerformed,
            grpc_api_types::payments::TransactionStatus::NotVerified => Self::NotVerified,
            grpc_api_types::payments::TransactionStatus::Rejected => Self::Rejected,
            grpc_api_types::payments::TransactionStatus::ChallengeRequired => Self::ChallengeRequired,
            grpc_api_types::payments::TransactionStatus::ChallengeRequiredDecoupledAuthentication => Self::ChallengeRequiredDecoupledAuthentication,
            grpc_api_types::payments::TransactionStatus::InformationOnly => Self::InformationOnly,
        }
    }
}

impl ForeignFrom<common_enums::ExemptionIndicator>
    for grpc_api_types::payments::ExemptionIndicator
{
    fn foreign_from(value: common_enums::ExemptionIndicator) -> Self {
        match value {
            common_enums::ExemptionIndicator::LowValue => Self::LowValue,
            common_enums::ExemptionIndicator::TransactionRiskAssessment => {
                Self::TransactionRiskAssessment
            }
            common_enums::ExemptionIndicator::TrustedListing => Self::TrustedListing,
            common_enums::ExemptionIndicator::SecureCorporatePayment => {
                Self::SecureCorporatePayment
            }
            common_enums::ExemptionIndicator::ScaDelegation => Self::ScaDelegation,
            common_enums::ExemptionIndicator::ThreeDsOutage => Self::ThreeDsOutage,
            common_enums::ExemptionIndicator::OutOfScaScope => Self::OutOfScaScope,
            common_enums::ExemptionIndicator::Other => Self::Other,
            common_enums::ExemptionIndicator::LowRiskProgram => Self::LowRiskProgram,
            common_enums::ExemptionIndicator::RecurringOperation => Self::RecurringOperation,
        }
    }
}

impl ForeignFrom<grpc_api_types::payments::ExemptionIndicator>
    for common_enums::ExemptionIndicator
{
    fn foreign_from(value: grpc_api_types::payments::ExemptionIndicator) -> Self {
        match value {
            grpc_api_types::payments::ExemptionIndicator::LowValue => Self::LowValue,
            grpc_api_types::payments::ExemptionIndicator::TransactionRiskAssessment => {
                Self::TransactionRiskAssessment
            }
            grpc_api_types::payments::ExemptionIndicator::TrustedListing => Self::TrustedListing,
            grpc_api_types::payments::ExemptionIndicator::SecureCorporatePayment => {
                Self::SecureCorporatePayment
            }
            grpc_api_types::payments::ExemptionIndicator::ScaDelegation => Self::ScaDelegation,
            grpc_api_types::payments::ExemptionIndicator::ThreeDsOutage => Self::ThreeDsOutage,
            grpc_api_types::payments::ExemptionIndicator::OutOfScaScope => Self::OutOfScaScope,
            grpc_api_types::payments::ExemptionIndicator::Other => Self::Other,
            grpc_api_types::payments::ExemptionIndicator::LowRiskProgram => Self::LowRiskProgram,
            grpc_api_types::payments::ExemptionIndicator::RecurringOperation => {
                Self::RecurringOperation
            }
            grpc_api_types::payments::ExemptionIndicator::Unspecified => Self::Other,
        }
    }
}

impl ForeignFrom<common_enums::CavvAlgorithm> for grpc_api_types::payments::CavvAlgorithm {
    fn foreign_from(value: common_enums::CavvAlgorithm) -> Self {
        match value {
            common_enums::CavvAlgorithm::Zero => Self::Zero,
            common_enums::CavvAlgorithm::One => Self::One,
            common_enums::CavvAlgorithm::Two => Self::Two,
            common_enums::CavvAlgorithm::Three => Self::Three,
            common_enums::CavvAlgorithm::Four => Self::Four,
            common_enums::CavvAlgorithm::A => Self::A,
        }
    }
}

impl ForeignFrom<grpc_api_types::payments::CavvAlgorithm> for common_enums::CavvAlgorithm {
    fn foreign_from(value: grpc_api_types::payments::CavvAlgorithm) -> Self {
        match value {
            grpc_api_types::payments::CavvAlgorithm::Zero => Self::Zero,
            grpc_api_types::payments::CavvAlgorithm::One => Self::One,
            grpc_api_types::payments::CavvAlgorithm::Two => Self::Two,
            grpc_api_types::payments::CavvAlgorithm::Three => Self::Three,
            grpc_api_types::payments::CavvAlgorithm::Four => Self::Four,
            grpc_api_types::payments::CavvAlgorithm::A => Self::A,
            grpc_api_types::payments::CavvAlgorithm::Unspecified => Self::Zero,
        }
    }
}

impl ForeignTryFrom<ConnectorResponseData> for grpc_api_types::payments::ConnectorResponseData {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: ConnectorResponseData,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            additional_payment_method_data: value.additional_payment_method_data.as_ref().map(
                |additional_payment_method_connector_response| {
                    match additional_payment_method_connector_response {
                        AdditionalPaymentMethodConnectorResponse::Card {
                            authentication_data,
                            payment_checks,
                            card_network,
                            domestic_network,
                            auth_code,
                        } => grpc_api_types::payments::AdditionalPaymentMethodConnectorResponse {
                            payment_method_data: Some(
                                grpc_api_types::payments::additional_payment_method_connector_response::PaymentMethodData::Card(
                                    grpc_api_types::payments::CardConnectorResponse {
                                        authentication_data: authentication_data
                                            .as_ref()
                                            .and_then(|data| serde_json::to_vec(data).ok()),
                                        payment_checks: payment_checks
                                            .as_ref()
                                            .and_then(|checks| serde_json::to_vec(checks).ok()),
                                        card_network: card_network.clone(),
                                        domestic_network: domestic_network.clone(),
                                        auth_code: auth_code.clone(),
                                    }
                                )
                            ),
                        },
                        AdditionalPaymentMethodConnectorResponse::Upi { upi_mode } => {
                            grpc_api_types::payments::AdditionalPaymentMethodConnectorResponse {
                                payment_method_data: Some(
                                    grpc_api_types::payments::additional_payment_method_connector_response::PaymentMethodData::Upi(
                                        grpc_api_types::payments::UpiConnectorResponse {
                                            upi_mode: upi_mode.clone().map(|source| {
                                                let proto_source: grpc_api_types::payments::UpiSource = ForeignFrom::foreign_from(source);
                                                proto_source as i32
                                            }),
                                        }
                                    )
                                ),
                            }
                        }
                        AdditionalPaymentMethodConnectorResponse::GooglePay { auth_code } => {
                            grpc_api_types::payments::AdditionalPaymentMethodConnectorResponse {
                                payment_method_data: Some(
                                    grpc_api_types::payments::additional_payment_method_connector_response::PaymentMethodData::GooglePay(
                                        grpc_api_types::payments::GooglePayConnectorResponse {
                                            auth_code: auth_code.clone(),
                                        }
                                    )
                                ),
                            }
                        }
                        AdditionalPaymentMethodConnectorResponse::ApplePay { auth_code } => {
                            grpc_api_types::payments::AdditionalPaymentMethodConnectorResponse {
                                payment_method_data: Some(
                                    grpc_api_types::payments::additional_payment_method_connector_response::PaymentMethodData::ApplePay(
                                        grpc_api_types::payments::ApplePayConnectorResponse {
                                            auth_code: auth_code.clone(),
                                        }
                                    )
                                ),
                            }
                        }
                    }
                },
            ),
            extended_authorization_response_data: value
                .get_extended_authorization_response_data()
                .map(|extended_authorization_response_data| {
                    grpc_api_types::payments::ExtendedAuthorizationResponseData {
                        extended_authentication_applied: extended_authorization_response_data
                            .extended_authentication_applied,
                        extended_authorization_last_applied_at:
                            extended_authorization_response_data
                                .extended_authorization_last_applied_at
                                .map(|dt| dt.assume_utc().unix_timestamp()),
                        capture_before: extended_authorization_response_data
                            .capture_before
                            .map(|dt| dt.assume_utc().unix_timestamp()),
                    }
                }),
            is_overcapture_enabled: value.is_overcapture_enabled(),
        })
    }
}

pub fn generate_create_order_response(
    router_data_v2: RouterDataV2<
        CreateOrder,
        PaymentFlowData,
        PaymentCreateOrderData,
        PaymentCreateOrderResponse,
    >,
) -> Result<PaymentServiceAuthorizeResponse, error_stack::Report<ApplicationErrorResponse>> {
    let transaction_response = router_data_v2.response;
    let status = router_data_v2.resource_common_data.status;
    let grpc_status = grpc_api_types::payments::PaymentStatus::foreign_from(status);
    let raw_connector_response = router_data_v2
        .resource_common_data
        .get_raw_connector_response();
    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();
    let response = match transaction_response {
        Ok(response) => {
            // For successful order creation, return basic success response
            PaymentServiceAuthorizeResponse {
                transaction_id: Some(grpc_api_types::payments::Identifier {
                    id_type: Some(grpc_api_types::payments::identifier::IdType::Id(
                        response.order_id,
                    )),
                }),
                redirection_data: None,
                network_txn_id: None,
                response_ref_id: None,
                incremental_authorization_allowed: None,
                status: grpc_status as i32,
                error_message: None,
                error_code: None,
                error_reason: None,
                network_decline_code: None,
                network_advice_code: None,
                network_error_message: None,
                status_code: 200,
                raw_connector_response,
                raw_connector_request,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                connector_metadata: None,
                state: None,
                captured_amount: None,
                minor_captured_amount: None,
                minor_capturable_amount: None,
                minor_authorized_amount: None,
                mandate_reference: None,
                connector_response: None,
            }
        }
        Err(err) => {
            let status = match err.get_attempt_status_for_grpc(
                err.status_code,
                router_data_v2.resource_common_data.status,
            ) {
                Some(attempt_status) => {
                    grpc_api_types::payments::PaymentStatus::foreign_from(attempt_status)
                }
                None => grpc_api_types::payments::PaymentStatus::AttemptStatusUnspecified,
            };
            PaymentServiceAuthorizeResponse {
                transaction_id: err.connector_transaction_id.clone().map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                redirection_data: None,
                network_txn_id: None,
                response_ref_id: err.connector_transaction_id.map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                incremental_authorization_allowed: None,
                status: status as i32,
                error_message: Some(err.message),
                error_code: Some(err.code),
                error_reason: err.reason,
                network_decline_code: err.network_decline_code,
                network_advice_code: err.network_advice_code,
                network_error_message: err.network_error_message,
                status_code: err.status_code as u32,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                connector_metadata: None,
                raw_connector_response,
                raw_connector_request,
                state: None,
                captured_amount: None,
                minor_captured_amount: None,
                minor_capturable_amount: None,
                minor_authorized_amount: None,
                mandate_reference: None,
                connector_response: None,
            }
        }
    };
    Ok(response)
}

/// Helper function to convert connector_metadata from serde_json::Value to Option<Secret<String>>
/// Serializes the JSON value to a string for transmission via gRPC
fn convert_connector_metadata_to_secret_string(
    connector_metadata: Option<serde_json::Value>,
) -> Option<Secret<String>> {
    connector_metadata.and_then(|value| serde_json::to_string(&value).ok().map(Secret::new))
}

pub fn generate_payment_authorize_response<T: PaymentMethodDataTypes>(
    router_data_v2: RouterDataV2<
        Authorize,
        PaymentFlowData,
        PaymentsAuthorizeData<T>,
        PaymentsResponseData,
    >,
) -> Result<PaymentServiceAuthorizeResponse, error_stack::Report<ApplicationErrorResponse>> {
    let transaction_response = router_data_v2.response;
    let status = router_data_v2.resource_common_data.status;
    info!("Payment authorize response status: {:?}", status);
    let response_headers = router_data_v2
        .resource_common_data
        .get_connector_response_headers_as_map();
    let grpc_status = grpc_api_types::payments::PaymentStatus::foreign_from(status);
    let raw_connector_response = router_data_v2
        .resource_common_data
        .get_raw_connector_response();
    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    // Create state if either access token or connector customer is available
    let state = if router_data_v2.resource_common_data.access_token.is_some()
        || router_data_v2
            .resource_common_data
            .connector_customer
            .is_some()
    {
        Some(ConnectorState {
            access_token: router_data_v2
                .resource_common_data
                .access_token
                .as_ref()
                .map(|token_data| grpc_api_types::payments::AccessToken {
                    token: token_data.access_token.clone(),
                    expires_in_seconds: token_data.expires_in,
                    token_type: token_data.token_type.clone(),
                }),
            connector_customer_id: router_data_v2
                .resource_common_data
                .connector_customer
                .clone(),
        })
    } else {
        None
    };

    let connector_response = router_data_v2
        .resource_common_data
        .connector_response
        .as_ref()
        .map(|connector_response_data| {
            grpc_api_types::payments::ConnectorResponseData::foreign_try_from(
                connector_response_data.clone(),
            )
        })
        .transpose()?;

    let response = match transaction_response {
        Ok(response) => match response {
            PaymentsResponseData::TransactionResponse {
                resource_id,
                redirection_data,
                connector_metadata,
                network_txn_id,
                connector_response_reference_id,
                incremental_authorization_allowed,
                mandate_reference,
                status_code,
            } => {
                let mandate_reference_grpc =
                    mandate_reference.map(|m| grpc_api_types::payments::MandateReference {
                        mandate_id: m.connector_mandate_id,
                        payment_method_id: m.payment_method_id,
                        connector_mandate_request_reference_id: m
                            .connector_mandate_request_reference_id,
                    });

                PaymentServiceAuthorizeResponse {
                    transaction_id: Some(grpc_api_types::payments::Identifier::foreign_try_from(
                        resource_id,
                    )?),
                    redirection_data: redirection_data
                        .map(|form| grpc_api_types::payments::RedirectForm::foreign_try_from(*form))
                        .transpose()?,
                    connector_metadata: convert_connector_metadata_to_secret_string(
                        connector_metadata,
                    ),
                    network_txn_id,
                    response_ref_id: connector_response_reference_id.map(|id| {
                        grpc_api_types::payments::Identifier {
                            id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                        }
                    }),
                    mandate_reference: mandate_reference_grpc,
                    incremental_authorization_allowed,
                    status: grpc_status as i32,
                    error_message: None,
                    error_code: None,
                    error_reason: None,
                    network_decline_code: None,
                    network_advice_code: None,
                    network_error_message: None,
                    raw_connector_response,
                    raw_connector_request,
                    status_code: status_code as u32,
                    response_headers,
                    state,
                    captured_amount: router_data_v2.resource_common_data.amount_captured,
                    minor_captured_amount: router_data_v2
                        .resource_common_data
                        .minor_amount_captured
                        .map(|amount_captured| amount_captured.get_amount_as_i64()),
                    minor_capturable_amount: router_data_v2
                        .resource_common_data
                        .minor_amount_capturable
                        .map(|amount_capturable| amount_capturable.get_amount_as_i64()),
                    minor_authorized_amount: router_data_v2
                        .resource_common_data
                        .minor_amount_authorized
                        .map(|amount_authorized| amount_authorized.get_amount_as_i64()),
                    connector_response,
                }
            }
            _ => Err(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_RESPONSE".to_owned(),
                error_identifier: 400,
                error_message: "Invalid response from connector".to_owned(),
                error_object: None,
            }))?,
        },
        Err(err) => {
            let status = match err.get_attempt_status_for_grpc(
                err.status_code,
                router_data_v2.resource_common_data.status,
            ) {
                Some(attempt_status) => {
                    grpc_api_types::payments::PaymentStatus::foreign_from(attempt_status)
                }
                None => grpc_api_types::payments::PaymentStatus::AttemptStatusUnspecified,
            };

            PaymentServiceAuthorizeResponse {
                transaction_id: err.connector_transaction_id.clone().map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                redirection_data: None,
                network_txn_id: None,
                response_ref_id: err.connector_transaction_id.map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                mandate_reference: None,
                incremental_authorization_allowed: None,
                status: status as i32,
                error_message: Some(err.message),
                error_code: Some(err.code),
                error_reason: err.reason,
                network_decline_code: err.network_decline_code,
                network_advice_code: err.network_advice_code,
                network_error_message: err.network_error_message,
                status_code: err.status_code as u32,
                response_headers,
                raw_connector_response,
                raw_connector_request,
                connector_metadata: None,
                state,
                captured_amount: None,
                minor_captured_amount: None,
                minor_capturable_amount: None,
                minor_authorized_amount: None,
                connector_response,
            }
        }
    };
    Ok(response)
}

// ForeignTryFrom for PaymentMethod gRPC enum to internal enum
impl ForeignTryFrom<grpc_api_types::payments::PaymentMethod> for PaymentMethod {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        item: grpc_api_types::payments::PaymentMethod,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match item {
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::Card(_)),
            } => Ok(Self::Card),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::CardProxy(_)),
            } => Ok(Self::Card),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::CardRedirect(_)),
            } => Ok(Self::Card),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::Token(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::UpiCollect(_)),
            } => Ok(Self::Upi),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::UpiIntent(_)),
            } => Ok(Self::Upi),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::UpiQr(_)),
            } => Ok(Self::Upi),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::ClassicReward(_)),
            } => Ok(Self::Reward),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::EVoucher(_)),
            } => Ok(Self::Reward),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::ApplePay(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::GooglePay(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::ApplePayThirdPartySdk(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::GooglePayThirdPartySdk(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::PaypalSdk(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::AmazonPayRedirect(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::PaypalRedirect(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::RevolutPay(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::Mifinity(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::Bluecode(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::CashappQr(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::WeChatPayQr(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::AliPayRedirect(_)),
            } => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::InstantBankTransfer(_)),
            } => Ok(Self::BankTransfer),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::SepaBankTransfer(_)),
            } => Ok(Self::BankTransfer),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::InstantBankTransferPoland(_)),
            } => Ok(Self::BankTransfer),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::InstantBankTransferFinland(_)),
            } => Ok(Self::BankTransfer),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::Ideal(_)),
            } => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::Eps(_)),
            } => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::Blik(_)),
            } => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethod {
                payment_method:
                    Some(grpc_api_types::payments::payment_method::PaymentMethod::Sofort(_)),
            } => Ok(Self::BankRedirect),
            _ => Ok(Self::Card), // Default fallback
        }
    }
}

// ForeignTryFrom for AuthenticationType gRPC enum to internal enum
impl ForeignTryFrom<grpc_api_types::payments::AuthenticationType>
    for common_enums::AuthenticationType
{
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        item: grpc_api_types::payments::AuthenticationType,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match item {
            grpc_api_types::payments::AuthenticationType::Unspecified => Ok(Self::NoThreeDs), // Default to NoThreeDs for unspecified
            grpc_api_types::payments::AuthenticationType::ThreeDs => Ok(Self::ThreeDs),
            grpc_api_types::payments::AuthenticationType::NoThreeDs => Ok(Self::NoThreeDs),
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentServiceGetRequest> for PaymentsSyncData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceGetRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let capture_method = Some(CaptureMethod::foreign_try_from(value.capture_method())?);
        let currency = common_enums::Currency::foreign_try_from(value.currency())?;
        let amount = common_utils::types::MinorUnit::new(value.amount);
        // Create ResponseId from resource_id
        let connector_transaction_id = ResponseId::ConnectorTransactionId(
            value
                .transaction_id
                .clone()
                .and_then(|id| id.id_type)
                .and_then(|id_type| match id_type {
                    grpc_api_types::payments::identifier::IdType::Id(id) => Some(id),
                    _ => None,
                })
                .unwrap_or_default(),
        );

        let setup_future_usage = match value.setup_future_usage() {
            grpc_payment_types::FutureUsage::Unspecified => None,
            _ => Some(FutureUsage::foreign_try_from(value.setup_future_usage())?),
        };

        let sync_type = match value.sync_type() {
            grpc_payment_types::SyncRequestType::MultipleCaptureSync => {
                router_request_types::SyncRequestType::MultipleCaptureSync
            }
            grpc_payment_types::SyncRequestType::SinglePaymentSync
            | grpc_payment_types::SyncRequestType::Unspecified => {
                router_request_types::SyncRequestType::SinglePaymentSync
            }
        };

        let payment_experience = match value.payment_experience() {
            grpc_payment_types::PaymentExperience::Unspecified => None,
            _ => Some(common_enums::PaymentExperience::foreign_try_from(
                value.payment_experience(),
            )?),
        };

        let connector_metadata = value
            .connector_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "connector metadata")))
            .transpose()?;

        Ok(Self {
            connector_transaction_id,
            encoded_data: value.encoded_data,
            capture_method,
            connector_metadata,
            sync_type,
            mandate_id: None,
            payment_method_type: None,
            currency,
            payment_experience,
            amount,
            integrity_object: None,
            all_keys_required: None, // Field not available in new proto structure
            split_payments: None,
            setup_future_usage,
        })
    }
}

impl ForeignFrom<common_enums::AttemptStatus> for grpc_api_types::payments::PaymentStatus {
    fn foreign_from(status: common_enums::AttemptStatus) -> Self {
        match status {
            common_enums::AttemptStatus::Charged => Self::Charged,
            common_enums::AttemptStatus::Pending => Self::Pending,
            common_enums::AttemptStatus::Failure => Self::Failure,
            common_enums::AttemptStatus::Authorized => Self::Authorized,
            common_enums::AttemptStatus::PartiallyAuthorized => Self::PartiallyAuthorized,
            common_enums::AttemptStatus::Started => Self::Started,
            common_enums::AttemptStatus::Expired => Self::Expired,
            common_enums::AttemptStatus::AuthenticationFailed => Self::AuthenticationFailed,
            common_enums::AttemptStatus::AuthenticationPending => Self::AuthenticationPending,
            common_enums::AttemptStatus::AuthenticationSuccessful => Self::AuthenticationSuccessful,
            common_enums::AttemptStatus::Authorizing => Self::Authorizing,
            common_enums::AttemptStatus::CaptureInitiated => Self::CaptureInitiated,
            common_enums::AttemptStatus::CaptureFailed => Self::CaptureFailed,
            common_enums::AttemptStatus::VoidInitiated => Self::VoidInitiated,
            common_enums::AttemptStatus::VoidPostCaptureInitiated => Self::VoidInitiated,
            common_enums::AttemptStatus::VoidFailed => Self::VoidFailed,
            common_enums::AttemptStatus::Voided => Self::Voided,
            common_enums::AttemptStatus::VoidedPostCapture => Self::VoidedPostCapture,
            common_enums::AttemptStatus::Unresolved => Self::Unresolved,
            common_enums::AttemptStatus::PaymentMethodAwaited => Self::PaymentMethodAwaited,
            common_enums::AttemptStatus::ConfirmationAwaited => Self::ConfirmationAwaited,
            common_enums::AttemptStatus::DeviceDataCollectionPending => {
                Self::DeviceDataCollectionPending
            }
            common_enums::AttemptStatus::RouterDeclined => Self::RouterDeclined,
            common_enums::AttemptStatus::AuthorizationFailed => Self::AuthorizationFailed,
            common_enums::AttemptStatus::CodInitiated => Self::CodInitiated,
            common_enums::AttemptStatus::AutoRefunded => Self::AutoRefunded,
            common_enums::AttemptStatus::PartialCharged => Self::PartialCharged,
            common_enums::AttemptStatus::PartialChargedAndChargeable => {
                Self::PartialChargedAndChargeable
            }
            common_enums::AttemptStatus::IntegrityFailure => Self::Failure,
            common_enums::AttemptStatus::Unspecified => Self::AttemptStatusUnspecified,
            common_enums::AttemptStatus::Unknown => Self::AttemptStatusUnspecified,
        }
    }
}

impl ForeignFrom<common_enums::AuthorizationStatus>
    for grpc_api_types::payments::AuthorizationStatus
{
    fn foreign_from(status: common_enums::AuthorizationStatus) -> Self {
        match status {
            common_enums::AuthorizationStatus::Success => Self::AuthorizationSuccess,
            common_enums::AuthorizationStatus::Unresolved => Self::AuthorizationUnresolved,
            common_enums::AuthorizationStatus::Processing => Self::AuthorizationProcessing,
            common_enums::AuthorizationStatus::Failure => Self::AuthorizationFailure,
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentStatus> for common_enums::AttemptStatus {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        status: grpc_api_types::payments::PaymentStatus,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match status {
            grpc_api_types::payments::PaymentStatus::Charged => Ok(Self::Charged),
            grpc_api_types::payments::PaymentStatus::Pending => Ok(Self::Pending),
            grpc_api_types::payments::PaymentStatus::Failure => Ok(Self::Failure),
            grpc_api_types::payments::PaymentStatus::Authorized => Ok(Self::Authorized),
            grpc_api_types::payments::PaymentStatus::Started => Ok(Self::Started),
            grpc_api_types::payments::PaymentStatus::AuthenticationFailed => {
                Ok(Self::AuthenticationFailed)
            }
            grpc_api_types::payments::PaymentStatus::AuthenticationPending => {
                Ok(Self::AuthenticationPending)
            }
            grpc_api_types::payments::PaymentStatus::AuthenticationSuccessful => {
                Ok(Self::AuthenticationSuccessful)
            }
            grpc_api_types::payments::PaymentStatus::Authorizing => Ok(Self::Authorizing),
            grpc_api_types::payments::PaymentStatus::PartiallyAuthorized => {
                Ok(Self::PartiallyAuthorized)
            }
            grpc_api_types::payments::PaymentStatus::CaptureInitiated => Ok(Self::CaptureInitiated),
            grpc_api_types::payments::PaymentStatus::CaptureFailed => Ok(Self::CaptureFailed),
            grpc_api_types::payments::PaymentStatus::VoidInitiated => Ok(Self::VoidInitiated),
            grpc_api_types::payments::PaymentStatus::VoidFailed => Ok(Self::VoidFailed),
            grpc_api_types::payments::PaymentStatus::Voided => Ok(Self::Voided),
            grpc_api_types::payments::PaymentStatus::VoidedPostCapture => {
                Ok(Self::VoidedPostCapture)
            }
            grpc_api_types::payments::PaymentStatus::Expired => Ok(Self::Expired),
            grpc_api_types::payments::PaymentStatus::Unresolved => Ok(Self::Unresolved),
            grpc_api_types::payments::PaymentStatus::PaymentMethodAwaited => {
                Ok(Self::PaymentMethodAwaited)
            }
            grpc_api_types::payments::PaymentStatus::ConfirmationAwaited => {
                Ok(Self::ConfirmationAwaited)
            }
            grpc_api_types::payments::PaymentStatus::DeviceDataCollectionPending => {
                Ok(Self::DeviceDataCollectionPending)
            }
            grpc_api_types::payments::PaymentStatus::RouterDeclined => Ok(Self::RouterDeclined),
            grpc_api_types::payments::PaymentStatus::AuthorizationFailed => {
                Ok(Self::AuthorizationFailed)
            }
            grpc_api_types::payments::PaymentStatus::CodInitiated => Ok(Self::CodInitiated),
            grpc_api_types::payments::PaymentStatus::AutoRefunded => Ok(Self::AutoRefunded),
            grpc_api_types::payments::PaymentStatus::PartialCharged => Ok(Self::PartialCharged),
            grpc_api_types::payments::PaymentStatus::PartialChargedAndChargeable => {
                Ok(Self::PartialChargedAndChargeable)
            }
            grpc_api_types::payments::PaymentStatus::AttemptStatusUnspecified => Ok(Self::Unknown),
        }
    }
}

impl ForeignFrom<common_enums::RefundStatus> for grpc_api_types::payments::RefundStatus {
    fn foreign_from(status: common_enums::RefundStatus) -> Self {
        match status {
            common_enums::RefundStatus::Failure => Self::RefundFailure,
            common_enums::RefundStatus::ManualReview => Self::RefundManualReview,
            common_enums::RefundStatus::Pending => Self::RefundPending,
            common_enums::RefundStatus::Success => Self::RefundSuccess,
            common_enums::RefundStatus::TransactionFailure => Self::RefundTransactionFailure,
        }
    }
}

pub fn generate_payment_void_response(
    router_data_v2: RouterDataV2<Void, PaymentFlowData, PaymentVoidData, PaymentsResponseData>,
) -> Result<PaymentServiceVoidResponse, error_stack::Report<ApplicationErrorResponse>> {
    let transaction_response = router_data_v2.response;

    // Create state if either access token or connector customer is available
    let state = if router_data_v2.resource_common_data.access_token.is_some()
        || router_data_v2
            .resource_common_data
            .connector_customer
            .is_some()
    {
        Some(ConnectorState {
            access_token: router_data_v2
                .resource_common_data
                .access_token
                .as_ref()
                .map(|token_data| grpc_api_types::payments::AccessToken {
                    token: token_data.access_token.clone(),
                    expires_in_seconds: token_data.expires_in,
                    token_type: token_data.token_type.clone(),
                }),
            connector_customer_id: router_data_v2
                .resource_common_data
                .connector_customer
                .clone(),
        })
    } else {
        None
    };

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    match transaction_response {
        Ok(response) => match response {
            PaymentsResponseData::TransactionResponse {
                resource_id,
                redirection_data: _,
                connector_metadata,
                network_txn_id: _,
                connector_response_reference_id,
                incremental_authorization_allowed,
                mandate_reference,
                status_code,
            } => {
                let status = router_data_v2.resource_common_data.status;
                let grpc_status = grpc_api_types::payments::PaymentStatus::foreign_from(status);

                let grpc_resource_id =
                    grpc_api_types::payments::Identifier::foreign_try_from(resource_id)?;

                let mandate_reference_grpc =
                    mandate_reference.map(|m| grpc_api_types::payments::MandateReference {
                        mandate_id: m.connector_mandate_id,
                        payment_method_id: m.payment_method_id,
                        connector_mandate_request_reference_id: m
                            .connector_mandate_request_reference_id,
                    });

                Ok(PaymentServiceVoidResponse {
                    transaction_id: Some(grpc_resource_id),
                    status: grpc_status.into(),
                    response_ref_id: connector_response_reference_id.map(|id| {
                        grpc_api_types::payments::Identifier {
                            id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                        }
                    }),
                    error_code: None,
                    error_message: None,
                    error_reason: None,
                    status_code: u32::from(status_code),
                    response_headers: router_data_v2
                        .resource_common_data
                        .get_connector_response_headers_as_map(),
                    raw_connector_request,
                    state,
                    mandate_reference: mandate_reference_grpc,
                    incremental_authorization_allowed,
                    connector_metadata: convert_connector_metadata_to_secret_string(
                        connector_metadata,
                    ),
                })
            }
            _ => Err(report!(ApplicationErrorResponse::InternalServerError(
                ApiError {
                    sub_code: "INVALID_RESPONSE_TYPE".to_owned(),
                    error_identifier: 500,
                    error_message: "Invalid response type received from connector".to_owned(),
                    error_object: None,
                }
            ))),
        },
        Err(e) => {
            let status = match e.get_attempt_status_for_grpc(
                e.status_code,
                router_data_v2.resource_common_data.status,
            ) {
                Some(attempt_status) => {
                    grpc_api_types::payments::PaymentStatus::foreign_from(attempt_status)
                }
                None => grpc_api_types::payments::PaymentStatus::AttemptStatusUnspecified,
            };
            Ok(PaymentServiceVoidResponse {
                transaction_id: e.connector_transaction_id.clone().map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                response_ref_id: e.connector_transaction_id.map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                status: status as i32,
                error_message: Some(e.message),
                error_code: Some(e.code),
                error_reason: e.reason,
                status_code: e.status_code as u32,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                state: None,
                raw_connector_request,
                mandate_reference: None,
                incremental_authorization_allowed: None,
                connector_metadata: None,
            })
        }
    }
}

pub fn generate_payment_void_post_capture_response(
    router_data_v2: RouterDataV2<
        VoidPC,
        PaymentFlowData,
        crate::connector_types::PaymentsCancelPostCaptureData,
        PaymentsResponseData,
    >,
) -> Result<PaymentServiceVoidPostCaptureResponse, error_stack::Report<ApplicationErrorResponse>> {
    let transaction_response = router_data_v2.response;

    // If there's an access token in PaymentFlowData, it must be newly generated (needs caching)
    let _state = router_data_v2
        .resource_common_data
        .access_token
        .as_ref()
        .map(|token_data| ConnectorState {
            access_token: Some(grpc_api_types::payments::AccessToken {
                token: token_data.access_token.clone(),
                expires_in_seconds: token_data.expires_in,
                token_type: token_data.token_type.clone(),
            }),
            connector_customer_id: router_data_v2
                .resource_common_data
                .connector_customer
                .clone(),
        });

    match transaction_response {
        Ok(response) => match response {
            PaymentsResponseData::TransactionResponse {
                resource_id,
                redirection_data: _,
                connector_metadata: _,
                network_txn_id: _,
                connector_response_reference_id,
                incremental_authorization_allowed: _,
                mandate_reference: _,
                status_code,
            } => {
                let status = router_data_v2.resource_common_data.status;
                let grpc_status = grpc_api_types::payments::PaymentStatus::foreign_from(status);

                let grpc_resource_id =
                    grpc_api_types::payments::Identifier::foreign_try_from(resource_id)?;

                Ok(PaymentServiceVoidPostCaptureResponse {
                    transaction_id: Some(grpc_resource_id),
                    status: grpc_status.into(),
                    response_ref_id: connector_response_reference_id.map(|id| {
                        grpc_api_types::payments::Identifier {
                            id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                        }
                    }),
                    error_code: None,
                    error_message: None,
                    error_reason: None,
                    status_code: u32::from(status_code),
                    response_headers: router_data_v2
                        .resource_common_data
                        .get_connector_response_headers_as_map(),
                })
            }
            _ => Err(report!(ApplicationErrorResponse::InternalServerError(
                ApiError {
                    sub_code: "INVALID_RESPONSE_TYPE".to_owned(),
                    error_identifier: 500,
                    error_message: "Invalid response type received from connector".to_owned(),
                    error_object: None,
                }
            ))),
        },
        Err(e) => {
            let status = match e.get_attempt_status_for_grpc(
                e.status_code,
                router_data_v2.resource_common_data.status,
            ) {
                Some(attempt_status) => {
                    grpc_api_types::payments::PaymentStatus::foreign_from(attempt_status)
                }
                None => grpc_api_types::payments::PaymentStatus::AttemptStatusUnspecified,
            };
            Ok(PaymentServiceVoidPostCaptureResponse {
                transaction_id: e.connector_transaction_id.clone().map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                status: status.into(),
                response_ref_id: e.connector_transaction_id.map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                error_code: Some(e.code),
                error_message: Some(e.message),
                error_reason: e.reason,
                status_code: u32::from(e.status_code),
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
            })
        }
    }
}

impl ForeignFrom<common_enums::DisputeStage> for grpc_api_types::payments::DisputeStage {
    fn foreign_from(status: common_enums::DisputeStage) -> Self {
        match status {
            common_enums::DisputeStage::PreDispute => Self::PreDispute,
            common_enums::DisputeStage::Dispute => Self::ActiveDispute,
            common_enums::DisputeStage::PreArbitration => Self::PreArbitration,
        }
    }
}

impl ForeignFrom<grpc_api_types::payments::ProductType> for common_enums::ProductType {
    fn foreign_from(value: grpc_api_types::payments::ProductType) -> Self {
        match value {
            grpc_api_types::payments::ProductType::Physical => Self::Physical,
            grpc_api_types::payments::ProductType::Digital => Self::Digital,
            grpc_api_types::payments::ProductType::Travel => Self::Travel,
            grpc_api_types::payments::ProductType::Ride => Self::Ride,
            grpc_api_types::payments::ProductType::Event => Self::Event,
            grpc_api_types::payments::ProductType::Accommodation => Self::Accommodation,
        }
    }
}

pub fn generate_payment_sync_response(
    router_data_v2: RouterDataV2<PSync, PaymentFlowData, PaymentsSyncData, PaymentsResponseData>,
) -> Result<PaymentServiceGetResponse, error_stack::Report<ApplicationErrorResponse>> {
    let transaction_response = router_data_v2.response;
    let raw_connector_response = router_data_v2
        .resource_common_data
        .get_raw_connector_response();

    // Create state if either access token or connector customer is available
    let state = if router_data_v2.resource_common_data.access_token.is_some()
        || router_data_v2
            .resource_common_data
            .connector_customer
            .is_some()
    {
        Some(ConnectorState {
            access_token: router_data_v2
                .resource_common_data
                .access_token
                .as_ref()
                .map(|token_data| grpc_api_types::payments::AccessToken {
                    token: token_data.access_token.clone(),
                    expires_in_seconds: token_data.expires_in,
                    token_type: token_data.token_type.clone(),
                }),
            connector_customer_id: router_data_v2
                .resource_common_data
                .connector_customer
                .clone(),
        })
    } else {
        None
    };

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    let connector_response = router_data_v2
        .resource_common_data
        .connector_response
        .as_ref()
        .map(|connector_response_data| {
            grpc_api_types::payments::ConnectorResponseData::foreign_try_from(
                connector_response_data.clone(),
            )
        })
        .transpose()?;

    match transaction_response {
        Ok(response) => match response {
            PaymentsResponseData::TransactionResponse {
                resource_id,
                redirection_data,
                connector_metadata: _,
                network_txn_id,
                connector_response_reference_id,
                incremental_authorization_allowed: _,
                mandate_reference,
                status_code,
            } => {
                let status = router_data_v2.resource_common_data.status;
                let grpc_status = grpc_api_types::payments::PaymentStatus::foreign_from(status);

                let grpc_resource_id =
                    grpc_api_types::payments::Identifier::foreign_try_from(resource_id)?;

                let mandate_reference_grpc =
                    mandate_reference.map(|m| grpc_api_types::payments::MandateReference {
                        mandate_id: m.connector_mandate_id,
                        payment_method_id: m.payment_method_id,
                        connector_mandate_request_reference_id: m
                            .connector_mandate_request_reference_id,
                    });

                Ok(PaymentServiceGetResponse {
                    transaction_id: Some(grpc_resource_id),
                    redirection_data: redirection_data
                        .map(|form| grpc_api_types::payments::RedirectForm::foreign_try_from(*form))
                        .transpose()?,
                    status: grpc_status as i32,
                    mandate_reference: mandate_reference_grpc,
                    error_code: None,
                    error_message: None,
                    error_reason: None,
                    network_decline_code: None,
                    network_advice_code: None,
                    network_error_message: None,
                    network_txn_id,
                    response_ref_id: connector_response_reference_id.map(|id| {
                        grpc_api_types::payments::Identifier {
                            id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                        }
                    }),
                    amount: None,
                    minor_amount: None,
                    currency: None,
                    captured_amount: router_data_v2.resource_common_data.amount_captured,
                    minor_captured_amount: router_data_v2
                        .resource_common_data
                        .minor_amount_captured
                        .map(|amount_captured| amount_captured.get_amount_as_i64()),
                    payment_method_type: None,
                    capture_method: None,
                    auth_type: None,
                    created_at: None,
                    updated_at: None,
                    authorized_at: None,
                    captured_at: None,
                    customer_name: None,
                    email: None,
                    connector_customer_id: None,
                    merchant_order_reference_id: None,
                    metadata: None,
                    status_code: status_code as u32,
                    raw_connector_response,
                    response_headers: router_data_v2
                        .resource_common_data
                        .get_connector_response_headers_as_map(),
                    state,
                    raw_connector_request,
                    connector_response,
                })
            }
            _ => Err(report!(ApplicationErrorResponse::InternalServerError(
                ApiError {
                    sub_code: "INVALID_RESPONSE_TYPE".to_owned(),
                    error_identifier: 500,
                    error_message: "Invalid response type received from connector".to_owned(),
                    error_object: None,
                }
            ))),
        },
        Err(e) => {
            let status = match e.get_attempt_status_for_grpc(
                e.status_code,
                router_data_v2.resource_common_data.status,
            ) {
                Some(attempt_status) => {
                    grpc_api_types::payments::PaymentStatus::foreign_from(attempt_status)
                }
                None => grpc_api_types::payments::PaymentStatus::AttemptStatusUnspecified,
            };
            Ok(PaymentServiceGetResponse {
                transaction_id: Some(grpc_api_types::payments::Identifier {
                    id_type: Some(if let Some(txn_id) = e.connector_transaction_id {
                        grpc_api_types::payments::identifier::IdType::Id(txn_id)
                    } else {
                        grpc_api_types::payments::identifier::IdType::NoResponseIdMarker(())
                    }),
                }),
                mandate_reference: None,
                status: status as i32,
                error_message: Some(e.message),
                error_code: Some(e.code),
                error_reason: e.reason,
                network_decline_code: e.network_decline_code,
                network_advice_code: e.network_advice_code,
                network_error_message: e.network_error_message,
                network_txn_id: None,
                response_ref_id: None,
                amount: None,
                minor_amount: None,
                currency: None,
                captured_amount: None,
                minor_captured_amount: None,
                payment_method_type: None,
                capture_method: None,
                auth_type: None,
                created_at: None,
                updated_at: None,
                authorized_at: None,
                captured_at: None,
                customer_name: None,
                email: None,
                connector_customer_id: None,
                merchant_order_reference_id: None,
                metadata: None,
                raw_connector_response,
                status_code: e.status_code as u32,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                state,
                raw_connector_request,
                connector_response,
                redirection_data: None,
            })
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::RefundServiceGetRequest> for RefundSyncData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::RefundServiceGetRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // Extract transaction_id as connector_transaction_id
        let connector_transaction_id = value
            .transaction_id
            .and_then(|id| id.id_type)
            .and_then(|id_type| match id_type {
                grpc_api_types::payments::identifier::IdType::Id(id) => Some(id),
                _ => None,
            })
            .unwrap_or_default();

        Ok(Self {
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            connector_transaction_id,
            connector_refund_id: value.refund_id.clone(),
            reason: value.refund_reason.clone(),
            refund_status: common_enums::RefundStatus::Pending,
            refund_connector_metadata: value
                .refund_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "refund metadata")))
                .transpose()?,
            all_keys_required: None, // Field not available in new proto structure
            integrity_object: None,
            split_refunds: None,
            merchant_account_metadata: value
                .merchant_account_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
                .transpose()?,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::RefundServiceGetRequest,
        Connectors,
        &MaskedMetadata,
    )> for RefundFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::RefundServiceGetRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);

        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;

        let payment_method = value
            .payment_method_type
            .map(|pm_type_i32| {
                // Convert i32 to gRPC PaymentMethodType enum
                let grpc_pm_type =
                    grpc_api_types::payments::PaymentMethodType::try_from(pm_type_i32)
                        .unwrap_or(grpc_api_types::payments::PaymentMethodType::Unspecified);

                // Convert from gRPC enum to internal PaymentMethod using ForeignTryFrom
                PaymentMethod::foreign_try_from(grpc_pm_type)
            })
            .transpose()?;

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),

            status: common_enums::RefundStatus::Pending,
            refund_id: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            access_token,
            connector_meta_data,
            test_mode: value.test_mode,
            payment_method,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceRefundRequest,
        Connectors,
        &MaskedMetadata,
    )> for RefundFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceRefundRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);

        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;

        let payment_method = value
            .payment_method_type
            .map(|pm_type_i32| {
                // Convert i32 to gRPC PaymentMethodType enum
                let grpc_pm_type =
                    grpc_api_types::payments::PaymentMethodType::try_from(pm_type_i32)
                        .unwrap_or(grpc_api_types::payments::PaymentMethodType::Unspecified);

                // Convert from gRPC enum to internal PaymentMethod using ForeignTryFrom
                PaymentMethod::foreign_try_from(grpc_pm_type)
            })
            .transpose()?;

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),

            status: common_enums::RefundStatus::Pending,
            refund_id: Some(value.refund_id),
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            access_token,
            connector_meta_data,
            test_mode: value.test_mode,
            payment_method,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentMethodType> for PaymentMethod {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentMethodType,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::PaymentMethodType::Credit => Ok(Self::Card),
            grpc_api_types::payments::PaymentMethodType::Debit => Ok(Self::Card),

            grpc_api_types::payments::PaymentMethodType::ApplePay => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethodType::GooglePay => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethodType::AmazonPay => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethodType::PayPal => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethodType::WeChatPay => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethodType::AliPay => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethodType::Cashapp => Ok(Self::Wallet),
            grpc_api_types::payments::PaymentMethodType::RevolutPay => Ok(Self::Wallet),

            grpc_api_types::payments::PaymentMethodType::UpiCollect => Ok(Self::Upi),
            grpc_api_types::payments::PaymentMethodType::UpiIntent => Ok(Self::Upi),

            grpc_api_types::payments::PaymentMethodType::Affirm => Ok(Self::PayLater),
            grpc_api_types::payments::PaymentMethodType::AfterpayClearpay => Ok(Self::PayLater),
            grpc_api_types::payments::PaymentMethodType::Alma => Ok(Self::PayLater),
            grpc_api_types::payments::PaymentMethodType::Atome => Ok(Self::PayLater),

            grpc_api_types::payments::PaymentMethodType::BancontactCard => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethodType::Ideal => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethodType::Sofort => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethodType::Trustly => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethodType::Giropay => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethodType::Eps => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethodType::Przelewy24 => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethodType::Blik => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethodType::Bizum => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethodType::OpenBankingUk => Ok(Self::BankRedirect),
            grpc_api_types::payments::PaymentMethodType::OnlineBankingFpx => Ok(Self::BankRedirect),

            grpc_api_types::payments::PaymentMethodType::Ach => Ok(Self::BankTransfer),
            grpc_api_types::payments::PaymentMethodType::Sepa => Ok(Self::BankTransfer),
            grpc_api_types::payments::PaymentMethodType::Bacs => Ok(Self::BankTransfer),

            grpc_api_types::payments::PaymentMethodType::ClassicReward => Ok(Self::Reward),
            grpc_api_types::payments::PaymentMethodType::Evoucher => Ok(Self::Reward),

            grpc_api_types::payments::PaymentMethodType::CryptoCurrency => Ok(Self::Crypto),

            grpc_api_types::payments::PaymentMethodType::DuitNow => Ok(Self::RealTimePayment),

            grpc_api_types::payments::PaymentMethodType::Boleto => Ok(Self::Voucher),
            grpc_api_types::payments::PaymentMethodType::Oxxo => Ok(Self::Voucher),
            grpc_api_types::payments::PaymentMethodType::CardRedirect => Ok(Self::CardRedirect),
            grpc_api_types::payments::PaymentMethodType::Knet => Ok(Self::CardRedirect),
            grpc_api_types::payments::PaymentMethodType::Benefit => Ok(Self::CardRedirect),
            grpc_api_types::payments::PaymentMethodType::MomoAtm => Ok(Self::CardRedirect),

            _ => Err(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "UNSUPPORTED_PAYMENT_METHOD_TYPE".to_owned(),
                error_identifier: 400,
                error_message: "This payment method type cannot be mapped to a high-level category"
                    .to_owned(),
                error_object: None,
            })
            .into()),
        }
    }
}

impl ForeignFrom<common_enums::DisputeStatus> for grpc_api_types::payments::DisputeStatus {
    fn foreign_from(status: common_enums::DisputeStatus) -> Self {
        match status {
            common_enums::DisputeStatus::DisputeOpened => Self::DisputeOpened,
            common_enums::DisputeStatus::DisputeAccepted => Self::DisputeAccepted,
            common_enums::DisputeStatus::DisputeCancelled => Self::DisputeCancelled,
            common_enums::DisputeStatus::DisputeChallenged => Self::DisputeChallenged,
            common_enums::DisputeStatus::DisputeExpired => Self::DisputeExpired,
            common_enums::DisputeStatus::DisputeLost => Self::DisputeLost,
            common_enums::DisputeStatus::DisputeWon => Self::DisputeWon,
        }
    }
}

impl ForeignFrom<Method> for grpc_api_types::payments::HttpMethod {
    fn foreign_from(method: Method) -> Self {
        match method {
            Method::Post => Self::Post,
            Method::Get => Self::Get,
            Method::Put => Self::Put,
            Method::Delete => Self::Delete,
            Method::Patch => Self::Post, // Patch is not defined in gRPC, using Post
                                         // as a fallback
        }
    }
}

impl ForeignTryFrom<router_response_types::RedirectForm>
    for grpc_api_types::payments::RedirectForm
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        form: router_response_types::RedirectForm,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match form {
            router_response_types::RedirectForm::Form {
                endpoint,
                method,
                form_fields,
            } => Ok(Self {
                form_type: Some(grpc_api_types::payments::redirect_form::FormType::Form(
                    grpc_api_types::payments::FormData {
                        endpoint,
                        method: grpc_api_types::payments::HttpMethod::foreign_from(method) as i32,
                        form_fields,
                    },
                )),
            }),
            router_response_types::RedirectForm::Html { html_data } => Ok(Self {
                form_type: Some(grpc_api_types::payments::redirect_form::FormType::Html(
                    grpc_api_types::payments::HtmlData { html_data },
                )),
            }),
            router_response_types::RedirectForm::Uri { uri } => Ok(Self {
                form_type: Some(grpc_api_types::payments::redirect_form::FormType::Uri(
                    grpc_api_types::payments::UriData { uri },
                )),
            }),
            router_response_types::RedirectForm::Mifinity {
                initialization_token,
            } => Ok(Self {
                form_type: Some(grpc_api_types::payments::redirect_form::FormType::Mifinity(
                    grpc_api_types::payments::MifinityData {
                        initialization_token,
                    },
                )),
            }),
            router_response_types::RedirectForm::Braintree {
                client_token,
                card_token,
                bin,
                acs_url,
            } => Ok(Self {
                form_type: Some(
                    grpc_api_types::payments::redirect_form::FormType::Braintree(
                        grpc_api_types::payments::BraintreeData {
                            client_token,
                            card_token,
                            bin,
                            acs_url,
                        },
                    ),
                ),
            }),
            // Variants not supported in gRPC proto
            router_response_types::RedirectForm::BlueSnap { .. }
            | router_response_types::RedirectForm::CybersourceAuthSetup { .. }
            | router_response_types::RedirectForm::CybersourceConsumerAuth { .. }
            | router_response_types::RedirectForm::DeutschebankThreeDSChallengeFlow { .. }
            | router_response_types::RedirectForm::Payme
            | router_response_types::RedirectForm::Nmi { .. }
            | router_response_types::RedirectForm::WorldpayDDCForm { .. } => {
                Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "UNSUPPORTED_REDIRECT_FORM_TYPE".to_owned(),
                    error_identifier: 400,
                    error_message: "RedirectForm type not supported in gRPC API".to_owned(),
                    error_object: None,
                })
                .into())
            }
        }
    }
}

pub fn generate_accept_dispute_response(
    router_data_v2: RouterDataV2<Accept, DisputeFlowData, AcceptDisputeData, DisputeResponseData>,
) -> Result<AcceptDisputeResponse, error_stack::Report<ApplicationErrorResponse>> {
    let dispute_response = router_data_v2.response;
    let response_headers = router_data_v2
        .resource_common_data
        .get_connector_response_headers_as_map();

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    match dispute_response {
        Ok(response) => {
            let grpc_status =
                grpc_api_types::payments::DisputeStatus::foreign_from(response.dispute_status);

            Ok(AcceptDisputeResponse {
                dispute_status: grpc_status.into(),
                dispute_id: response.connector_dispute_id,
                connector_status_code: None,
                error_message: None,
                error_code: None,
                error_reason: None,
                response_ref_id: None,
                status_code: response.status_code as u32,
                response_headers,
                raw_connector_request,
            })
        }
        Err(e) => {
            let grpc_dispute_status = grpc_api_types::payments::DisputeStatus::default();

            Ok(AcceptDisputeResponse {
                dispute_status: grpc_dispute_status as i32,
                dispute_id: e.connector_transaction_id.unwrap_or_default(),
                connector_status_code: None,
                error_message: Some(e.message),
                error_code: Some(e.code),
                error_reason: e.reason,
                response_ref_id: None,
                status_code: e.status_code as u32,
                response_headers,
                raw_connector_request,
            })
        }
    }
}

impl ForeignTryFrom<(grpc_api_types::payments::AcceptDisputeRequest, Connectors)>
    for DisputeFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors): (grpc_api_types::payments::AcceptDisputeRequest, Connectors),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            dispute_id: None,
            connectors,
            connector_dispute_id: value.dispute_id,
            defense_reason_code: None,
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::AcceptDisputeRequest,
        Connectors,
        &MaskedMetadata,
    )> for DisputeFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, _metadata): (
            grpc_api_types::payments::AcceptDisputeRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),

            dispute_id: None,
            connectors,
            connector_dispute_id: value.dispute_id,
            defense_reason_code: None,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
        })
    }
}

pub fn generate_submit_evidence_response(
    router_data_v2: RouterDataV2<
        SubmitEvidence,
        DisputeFlowData,
        SubmitEvidenceData,
        DisputeResponseData,
    >,
) -> Result<DisputeServiceSubmitEvidenceResponse, error_stack::Report<ApplicationErrorResponse>> {
    let dispute_response = router_data_v2.response;
    let response_headers = router_data_v2
        .resource_common_data
        .get_connector_response_headers_as_map();

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    match dispute_response {
        Ok(response) => {
            let grpc_status =
                grpc_api_types::payments::DisputeStatus::foreign_from(response.dispute_status);

            Ok(DisputeServiceSubmitEvidenceResponse {
                dispute_status: grpc_status.into(),
                dispute_id: Some(response.connector_dispute_id),
                submitted_evidence_ids: vec![],
                connector_status_code: None,
                error_message: None,
                error_code: None,
                error_reason: None,
                response_ref_id: None,
                status_code: response.status_code as u32,
                response_headers,
                raw_connector_request,
            })
        }
        Err(e) => {
            let grpc_attempt_status = e
                .attempt_status
                .map(grpc_api_types::payments::PaymentStatus::foreign_from)
                .unwrap_or_default();

            Ok(DisputeServiceSubmitEvidenceResponse {
                dispute_status: grpc_attempt_status.into(),
                dispute_id: e.connector_transaction_id,
                submitted_evidence_ids: vec![],
                connector_status_code: None,
                error_message: Some(e.message),
                error_code: Some(e.code),
                error_reason: e.reason,
                response_ref_id: None,
                status_code: e.status_code as u32,
                response_headers,
                raw_connector_request,
            })
        }
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::DisputeServiceSubmitEvidenceRequest,
        Connectors,
    )> for DisputeFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors): (
            grpc_api_types::payments::DisputeServiceSubmitEvidenceRequest,
            Connectors,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            dispute_id: None,
            connectors,
            connector_dispute_id: value.dispute_id,
            defense_reason_code: None,
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::DisputeServiceSubmitEvidenceRequest,
        Connectors,
        &MaskedMetadata,
    )> for DisputeFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, _metadata): (
            grpc_api_types::payments::DisputeServiceSubmitEvidenceRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),

            dispute_id: None,
            connectors,
            connector_dispute_id: value.dispute_id,
            defense_reason_code: None,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
        })
    }
}

pub fn generate_refund_sync_response(
    router_data_v2: RouterDataV2<RSync, RefundFlowData, RefundSyncData, RefundsResponseData>,
) -> Result<RefundResponse, error_stack::Report<ApplicationErrorResponse>> {
    let refunds_response = router_data_v2.response;
    let raw_connector_response = router_data_v2
        .resource_common_data
        .get_raw_connector_response();

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    match refunds_response {
        Ok(response) => {
            let status = response.refund_status;
            let grpc_status = grpc_api_types::payments::RefundStatus::foreign_from(status);
            let response_headers = router_data_v2
                .resource_common_data
                .get_connector_response_headers_as_map();
            Ok(RefundResponse {
                transaction_id: Some(grpc_api_types::payments::Identifier::default()),
                refund_id: response.connector_refund_id.clone(),
                status: grpc_status as i32,
                response_ref_id: Some(grpc_api_types::payments::Identifier {
                    id_type: Some(grpc_api_types::payments::identifier::IdType::Id(
                        response.connector_refund_id.clone(),
                    )),
                }),
                error_code: None,
                error_message: None,
                error_reason: None,
                refund_amount: None,
                minor_refund_amount: None,
                refund_currency: None,
                payment_amount: None,
                minor_payment_amount: None,
                refund_reason: None,
                created_at: None,
                updated_at: None,
                processed_at: None,
                customer_name: None,
                email: None,
                merchant_order_reference_id: None,
                metadata: None,
                refund_metadata: None,
                raw_connector_response,
                status_code: response.status_code as u32,
                response_headers,
                state: None,
                raw_connector_request,
            })
        }
        Err(e) => {
            let status = e
                .attempt_status
                .map(grpc_api_types::payments::PaymentStatus::foreign_from)
                .unwrap_or_default();
            let response_headers = router_data_v2
                .resource_common_data
                .get_connector_response_headers_as_map();

            Ok(RefundResponse {
                transaction_id: Some(
                    e.connector_transaction_id
                        .as_ref()
                        .map(|id| grpc_api_types::payments::Identifier {
                            id_type: Some(grpc_api_types::payments::identifier::IdType::Id(
                                id.clone(),
                            )),
                        })
                        .unwrap_or_default(),
                ),
                refund_id: String::new(),
                status: status as i32,
                response_ref_id: e.connector_transaction_id.map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                error_code: Some(e.code),
                error_message: Some(e.message),
                error_reason: e.reason,
                refund_amount: None,
                minor_refund_amount: None,
                refund_currency: None,
                payment_amount: None,
                minor_payment_amount: None,
                refund_reason: None,
                created_at: None,
                updated_at: None,
                processed_at: None,
                customer_name: None,
                email: None,
                raw_connector_response,
                merchant_order_reference_id: None,
                metadata: None,
                refund_metadata: None,
                status_code: e.status_code as u32,
                response_headers,
                state: None,
                raw_connector_request,
            })
        }
    }
}
impl ForeignTryFrom<WebhookDetailsResponse> for PaymentServiceGetResponse {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: WebhookDetailsResponse,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let status = grpc_api_types::payments::PaymentStatus::foreign_from(value.status);
        let response_headers = value
            .response_headers
            .map(|headers| {
                headers
                    .iter()
                    .filter_map(|(name, value)| {
                        value
                            .to_str()
                            .ok()
                            .map(|v| (name.to_string(), v.to_string()))
                    })
                    .collect()
            })
            .unwrap_or_default();
        let mandate_reference_grpc =
            value
                .mandate_reference
                .map(|m| grpc_api_types::payments::MandateReference {
                    mandate_id: m.connector_mandate_id,
                    payment_method_id: m.payment_method_id,
                    connector_mandate_request_reference_id: m
                        .connector_mandate_request_reference_id,
                });
        Ok(Self {
            transaction_id: value
                .resource_id
                .map(|resource_id| {
                    grpc_api_types::payments::Identifier::foreign_try_from(resource_id)
                })
                .transpose()?,
            status: status as i32,
            mandate_reference: mandate_reference_grpc,
            error_code: value.error_code,
            error_message: value.error_message,
            error_reason: None,
            network_decline_code: None,
            network_advice_code: None,
            network_error_message: None,
            network_txn_id: value.network_txn_id,
            response_ref_id: value.connector_response_reference_id.map(|id| {
                grpc_api_types::payments::Identifier {
                    id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                }
            }),
            amount: None,
            minor_amount: None,
            currency: None,
            captured_amount: value.amount_captured,
            minor_captured_amount: value
                .minor_amount_captured
                .map(|amount_captured| amount_captured.get_amount_as_i64()),
            payment_method_type: None,
            capture_method: None,
            auth_type: None,
            created_at: None,
            updated_at: None,
            authorized_at: None,
            captured_at: None,
            customer_name: None,
            email: None,
            connector_customer_id: None,
            merchant_order_reference_id: None,
            metadata: None,
            status_code: value.status_code as u32,
            raw_connector_response: None,
            response_headers,
            state: None,
            raw_connector_request: None,
            connector_response: None,
            redirection_data: None,
        })
    }
}

impl ForeignTryFrom<PaymentServiceVoidRequest> for PaymentVoidData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: PaymentServiceVoidRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let amount = Some(common_utils::types::MinorUnit::new(value.amount()));
        // If currency is unspecified, send None, otherwise try to convert it
        let currency = if value.currency() == grpc_api_types::payments::Currency::Unspecified {
            None
        } else {
            Some(common_enums::Currency::foreign_try_from(value.currency())?)
        };
        Ok(Self {
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            connector_transaction_id: value
                .transaction_id
                .and_then(|id| id.id_type)
                .and_then(|id_type| match id_type {
                    grpc_api_types::payments::identifier::IdType::Id(id) => Some(id),
                    _ => None,
                })
                .unwrap_or_default(),
            metadata: value
                .metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "metadata")))
                .transpose()?,
            cancellation_reason: value.cancellation_reason,
            raw_connector_response: None,
            integrity_object: None,
            amount,
            currency,
            connector_metadata: value
                .connector_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "connector metadata")))
                .transpose()?,
            merchant_order_reference_id: value.merchant_order_reference_id,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentServiceVoidPostCaptureRequest>
    for crate::connector_types::PaymentsCancelPostCaptureData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceVoidPostCaptureRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            connector_transaction_id: value
                .transaction_id
                .and_then(|id| id.id_type)
                .and_then(|id_type| match id_type {
                    grpc_api_types::payments::identifier::IdType::Id(id) => Some(id),
                    _ => None,
                })
                .unwrap_or_default(),
            cancellation_reason: value.cancellation_reason,
            raw_connector_response: None,
            integrity_object: None,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceVoidPostCaptureRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceVoidPostCaptureRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // For void post capture operations, address information is typically not available or required
        // Since this is a PaymentServiceVoidPostCaptureRequest, we use default address values
        let address: PaymentAddress = PaymentAddress::new(
            None,        // shipping
            None,        // billing
            None,        // payment_method_billing
            Some(false), // should_unify_address = false for void post capture operations
        );

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card, //TODO
            address,
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description: None,
            return_url: None,
            connector_meta_data: None,
            amount_captured: None,
            minor_amount_captured: None,
            access_token: None,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: None,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            minor_amount_capturable: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl ForeignTryFrom<PaymentServiceIncrementalAuthorizationRequest>
    for PaymentsIncrementalAuthorizationData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: PaymentServiceIncrementalAuthorizationRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let currency = common_enums::Currency::foreign_try_from(value.currency())?;

        let connector_transaction_id = ResponseId::ConnectorTransactionId(
            value
                .transaction_id
                .clone()
                .and_then(|id| id.id_type)
                .and_then(|id_type| match id_type {
                    grpc_api_types::payments::identifier::IdType::Id(id) => Some(id),
                    _ => None,
                })
                .ok_or(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "MISSING_TRANSACTION_ID".to_owned(),
                    error_identifier: 400,
                    error_message: "Transaction id is missing".to_owned(),
                    error_object: None,
                }))?,
        );

        let connector_metadata = value
            .connector_metadata
            .map(|metadata| serde_json::from_str(&metadata.expose()))
            .transpose()
            .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_CONNECTOR_METADATA".to_owned(),
                error_identifier: 400,
                error_message: "Failed to parse connector metadata".to_owned(),
                error_object: None,
            }))?;

        Ok(Self {
            minor_amount: common_utils::types::MinorUnit::new(value.minor_amount),
            connector_transaction_id,
            connector_metadata,
            currency,
            reason: value.reason,
        })
    }
}

impl
    ForeignTryFrom<(
        PaymentServiceIncrementalAuthorizationRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            PaymentServiceIncrementalAuthorizationRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // For incremental authorization operations, address information is typically not available or required
        // Since this is a PaymentServiceIncrementalAuthorizationRequest, we use default address values
        let address: PaymentAddress = PaymentAddress::new(
            None,        // shipping
            None,        // billing
            None,        // payment_method_billing
            Some(false), // should_unify_address = false for void post capture operations
        );

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card, //TODO
            address,
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description: None,
            return_url: None,
            connector_meta_data: None,
            amount_captured: None,
            minor_amount_captured: None,
            access_token: None,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: None,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            minor_amount_capturable: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl ForeignTryFrom<RefundWebhookDetailsResponse> for RefundResponse {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: RefundWebhookDetailsResponse,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let status = grpc_api_types::payments::RefundStatus::foreign_from(value.status);
        let response_headers = value
            .response_headers
            .map(|headers| {
                headers
                    .iter()
                    .filter_map(|(name, value)| {
                        value
                            .to_str()
                            .ok()
                            .map(|v| (name.to_string(), v.to_string()))
                    })
                    .collect()
            })
            .unwrap_or_default();

        Ok(Self {
            transaction_id: Some(grpc_api_types::payments::Identifier::default()),
            refund_id: value.connector_refund_id.unwrap_or_default(),
            status: status.into(),
            response_ref_id: value.connector_response_reference_id.map(|id| {
                grpc_api_types::payments::Identifier {
                    id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                }
            }),
            error_code: value.error_code,
            error_message: value.error_message,
            error_reason: None,
            raw_connector_response: None,
            refund_amount: None,
            minor_refund_amount: None,
            refund_currency: None,
            payment_amount: None,
            minor_payment_amount: None,
            refund_reason: None,
            created_at: None,
            updated_at: None,
            processed_at: None,
            customer_name: None,
            email: None,
            merchant_order_reference_id: None,
            metadata: None,
            refund_metadata: None,
            status_code: value.status_code as u32,
            response_headers,
            state: None,
            raw_connector_request: None,
        })
    }
}

impl ForeignTryFrom<DisputeWebhookDetailsResponse> for DisputeResponse {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: DisputeWebhookDetailsResponse,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let grpc_status = grpc_api_types::payments::DisputeStatus::foreign_from(value.status);
        let grpc_stage = grpc_api_types::payments::DisputeStage::foreign_from(value.stage);
        let response_headers = value
            .response_headers
            .map(|headers| {
                headers
                    .iter()
                    .filter_map(|(name, value)| {
                        value
                            .to_str()
                            .ok()
                            .map(|v| (name.to_string(), v.to_string()))
                    })
                    .collect()
            })
            .unwrap_or_default();
        Ok(Self {
            dispute_id: Some(value.dispute_id),
            transaction_id: None,
            dispute_status: grpc_status.into(),
            dispute_stage: grpc_stage.into(),
            connector_status_code: None,
            error_code: None,
            error_message: None,
            error_reason: None,
            dispute_amount: None,
            dispute_currency: None,
            dispute_date: None,
            service_date: None,
            shipping_date: None,
            due_date: None,
            evidence_documents: vec![],
            dispute_reason: None,
            dispute_message: value.dispute_message,
            response_ref_id: value.connector_response_reference_id.map(|id| {
                grpc_api_types::payments::Identifier {
                    id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                }
            }),
            status_code: value.status_code as u32,
            response_headers,
            raw_connector_request: None,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentServiceRefundRequest> for RefundsData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceRefundRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let minor_refund_amount = common_utils::types::MinorUnit::new(value.minor_refund_amount);

        let minor_payment_amount = common_utils::types::MinorUnit::new(value.minor_payment_amount);

        // Extract transaction_id as connector_transaction_id
        let connector_transaction_id = value
            .transaction_id
            .clone()
            .and_then(|id| id.id_type)
            .and_then(|id_type| match id_type {
                grpc_api_types::payments::identifier::IdType::Id(id) => Some(id),
                _ => None,
            })
            .unwrap_or_default();

        Ok(Self {
            refund_id: value.refund_id.to_string(),
            connector_transaction_id,
            connector_refund_id: None, // refund_id field is used as refund_id, not connector_refund_id
            customer_id: value.customer_id.clone(),
            currency: common_enums::Currency::foreign_try_from(value.currency())?,
            payment_amount: value.payment_amount,
            reason: value.reason.clone(),
            webhook_url: value.webhook_url,
            refund_amount: value.refund_amount,
            connector_metadata: value
                .connector_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "connector metadata")))
                .transpose()?,
            refund_connector_metadata: value
                .refund_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "refund metadata")))
                .transpose()?,
            minor_payment_amount,
            minor_refund_amount,
            refund_status: common_enums::RefundStatus::Pending,
            merchant_account_id: value.merchant_account_id,
            capture_method: value
                .capture_method
                .map(|cm| {
                    CaptureMethod::foreign_try_from(
                        grpc_api_types::payments::CaptureMethod::try_from(cm).unwrap_or_default(),
                    )
                })
                .transpose()?,
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            integrity_object: None,
            split_refunds: None,
            merchant_account_metadata: value
                .merchant_account_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
                .transpose()?,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::AcceptDisputeRequest> for AcceptDisputeData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::AcceptDisputeRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            connector_dispute_id: value.dispute_id,
            integrity_object: None,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::DisputeServiceSubmitEvidenceRequest>
    for SubmitEvidenceData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::DisputeServiceSubmitEvidenceRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // Initialize all fields to None
        let mut result = Self {
            dispute_id: Some(value.dispute_id.clone()),
            connector_dispute_id: value.dispute_id,
            integrity_object: None,
            access_activity_log: None,
            billing_address: None,
            cancellation_policy: None,
            cancellation_policy_file_type: None,
            cancellation_policy_provider_file_id: None,
            cancellation_policy_disclosure: None,
            cancellation_rebuttal: None,
            customer_communication: None,
            customer_communication_file_type: None,
            customer_communication_provider_file_id: None,
            customer_email_address: None,
            customer_name: None,
            customer_purchase_ip: None,
            customer_signature: None,
            customer_signature_file_type: None,
            customer_signature_provider_file_id: None,
            product_description: None,
            receipt: None,
            receipt_file_type: None,
            receipt_provider_file_id: None,
            refund_policy: None,
            refund_policy_file_type: None,
            refund_policy_provider_file_id: None,
            refund_policy_disclosure: None,
            refund_refusal_explanation: None,
            service_date: value.service_date.map(|date| date.to_string()),
            service_documentation: None,
            service_documentation_file_type: None,
            service_documentation_provider_file_id: None,
            shipping_address: None,
            shipping_carrier: None,
            shipping_date: value.shipping_date.map(|date| date.to_string()),
            shipping_documentation: None,
            shipping_documentation_file_type: None,
            shipping_documentation_provider_file_id: None,
            shipping_tracking_number: None,
            invoice_showing_distinct_transactions: None,
            invoice_showing_distinct_transactions_file_type: None,
            invoice_showing_distinct_transactions_provider_file_id: None,
            recurring_transaction_agreement: None,
            recurring_transaction_agreement_file_type: None,
            recurring_transaction_agreement_provider_file_id: None,
            uncategorized_file: None,
            uncategorized_file_type: None,
            uncategorized_file_provider_file_id: None,
            uncategorized_text: None,
        };

        // Extract evidence from evidence_documents array
        for document in value.evidence_documents {
            let evidence_type =
                grpc_api_types::payments::EvidenceType::try_from(document.evidence_type)
                    .unwrap_or(grpc_api_types::payments::EvidenceType::Unspecified);

            match evidence_type {
                grpc_api_types::payments::EvidenceType::CancellationPolicy => {
                    result.cancellation_policy = document.file_content;
                    result.cancellation_policy_file_type = document.file_mime_type;
                    result.cancellation_policy_provider_file_id = document.provider_file_id;
                }
                grpc_api_types::payments::EvidenceType::CustomerCommunication => {
                    result.customer_communication = document.file_content;
                    result.customer_communication_file_type = document.file_mime_type;
                    result.customer_communication_provider_file_id = document.provider_file_id;
                }
                grpc_api_types::payments::EvidenceType::CustomerSignature => {
                    result.customer_signature = document.file_content;
                    result.customer_signature_file_type = document.file_mime_type;
                    result.customer_signature_provider_file_id = document.provider_file_id;
                }
                grpc_api_types::payments::EvidenceType::Receipt => {
                    result.receipt = document.file_content;
                    result.receipt_file_type = document.file_mime_type;
                    result.receipt_provider_file_id = document.provider_file_id;
                }
                grpc_api_types::payments::EvidenceType::RefundPolicy => {
                    result.refund_policy = document.file_content;
                    result.refund_policy_file_type = document.file_mime_type;
                    result.refund_policy_provider_file_id = document.provider_file_id;
                }
                grpc_api_types::payments::EvidenceType::ServiceDocumentation => {
                    result.service_documentation = document.file_content;
                    result.service_documentation_file_type = document.file_mime_type;
                    result.service_documentation_provider_file_id = document.provider_file_id;
                }
                grpc_api_types::payments::EvidenceType::ShippingDocumentation => {
                    result.shipping_documentation = document.file_content;
                    result.shipping_documentation_file_type = document.file_mime_type;
                    result.shipping_documentation_provider_file_id = document.provider_file_id;
                }
                grpc_api_types::payments::EvidenceType::InvoiceShowingDistinctTransactions => {
                    result.invoice_showing_distinct_transactions = document.file_content;
                    result.invoice_showing_distinct_transactions_file_type =
                        document.file_mime_type;
                    result.invoice_showing_distinct_transactions_provider_file_id =
                        document.provider_file_id;
                }
                grpc_api_types::payments::EvidenceType::RecurringTransactionAgreement => {
                    result.recurring_transaction_agreement = document.file_content;
                    result.recurring_transaction_agreement_file_type = document.file_mime_type;
                    result.recurring_transaction_agreement_provider_file_id =
                        document.provider_file_id;
                }
                grpc_api_types::payments::EvidenceType::UncategorizedFile => {
                    result.uncategorized_file = document.file_content;
                    result.uncategorized_file_type = document.file_mime_type;
                    result.uncategorized_file_provider_file_id = document.provider_file_id;
                    result.uncategorized_text = document.text_content;
                }
                grpc_api_types::payments::EvidenceType::Unspecified => {
                    // Skip unspecified evidence types
                }
            }
        }

        Ok(result)
    }
}

pub fn generate_refund_response(
    router_data_v2: RouterDataV2<Refund, RefundFlowData, RefundsData, RefundsResponseData>,
) -> Result<RefundResponse, error_stack::Report<ApplicationErrorResponse>> {
    let refund_response = router_data_v2.response;
    let raw_connector_response = router_data_v2
        .resource_common_data
        .get_raw_connector_response();

    // RefundFlowData doesn't have access_token field, so no state to return
    let state = None;

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    match refund_response {
        Ok(response) => {
            let status = response.refund_status;
            let grpc_status = grpc_api_types::payments::RefundStatus::foreign_from(status);

            Ok(RefundResponse {
                transaction_id: Some(grpc_api_types::payments::Identifier::default()),
                refund_id: response.connector_refund_id,
                status: grpc_status as i32,
                response_ref_id: None,
                error_code: None,
                error_message: None,
                error_reason: None,
                refund_amount: None,
                minor_refund_amount: None,
                refund_currency: None,
                payment_amount: None,
                minor_payment_amount: None,
                refund_reason: None,
                created_at: None,
                updated_at: None,
                processed_at: None,
                customer_name: None,
                email: None,
                merchant_order_reference_id: None,
                raw_connector_response,
                metadata: None,
                refund_metadata: None,
                status_code: response.status_code as u32,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                state,
                raw_connector_request,
            })
        }
        Err(e) => {
            let status = e
                .attempt_status
                .map(grpc_api_types::payments::PaymentStatus::foreign_from)
                .unwrap_or_default();

            Ok(RefundResponse {
                transaction_id: Some(
                    e.connector_transaction_id
                        .map(|id| grpc_api_types::payments::Identifier {
                            id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                        })
                        .unwrap_or_default(),
                ),
                refund_id: String::new(),
                status: status as i32,
                response_ref_id: None,
                error_code: Some(e.code),
                error_message: Some(e.message),
                error_reason: e.reason,
                refund_amount: None,
                minor_refund_amount: None,
                refund_currency: None,
                payment_amount: None,
                minor_payment_amount: None,
                refund_reason: None,
                created_at: None,
                updated_at: None,
                processed_at: None,
                customer_name: None,
                email: None,
                raw_connector_response,
                merchant_order_reference_id: None,
                metadata: None,
                refund_metadata: None,
                status_code: e.status_code as u32,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                state,
                raw_connector_request,
            })
        }
    }
}

impl ForeignTryFrom<PaymentServiceSdkSessionTokenRequest> for PaymentsSdkSessionTokenData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: PaymentServiceSdkSessionTokenRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let currency = common_enums::Currency::foreign_try_from(value.currency())?;

        let payment_method_type =
            <Option<PaymentMethodType>>::foreign_try_from(value.payment_method_type())?;

        let email: Option<Email> = match value.email {
            Some(ref email_str) => {
                Some(Email::try_from(email_str.clone().expose()).map_err(|_| {
                    error_stack::Report::new(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_EMAIL_FORMAT".to_owned(),
                        error_identifier: 400,

                        error_message: "Invalid email".to_owned(),
                        error_object: None,
                    }))
                })?)
            }
            None => None,
        };

        Ok(Self {
            amount: common_utils::types::MinorUnit::new(value.amount),
            currency,
            country: Some(CountryAlpha2::foreign_try_from(
                value.country_alpha2_code(),
            )?),
            order_details: None,
            email,
            minor_amount: common_utils::types::MinorUnit::new(value.minor_amount),
            customer_name: value.customer_name,
            order_tax_amount: value
                .order_tax_amount
                .map(common_utils::types::MinorUnit::new),
            shipping_cost: value.shipping_cost.map(common_utils::types::MinorUnit::new),
            payment_method_type,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentServiceCaptureRequest>
    for PaymentsCaptureData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceCaptureRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let capture_method = Some(CaptureMethod::foreign_try_from(value.capture_method())?);

        let connector_transaction_id = ResponseId::ConnectorTransactionId(
            value
                .transaction_id
                .clone()
                .and_then(|id| id.id_type)
                .and_then(|id_type| match id_type {
                    grpc_api_types::payments::identifier::IdType::Id(id) => Some(id),
                    _ => None,
                })
                .unwrap_or_default(),
        );

        let multiple_capture_data =
            value
                .multiple_capture_data
                .clone()
                .map(|data| MultipleCaptureRequestData {
                    capture_sequence: data.capture_sequence,
                    capture_reference: data.capture_reference,
                });

        let minor_amount = common_utils::types::MinorUnit::new(value.amount_to_capture);

        Ok(Self {
            amount_to_capture: value.amount_to_capture,
            minor_amount_to_capture: minor_amount,
            currency: common_enums::Currency::foreign_try_from(value.currency())?,
            connector_transaction_id,
            multiple_capture_data,
            metadata: value
                .metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "metadata")))
                .transpose()?,
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            integrity_object: None,
            capture_method,
            connector_metadata: value
                .connector_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "connector metadata")))
                .transpose()?,
            merchant_order_reference_id: value.merchant_order_reference_id,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceCaptureRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceCaptureRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;
        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);
        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;
        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "PAYMENT_ID".to_string(),
            attempt_id: "ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card, // Default
            address: PaymentAddress::default(),
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description: None,
            return_url: None,
            connector_meta_data,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl
    ForeignTryFrom<(
        PaymentServiceSdkSessionTokenRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            PaymentServiceSdkSessionTokenRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "PAYMENT_ID".to_string(),
            attempt_id: "ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Wallet,
            address: PaymentAddress::default(),
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description: None,
            return_url: None,
            connector_meta_data: value
                .merchant_account_metadata
                .map(|metadata| serde_json::from_str(&metadata.expose()))
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_MERCHANT_ACCOUNT_METADATA".to_owned(),
                    error_identifier: 400,
                    error_message: "Failed to parse merchant account metadata".to_owned(),
                    error_object: None,
                }))?,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token: None,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: None,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

pub fn generate_payment_incremental_authorization_response(
    router_data_v2: RouterDataV2<
        IncrementalAuthorization,
        PaymentFlowData,
        PaymentsIncrementalAuthorizationData,
        PaymentsResponseData,
    >,
) -> Result<
    PaymentServiceIncrementalAuthorizationResponse,
    error_stack::Report<ApplicationErrorResponse>,
> {
    // Create state if either access token or connector customer is available
    let state = if router_data_v2.resource_common_data.access_token.is_some()
        || router_data_v2
            .resource_common_data
            .connector_customer
            .is_some()
    {
        Some(ConnectorState {
            access_token: router_data_v2
                .resource_common_data
                .access_token
                .as_ref()
                .map(|token_data| grpc_api_types::payments::AccessToken {
                    token: token_data.access_token.clone(),
                    expires_in_seconds: token_data.expires_in,
                    token_type: token_data.token_type.clone(),
                }),
            connector_customer_id: router_data_v2
                .resource_common_data
                .connector_customer
                .clone(),
        })
    } else {
        None
    };

    match router_data_v2.response {
        Ok(response) => match response {
            PaymentsResponseData::IncrementalAuthorizationResponse {
                status,
                connector_authorization_id,
                status_code,
            } => {
                let grpc_status =
                    grpc_api_types::payments::AuthorizationStatus::foreign_from(status);

                Ok(PaymentServiceIncrementalAuthorizationResponse {
                    connector_authorization_id,
                    error_code: None,
                    error_message: None,
                    error_reason: None,
                    status: grpc_status.into(),
                    status_code: status_code as u32,
                    response_headers: router_data_v2
                        .resource_common_data
                        .get_connector_response_headers_as_map(),
                    state,
                })
            }
            _ => Err(report!(ApplicationErrorResponse::InternalServerError(
                ApiError {
                    sub_code: "INVALID_RESPONSE_TYPE".to_owned(),
                    error_identifier: 500,
                    error_message: "Invalid response type received from connector".to_owned(),
                    error_object: None,
                }
            ))),
        },
        Err(e) => Ok(PaymentServiceIncrementalAuthorizationResponse {
            status: grpc_api_types::payments::AuthorizationStatus::AuthorizationFailure.into(),
            connector_authorization_id: None,
            error_message: Some(e.message),
            error_code: Some(e.code),
            error_reason: e.reason,
            status_code: e.status_code as u32,
            response_headers: router_data_v2
                .resource_common_data
                .get_connector_response_headers_as_map(),
            state,
        }),
    }
}

pub fn generate_payment_capture_response(
    router_data_v2: RouterDataV2<
        Capture,
        PaymentFlowData,
        PaymentsCaptureData,
        PaymentsResponseData,
    >,
) -> Result<PaymentServiceCaptureResponse, error_stack::Report<ApplicationErrorResponse>> {
    let transaction_response = router_data_v2.response;

    // Create state if either access token or connector customer is available
    let state = if router_data_v2.resource_common_data.access_token.is_some()
        || router_data_v2
            .resource_common_data
            .connector_customer
            .is_some()
    {
        Some(ConnectorState {
            access_token: router_data_v2
                .resource_common_data
                .access_token
                .as_ref()
                .map(|token_data| grpc_api_types::payments::AccessToken {
                    token: token_data.access_token.clone(),
                    expires_in_seconds: token_data.expires_in,
                    token_type: token_data.token_type.clone(),
                }),
            connector_customer_id: router_data_v2
                .resource_common_data
                .connector_customer
                .clone(),
        })
    } else {
        None
    };

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    match transaction_response {
        Ok(response) => match response {
            PaymentsResponseData::TransactionResponse {
                resource_id,
                redirection_data: _,
                connector_metadata,
                network_txn_id: _,
                connector_response_reference_id,
                incremental_authorization_allowed,
                mandate_reference,
                status_code,
            } => {
                let status = router_data_v2.resource_common_data.status;
                let grpc_status = grpc_api_types::payments::PaymentStatus::foreign_from(status);
                let grpc_resource_id =
                    grpc_api_types::payments::Identifier::foreign_try_from(resource_id)?;

                let mandate_reference_grpc =
                    mandate_reference.map(|m| grpc_api_types::payments::MandateReference {
                        mandate_id: m.connector_mandate_id,
                        payment_method_id: m.payment_method_id,
                        connector_mandate_request_reference_id: m
                            .connector_mandate_request_reference_id,
                    });

                Ok(PaymentServiceCaptureResponse {
                    transaction_id: Some(grpc_resource_id),
                    response_ref_id: connector_response_reference_id.map(|id| {
                        grpc_api_types::payments::Identifier {
                            id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                        }
                    }),
                    error_code: None,
                    error_message: None,
                    error_reason: None,
                    status: grpc_status.into(),
                    status_code: status_code as u32,
                    response_headers: router_data_v2
                        .resource_common_data
                        .get_connector_response_headers_as_map(),
                    state,
                    raw_connector_request,
                    incremental_authorization_allowed,
                    mandate_reference: mandate_reference_grpc,
                    captured_amount: router_data_v2.resource_common_data.amount_captured,
                    minor_captured_amount: router_data_v2
                        .resource_common_data
                        .minor_amount_captured
                        .map(|amount_captured| amount_captured.get_amount_as_i64()),
                    connector_metadata: convert_connector_metadata_to_secret_string(
                        connector_metadata,
                    ),
                })
            }
            _ => Err(report!(ApplicationErrorResponse::InternalServerError(
                ApiError {
                    sub_code: "INVALID_RESPONSE_TYPE".to_owned(),
                    error_identifier: 500,
                    error_message: "Invalid response type received from connector".to_owned(),
                    error_object: None,
                }
            ))),
        },
        Err(e) => {
            let status = match e.get_attempt_status_for_grpc(
                e.status_code,
                router_data_v2.resource_common_data.status,
            ) {
                Some(attempt_status) => {
                    grpc_api_types::payments::PaymentStatus::foreign_from(attempt_status)
                }
                None => grpc_api_types::payments::PaymentStatus::AttemptStatusUnspecified,
            };
            Ok(PaymentServiceCaptureResponse {
                transaction_id: e.connector_transaction_id.clone().map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                response_ref_id: e.connector_transaction_id.map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                status: status.into(),
                error_message: Some(e.message),
                error_code: Some(e.code),
                error_reason: e.reason,
                status_code: e.status_code as u32,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                state,
                raw_connector_request,
                incremental_authorization_allowed: None,
                mandate_reference: None,
                captured_amount: None,
                minor_captured_amount: None,
                connector_metadata: None,
            })
        }
    }
}

impl
    ForeignTryFrom<(
        PaymentServiceRegisterRequest,
        Connectors,
        consts::Env,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, environment, metadata): (
            PaymentServiceRegisterRequest,
            Connectors,
            consts::Env,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let address = match value.address {
            Some(address) => PaymentAddress::foreign_try_from(address)?,
            None => {
                return Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_ADDRESS".to_owned(),
                    error_identifier: 400,
                    error_message: "Address is required".to_owned(),
                    error_object: None,
                }))?
            }
        };
        let test_mode = match environment {
            consts::Env::Development => Some(true),
            consts::Env::Production => Some(false),
            _ => Some(true),
        };

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;
        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);
        let metadata = value
            .metadata
            .map(|m| SecretSerdeValue::foreign_try_from((m, "metadata")))
            .transpose()?;
        let description = metadata
            .as_ref()
            .and_then(|m| m.peek().get("description"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        // Extract connector_meta_data from merchant_account_metadata
        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card, //TODO
            address,
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: value
                .customer_id
                .clone()
                .map(|customer_id| CustomerId::try_from(Cow::from(customer_id)))
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_CUSTOMER_ID".to_owned(),
                    error_identifier: 400,
                    error_message: "Failed to parse Customer Id".to_owned(),
                    error_object: None,
                }))?,
            connector_customer: value.connector_customer_id,
            description,
            return_url: None,
            connector_meta_data,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token,
            session_token: value.session_token,
            reference_id: None,
            payment_method_token: value
                .payment_method_token
                .map(|pmt| router_data::PaymentMethodToken::Token(Secret::new(pmt))),
            preprocessing_id: None,
            connector_api_version: None,
            test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl ForeignTryFrom<PaymentServiceRegisterRequest> for SetupMandateRequestData<DefaultPCIHolder> {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: PaymentServiceRegisterRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let email: Option<Email> = match value.email {
            Some(ref email_str) => {
                Some(Email::try_from(email_str.clone().expose()).map_err(|_| {
                    error_stack::Report::new(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_EMAIL_FORMAT".to_owned(),
                        error_identifier: 400,

                        error_message: "Invalid email".to_owned(),
                        error_object: None,
                    }))
                })?)
            }
            None => None,
        };
        let customer_acceptance = value.customer_acceptance.clone().ok_or_else(|| {
            error_stack::Report::new(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "MISSING_CUSTOMER_ACCEPTANCE".to_owned(),
                error_identifier: 400,
                error_message: "Customer acceptance is missing".to_owned(),
                error_object: None,
            }))
        })?;

        let setup_future_usage = value.setup_future_usage();

        let setup_mandate_details = MandateData {
            update_mandate_id: None,
            customer_acceptance: Some(mandates::CustomerAcceptance::foreign_try_from(
                customer_acceptance.clone(),
            )?),
            mandate_type: None,
        };

        let billing_descriptor =
            value
                .billing_descriptor
                .as_ref()
                .map(|descriptor| BillingDescriptor {
                    name: descriptor.name.clone(),
                    city: descriptor.city.clone(),
                    phone: descriptor.phone.clone(),
                    statement_descriptor: descriptor.statement_descriptor.clone(),
                    statement_descriptor_suffix: descriptor.statement_descriptor_suffix.clone(),
                    reference: descriptor.reference.clone(),
                });

        let payment_channel = match value.payment_channel() {
            grpc_payment_types::PaymentChannel::Unspecified => None,
            _ => Some(common_enums::PaymentChannel::foreign_try_from(
                value.payment_channel(),
            )?),
        };

        Ok(Self {
            currency: common_enums::Currency::foreign_try_from(value.currency())?,
            payment_method_data: PaymentMethodData::foreign_try_from(
                value.payment_method.ok_or_else(|| {
                    ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                        error_identifier: 400,
                        error_message: "Payment method data is required".to_owned(),
                        error_object: None,
                    })
                })?,
            )?,
            amount: Some(0),
            confirm: true,
            customer_acceptance: Some(mandates::CustomerAcceptance::foreign_try_from(
                customer_acceptance.clone(),
            )?),
            mandate_id: None,
            setup_future_usage: Some(common_enums::FutureUsage::foreign_try_from(
                setup_future_usage,
            )?),
            off_session: value.off_session,
            setup_mandate_details: Some(setup_mandate_details),
            router_return_url: value.return_url.clone(),
            webhook_url: value.webhook_url,
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            email,
            customer_name: None,
            return_url: value.return_url.clone(),
            payment_method_type: None,
            request_incremental_authorization: false,
            metadata: value
                .metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "metadata")))
                .transpose()?,
            complete_authorize_url: None,
            capture_method: None,
            integrity_object: None,
            minor_amount: Some(common_utils::types::MinorUnit::new(0)),
            shipping_cost: None,
            customer_id: value
                .customer_id
                .clone()
                .map(|customer_id| CustomerId::try_from(Cow::from(customer_id)))
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_CUSTOMER_ID".to_owned(),
                    error_identifier: 400,
                    error_message: "Failed to parse Customer Id".to_owned(),
                    error_object: None,
                }))?,
            billing_descriptor,
            merchant_order_reference_id: value.merchant_order_reference_id,
            merchant_account_metadata: value
                .merchant_account_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
                .transpose()?,
            payment_channel,
            enable_partial_authorization: value.enable_partial_authorization,
            locale: value.locale.clone(),
            connector_testing_data: value.connector_testing_data.and_then(|s| {
                serde_json::from_str(&s.expose())
                    .ok()
                    .map(common_utils::pii::SecretSerdeValue::new)
            }),
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentChannel> for common_enums::PaymentChannel {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentChannel,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_payment_types::PaymentChannel::Ecommerce => {
                Ok(common_enums::PaymentChannel::Ecommerce)
            }
            grpc_payment_types::PaymentChannel::MailOrder => {
                Ok(common_enums::PaymentChannel::MailOrder)
            }
            grpc_payment_types::PaymentChannel::TelephoneOrder => {
                Ok(common_enums::PaymentChannel::TelephoneOrder)
            }
            grpc_payment_types::PaymentChannel::Unspecified => {
                Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "UNSPECIFIED_PAYMENT_CHANNEL".to_owned(),
                    error_identifier: 400,
                    error_message: "Payment channel type must be specified".to_owned(),
                    error_object: None,
                })
                .into())
            }
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::CustomerAcceptance> for mandates::CustomerAcceptance {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::CustomerAcceptance,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            acceptance_type: mandates::AcceptanceType::foreign_try_from(value.acceptance_type())?,
            accepted_at: time::OffsetDateTime::from_unix_timestamp(value.accepted_at)
                .ok()
                .map(|offset_dt| time::PrimitiveDateTime::new(offset_dt.date(), offset_dt.time())),
            online: value
                .online_mandate_details
                .map(mandates::OnlineMandate::foreign_try_from)
                .transpose()?,
        })
    }
}

impl
    From<(
        &grpc_api_types::payments::BillingDescriptor,
        Option<String>,
        Option<String>,
    )> for BillingDescriptor
{
    fn from(
        (descriptor, statement_descriptor_name, statement_descriptor_suffix): (
            &grpc_api_types::payments::BillingDescriptor,
            Option<String>,
            Option<String>,
        ),
    ) -> Self {
        BillingDescriptor {
            name: descriptor.name.clone(),
            city: descriptor.city.clone(),
            phone: descriptor.phone.clone(),
            statement_descriptor: descriptor
                .statement_descriptor
                .clone()
                .or(statement_descriptor_name),
            statement_descriptor_suffix: descriptor
                .statement_descriptor_suffix
                .clone()
                .or(statement_descriptor_suffix),
            reference: descriptor.reference.clone(),
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::OnlineMandate> for mandates::OnlineMandate {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::OnlineMandate,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            ip_address: value.ip_address.map(Secret::new),
            user_agent: value.user_agent,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::AcceptanceType> for mandates::AcceptanceType {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::AcceptanceType,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_payment_types::AcceptanceType::Offline => Ok(Self::Offline),
            grpc_payment_types::AcceptanceType::Online => Ok(Self::Online),
            grpc_payment_types::AcceptanceType::Unspecified => {
                Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "UNSPECIFIED_ACCEPTANCE_TYPE".to_owned(),
                    error_identifier: 400,
                    error_message: "Acceptance type must be specified".to_owned(),
                    error_object: None,
                })
                .into())
            }
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::SetupMandateDetails> for MandateData {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::SetupMandateDetails,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // Map the mandate_type from grpc type to domain type
        let mandate_type = value
            .mandate_type
            .and_then(|grpc_mandate_type| match grpc_mandate_type.mandate_type {
                Some(grpc_api_types::payments::mandate_type::MandateType::SingleUse(
                    amount_data,
                )) => Some(mandates::MandateDataType::SingleUse(
                    mandates::MandateAmountData {
                        amount: common_utils::types::MinorUnit::new(amount_data.amount),
                        currency: grpc_api_types::payments::Currency::try_from(
                            amount_data.currency,
                        )
                        .ok()
                        .and_then(|grpc_currency| {
                            common_enums::Currency::foreign_try_from(grpc_currency).ok()
                        })
                        .unwrap_or(common_enums::Currency::USD),
                        start_date: amount_data.start_date.and_then(|ts| {
                            time::OffsetDateTime::from_unix_timestamp(ts)
                                .ok()
                                .map(|offset_dt| {
                                    time::PrimitiveDateTime::new(offset_dt.date(), offset_dt.time())
                                })
                        }),
                        end_date: amount_data.end_date.and_then(|ts| {
                            time::OffsetDateTime::from_unix_timestamp(ts)
                                .ok()
                                .map(|offset_dt| {
                                    time::PrimitiveDateTime::new(offset_dt.date(), offset_dt.time())
                                })
                        }),
                        metadata: None,
                    },
                )),
                Some(grpc_api_types::payments::mandate_type::MandateType::MultiUse(
                    amount_data,
                )) => Some(mandates::MandateDataType::MultiUse(Some(
                    mandates::MandateAmountData {
                        amount: common_utils::types::MinorUnit::new(amount_data.amount),
                        currency: grpc_api_types::payments::Currency::try_from(
                            amount_data.currency,
                        )
                        .ok()
                        .and_then(|grpc_currency| {
                            common_enums::Currency::foreign_try_from(grpc_currency).ok()
                        })
                        .unwrap_or(common_enums::Currency::USD),
                        start_date: amount_data.start_date.and_then(|ts| {
                            time::OffsetDateTime::from_unix_timestamp(ts)
                                .ok()
                                .map(|offset_dt| {
                                    time::PrimitiveDateTime::new(offset_dt.date(), offset_dt.time())
                                })
                        }),
                        end_date: amount_data.end_date.and_then(|ts| {
                            time::OffsetDateTime::from_unix_timestamp(ts)
                                .ok()
                                .map(|offset_dt| {
                                    time::PrimitiveDateTime::new(offset_dt.date(), offset_dt.time())
                                })
                        }),
                        metadata: None,
                    },
                ))),
                None => None,
            });

        Ok(Self {
            update_mandate_id: value.update_mandate_id,
            customer_acceptance: value
                .customer_acceptance
                .map(mandates::CustomerAcceptance::foreign_try_from)
                .transpose()?,
            mandate_type,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::FutureUsage> for common_enums::FutureUsage {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::FutureUsage,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::FutureUsage::OffSession => Ok(Self::OffSession),
            grpc_api_types::payments::FutureUsage::OnSession => Ok(Self::OnSession),
            grpc_api_types::payments::FutureUsage::Unspecified => {
                Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "UNSPECIFIED_FUTURE_USAGE".to_owned(),
                    error_identifier: 401,
                    error_message: "Future usage must be specified".to_owned(),
                    error_object: None,
                })
                .into())
            }
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::MitCategory> for common_enums::MitCategory {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: grpc_api_types::payments::MitCategory,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::MitCategory::RecurringMit => {
                Ok(common_enums::MitCategory::Recurring)
            }
            grpc_api_types::payments::MitCategory::InstallmentMit => {
                Ok(common_enums::MitCategory::Installment)
            }
            grpc_api_types::payments::MitCategory::UnscheduledMit => {
                Ok(common_enums::MitCategory::Unscheduled)
            }
            grpc_api_types::payments::MitCategory::ResubmissionMit => {
                Ok(common_enums::MitCategory::Resubmission)
            }
            grpc_api_types::payments::MitCategory::Unspecified => {
                Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "UNSPECIFIED_MIT_CATEGORY".to_owned(),
                    error_identifier: 401,
                    error_message: "Mit category must be specified".to_owned(),
                    error_object: None,
                })
                .into())
            }
        }
    }
}

pub fn generate_setup_mandate_response<T: PaymentMethodDataTypes>(
    router_data_v2: RouterDataV2<
        SetupMandate,
        PaymentFlowData,
        SetupMandateRequestData<T>,
        PaymentsResponseData,
    >,
) -> Result<PaymentServiceRegisterResponse, error_stack::Report<ApplicationErrorResponse>> {
    let transaction_response = router_data_v2.response;
    let status = router_data_v2.resource_common_data.status;
    let grpc_status = grpc_api_types::payments::PaymentStatus::foreign_from(status);

    // Create state if either access token or connector customer is available
    let state = if router_data_v2.resource_common_data.access_token.is_some()
        || router_data_v2
            .resource_common_data
            .connector_customer
            .is_some()
    {
        Some(ConnectorState {
            access_token: router_data_v2
                .resource_common_data
                .access_token
                .as_ref()
                .map(|token_data| grpc_api_types::payments::AccessToken {
                    token: token_data.access_token.clone(),
                    expires_in_seconds: token_data.expires_in,
                    token_type: token_data.token_type.clone(),
                }),
            connector_customer_id: router_data_v2
                .resource_common_data
                .connector_customer
                .clone(),
        })
    } else {
        None
    };

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    let connector_response = router_data_v2
        .resource_common_data
        .connector_response
        .as_ref()
        .map(|connector_response_data| {
            grpc_api_types::payments::ConnectorResponseData::foreign_try_from(
                connector_response_data.clone(),
            )
        })
        .transpose()?;

    // Set amount_captured based on status - only if Charged/PartialCharged
    let captured_amount = match status {
        common_enums::AttemptStatus::Charged
        | common_enums::AttemptStatus::PartialCharged
        | common_enums::AttemptStatus::PartialChargedAndChargeable => router_data_v2.request.amount,
        _ => None,
    };

    let minor_captured_amount = captured_amount;

    let response = match transaction_response {
        Ok(response) => match response {
            PaymentsResponseData::TransactionResponse {
                resource_id,
                redirection_data,
                connector_metadata,
                network_txn_id,
                connector_response_reference_id,
                incremental_authorization_allowed,
                mandate_reference,
                status_code,
            } => {
                let mandate_reference_grpc =
                    mandate_reference.map(|m| grpc_api_types::payments::MandateReference {
                        mandate_id: m.connector_mandate_id,
                        payment_method_id: m.payment_method_id,
                        connector_mandate_request_reference_id: m
                            .connector_mandate_request_reference_id,
                    });

                PaymentServiceRegisterResponse {
                    registration_id: Some(grpc_api_types::payments::Identifier::foreign_try_from(resource_id)?),
                    redirection_data: redirection_data.map(
                        |form| {
                            match *form {
                                router_response_types::RedirectForm::Form { endpoint, method, form_fields: _ } => {
                                    Ok::<grpc_api_types::payments::RedirectForm, ApplicationErrorResponse>(grpc_api_types::payments::RedirectForm {
                                        form_type: Some(grpc_api_types::payments::redirect_form::FormType::Form(
                                            grpc_api_types::payments::FormData {
                                                endpoint,
                                                method: match method {
                                                    Method::Get => 1,
                                                    Method::Post => 2,
                                                    Method::Put => 3,
                                                    Method::Delete => 4,
                                                    _ => 0,
                                                },
                                                form_fields: HashMap::default(), //TODO
                                            }
                                        ))
                                    })
                                },
                                router_response_types::RedirectForm::Html { html_data } => {
                                    Ok(grpc_api_types::payments::RedirectForm {
                                        form_type: Some(grpc_api_types::payments::redirect_form::FormType::Html(
                                            grpc_api_types::payments::HtmlData {
                                                html_data,
                                            }
                                        ))
                                    })
                                },
                                _ => Err(
                                    ApplicationErrorResponse::BadRequest(ApiError {
                                        sub_code: "INVALID_RESPONSE".to_owned(),
                                        error_identifier: 400,
                                        error_message: "Invalid response from connector".to_owned(),
                                        error_object: None,
                                    }))?,
                            }
                        }
                    ).transpose()?,
                    network_txn_id,
                    response_ref_id: connector_response_reference_id.map(|id| grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }),
                    status: grpc_status as i32,
                    mandate_reference: mandate_reference_grpc,
                    incremental_authorization_allowed,
                    error_message: None,
                    error_code: None,
                    error_reason: None,
                    status_code: status_code as u32,
                    response_headers: router_data_v2
                        .resource_common_data
                        .get_connector_response_headers_as_map(),
                    state,
                    raw_connector_request,
                    connector_response,
                    connector_metadata: convert_connector_metadata_to_secret_string(connector_metadata),
                    captured_amount,
                    minor_captured_amount,
                }
            }
            _ => Err(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_RESPONSE".to_owned(),
                error_identifier: 400,
                error_message: "Invalid response from connector".to_owned(),
                error_object: None,
            }))?,
        },
        Err(err) => {
            let status = match err.get_attempt_status_for_grpc(
                err.status_code,
                router_data_v2.resource_common_data.status,
            ) {
                Some(attempt_status) => {
                    grpc_api_types::payments::PaymentStatus::foreign_from(attempt_status)
                }
                None => grpc_api_types::payments::PaymentStatus::AttemptStatusUnspecified,
            };
            PaymentServiceRegisterResponse {
                registration_id: Some(grpc_api_types::payments::Identifier {
                    id_type: Some(
                        grpc_api_types::payments::identifier::IdType::NoResponseIdMarker(()),
                    ),
                }),
                redirection_data: None,
                network_txn_id: None,
                response_ref_id: err.connector_transaction_id.map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                status: status as i32,
                mandate_reference: None,
                incremental_authorization_allowed: None,
                error_message: Some(err.message),
                error_code: Some(err.code),
                error_reason: err.reason,
                status_code: err.status_code as u32,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                state,
                raw_connector_request,
                connector_response,
                connector_metadata: None,
                captured_amount: None,
                minor_captured_amount: None,
            }
        }
    };
    Ok(response)
}

impl ForeignTryFrom<(DisputeDefendRequest, Connectors)> for DisputeFlowData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors): (DisputeDefendRequest, Connectors),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            dispute_id: Some(value.dispute_id.clone()),
            connectors,
            connector_dispute_id: value.dispute_id,
            defense_reason_code: Some(value.reason_code.unwrap_or_default()),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
        })
    }
}

impl ForeignTryFrom<(DisputeDefendRequest, Connectors, &MaskedMetadata)> for DisputeFlowData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, _metadata): (DisputeDefendRequest, Connectors, &MaskedMetadata),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),

            dispute_id: Some(value.dispute_id.clone()),
            connectors,
            connector_dispute_id: value.dispute_id,
            defense_reason_code: Some(value.reason_code.unwrap_or_default()),
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
        })
    }
}
impl ForeignTryFrom<DisputeDefendRequest> for DisputeDefendData {
    type Error = ApplicationErrorResponse;
    fn foreign_try_from(
        value: DisputeDefendRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let connector_dispute_id = value.dispute_id;
        Ok(Self {
            dispute_id: connector_dispute_id.clone(),
            connector_dispute_id,
            defense_reason_code: value.reason_code.unwrap_or_default(),
            integrity_object: None,
        })
    }
}

pub fn generate_defend_dispute_response(
    router_data_v2: RouterDataV2<
        DefendDispute,
        DisputeFlowData,
        DisputeDefendData,
        DisputeResponseData,
    >,
) -> Result<DisputeDefendResponse, error_stack::Report<ApplicationErrorResponse>> {
    let defend_dispute_response = router_data_v2.response;

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    match defend_dispute_response {
        Ok(response) => Ok(DisputeDefendResponse {
            dispute_id: response.connector_dispute_id,
            dispute_status: response.dispute_status as i32,
            connector_status_code: None,
            error_message: None,
            error_code: None,
            error_reason: None,
            response_ref_id: None,
            status_code: response.status_code as u32,
            response_headers: router_data_v2
                .resource_common_data
                .get_connector_response_headers_as_map(),
            raw_connector_request,
        }),
        Err(e) => Ok(DisputeDefendResponse {
            dispute_id: e
                .connector_transaction_id
                .unwrap_or_else(|| NO_ERROR_CODE.to_string()),
            dispute_status: common_enums::DisputeStatus::DisputeLost as i32,
            connector_status_code: None,
            error_message: Some(e.message),
            error_code: Some(e.code),
            error_reason: e.reason,
            response_ref_id: None,
            status_code: e.status_code as u32,
            response_headers: router_data_v2
                .resource_common_data
                .get_connector_response_headers_as_map(),
            raw_connector_request,
        }),
    }
}

pub fn generate_session_token_response(
    router_data_v2: RouterDataV2<
        CreateSessionToken,
        PaymentFlowData,
        SessionTokenRequestData,
        SessionTokenResponseData,
    >,
) -> Result<String, error_stack::Report<ApplicationErrorResponse>> {
    let session_token_response = router_data_v2.response;

    match session_token_response {
        Ok(response) => Ok(response.session_token),
        Err(e) => Err(report!(ApplicationErrorResponse::InternalServerError(
            ApiError {
                sub_code: "SESSION_TOKEN_ERROR".to_string(),
                error_identifier: 500,
                error_message: format!("Session token creation failed: {}", e.message),
                error_object: None,
            }
        ))),
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentServiceCreateOrderRequest>
    for PaymentCreateOrderData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceCreateOrderRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let currency = common_enums::Currency::foreign_try_from(value.currency())?;

        Ok(Self {
            amount: common_utils::types::MinorUnit::new(value.amount),
            currency,
            integrity_object: None,
            metadata: value
                .metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "metadata")))
                .transpose()?,
            webhook_url: value.webhook_url,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceCreateOrderRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceCreateOrderRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;
        let vault_headers = extract_headers_from_metadata(metadata);

        // For order creation, create a default address
        let address = PaymentAddress::new(
            None,        // shipping
            None,        // billing
            None,        // payment_method_billing
            Some(false), // should_unify_address
        );

        // Create connector metadata from the metadata field if present
        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;

        // Extract access token from state if present
        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card,
            address,
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None, // PaymentServiceCreateOrderRequest doesn't have customer_id field
            connector_customer: None,
            description: None,
            return_url: None,
            connector_meta_data,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}
#[derive(Debug, Clone, ToSchema, Serialize)]
pub struct CardSpecificFeatures {
    /// Indicates whether three_ds card payments are supported
    // #[schema(value_type = FeatureStatus)]
    pub three_ds: FeatureStatus,
    /// Indicates whether non three_ds card payments are supported
    // #[schema(value_type = FeatureStatus)]
    pub no_three_ds: FeatureStatus,
    /// List of supported card networks
    // #[schema(value_type = Vec<CardNetwork>)]
    pub supported_card_networks: Vec<CardNetwork>,
}

#[derive(Debug, Clone, ToSchema, Serialize)]
#[serde(untagged)]
pub enum PaymentMethodSpecificFeatures {
    /// Card specific features
    Card(CardSpecificFeatures),
}
/// Represents details of a payment method.
#[derive(Debug, Clone)]
pub struct PaymentMethodDetails {
    /// Indicates whether mandates are supported by this payment method.
    pub mandates: FeatureStatus,
    /// Indicates whether refund is supported by this payment method.
    pub refunds: FeatureStatus,
    /// List of supported capture methods
    pub supported_capture_methods: Vec<CaptureMethod>,
    /// Payment method specific features
    pub specific_features: Option<PaymentMethodSpecificFeatures>,
}
/// The status of the feature
#[derive(
    Clone,
    Copy,
    Debug,
    Eq,
    PartialEq,
    serde::Deserialize,
    serde::Serialize,
    strum::Display,
    ToSchema,
)]
#[strum(serialize_all = "snake_case")]
#[serde(rename_all = "snake_case")]
pub enum FeatureStatus {
    NotSupported,
    Supported,
}
pub type PaymentMethodTypeMetadata = HashMap<PaymentMethodType, PaymentMethodDetails>;
pub type SupportedPaymentMethods = HashMap<PaymentMethod, PaymentMethodTypeMetadata>;

#[derive(Debug, Clone)]
pub struct ConnectorInfo {
    /// Display name of the Connector
    pub display_name: &'static str,
    /// Description of the connector.
    pub description: &'static str,
    /// Connector Type
    pub connector_type: PaymentConnectorCategory,
}

/// Connector Access Method
#[derive(
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    PartialEq,
    serde::Deserialize,
    serde::Serialize,
    strum::Display,
    ToSchema,
)]
#[strum(serialize_all = "snake_case")]
#[serde(rename_all = "snake_case")]
pub enum PaymentConnectorCategory {
    PaymentGateway,
    AlternativePaymentMethod,
    BankAcquirer,
}

#[derive(Debug, strum::Display, Eq, PartialEq, Hash)]
pub enum PaymentMethodDataType {
    Card,
    Bluecode,
    Knet,
    Benefit,
    MomoAtm,
    CardRedirect,
    AliPayQr,
    AliPayRedirect,
    AliPayHkRedirect,
    AmazonPayRedirect,
    MomoRedirect,
    KakaoPayRedirect,
    GoPayRedirect,
    GcashRedirect,
    ApplePay,
    ApplePayRedirect,
    ApplePayThirdPartySdk,
    DanaRedirect,
    DuitNow,
    GooglePay,
    GooglePayRedirect,
    GooglePayThirdPartySdk,
    MbWayRedirect,
    MobilePayRedirect,
    PaypalRedirect,
    PaypalSdk,
    Paze,
    SamsungPay,
    TwintRedirect,
    VippsRedirect,
    TouchNGoRedirect,
    WeChatPayRedirect,
    WeChatPayQr,
    CashappQr,
    SwishQr,
    KlarnaRedirect,
    KlarnaSdk,
    AffirmRedirect,
    AfterpayClearpayRedirect,
    PayBrightRedirect,
    WalleyRedirect,
    AlmaRedirect,
    AtomeRedirect,
    BancontactCard,
    Bizum,
    Blik,
    Eft,
    Eps,
    Giropay,
    Ideal,
    Interac,
    LocalBankRedirect,
    OnlineBankingCzechRepublic,
    OnlineBankingFinland,
    OnlineBankingPoland,
    OnlineBankingSlovakia,
    OpenBankingUk,
    Przelewy24,
    Sofort,
    Trustly,
    OnlineBankingFpx,
    OnlineBankingThailand,
    AchBankDebit,
    SepaBankDebit,
    BecsBankDebit,
    BacsBankDebit,
    AchBankTransfer,
    SepaBankTransfer,
    BacsBankTransfer,
    MultibancoBankTransfer,
    PermataBankTransfer,
    BcaBankTransfer,
    BniVaBankTransfer,
    BriVaBankTransfer,
    CimbVaBankTransfer,
    DanamonVaBankTransfer,
    MandiriVaBankTransfer,
    Pix,
    Pse,
    Crypto,
    MandatePayment,
    Reward,
    Upi,
    Boleto,
    Efecty,
    PagoEfectivo,
    RedCompra,
    RedPagos,
    Alfamart,
    Indomaret,
    Oxxo,
    SevenEleven,
    Lawson,
    MiniStop,
    FamilyMart,
    Seicomart,
    PayEasy,
    Givex,
    PaySafeCar,
    CardToken,
    LocalBankTransfer,
    Mifinity,
    Fps,
    PromptPay,
    VietQr,
    OpenBanking,
    NetworkToken,
    NetworkTransactionIdAndCardDetails,
    DirectCarrierBilling,
    InstantBankTransfer,
    InstantBankTransferPoland,
    InstantBankTransferFinland,
    CardDetailsForNetworkTransactionId,
    RevolutPay,
}

impl ForeignTryFrom<String> for Secret<time::Date> {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(date_string: String) -> Result<Self, error_stack::Report<Self::Error>> {
        let date = time::Date::parse(
            &date_string,
            &time::format_description::well_known::Iso8601::DATE,
        )
        .map_err(|err| {
            tracing::error!("Failed to parse date string: {}", err);
            ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_DATE_FORMAT".to_owned(),
                error_identifier: 400,
                error_message: "Invalid date format".to_owned(),
                error_object: None,
            })
        })?;
        Ok(Self::new(date))
    }
}

impl ForeignTryFrom<grpc_api_types::payments::BrowserInformation> for BrowserInformation {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::BrowserInformation,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            color_depth: value.color_depth.map(|cd| cd as u8),
            java_enabled: value.java_enabled,
            java_script_enabled: value.java_script_enabled,
            language: value.language,
            screen_height: value.screen_height,
            screen_width: value.screen_width,
            time_zone: value.time_zone_offset_minutes,
            ip_address: value.ip_address.and_then(|ip| ip.parse().ok()),
            accept_header: value.accept_header,
            user_agent: value.user_agent,
            os_type: value.os_type,
            os_version: value.os_version,
            device_model: value.device_model,
            accept_language: value.accept_language,
            referer: value.referer,
        })
    }
}

impl ForeignTryFrom<PaymentServiceAuthorizeRequest> for SessionTokenRequestData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: PaymentServiceAuthorizeRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let currency = common_enums::Currency::foreign_try_from(value.currency())?;

        Ok(Self {
            amount: common_utils::types::MinorUnit::new(value.minor_amount),
            currency,
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
        })
    }
}

impl ForeignTryFrom<PaymentServiceAuthorizeRequest> for AccessTokenRequestData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        _value: PaymentServiceAuthorizeRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            grant_type: "client_credentials".to_string(),
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentServiceCreateAccessTokenRequest>
    for AccessTokenRequestData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        _value: grpc_api_types::payments::PaymentServiceCreateAccessTokenRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            grant_type: "client_credentials".to_string(),
        })
    }
}

// Generic implementation for access token request from connector auth
impl ForeignTryFrom<&ConnectorAuthType> for AccessTokenRequestData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        _auth_type: &ConnectorAuthType,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // Default to client_credentials grant type for OAuth
        // Connectors can override this with their own specific implementations
        Ok(Self {
            grant_type: "client_credentials".to_string(),
        })
    }
}

impl ForeignTryFrom<PaymentServiceAuthorizeRequest> for ConnectorCustomerData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: PaymentServiceAuthorizeRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // Try to get email from top level first, fallback to billing address
        let email_string = value.email.or_else(|| {
            value
                .address
                .as_ref()
                .and_then(|addr| addr.billing_address.as_ref())
                .and_then(|billing| billing.email.clone())
        });

        let email = email_string.and_then(|email_str| Email::try_from(email_str.expose()).ok());

        // Try to get name from top level customer_name first, fallback to billing address first_name
        let name_string = value.customer_name.map(Secret::new).or_else(|| {
            value
                .address
                .as_ref()
                .and_then(|addr| addr.billing_address.as_ref())
                .and_then(|billing| billing.first_name.clone())
        });

        Ok(Self {
            customer_id: value.customer_id.map(Secret::new),
            email: email.map(Secret::new),
            name: name_string,
            description: None,
            split_payments: None,
            phone: None,
            preprocessing_id: None,
        })
    }
}

impl<T: PaymentMethodDataTypes> From<&PaymentsAuthorizeData<T>>
    for PaymentMethodTokenizationData<T>
{
    fn from(data: &PaymentsAuthorizeData<T>) -> Self {
        Self {
            payment_method_data: data.payment_method_data.clone(),
            browser_info: data.browser_info.clone(),
            currency: data.currency,
            amount: data.amount,
            capture_method: data.capture_method,
            split_payments: data.split_payments.clone(),
            customer_acceptance: data.customer_acceptance.clone(),
            setup_future_usage: data.setup_future_usage,
            setup_mandate_details: data.setup_mandate_details.clone(),
            mandate_id: data.mandate_id.clone(),
            integrity_object: None,
            merchant_account_metadata: data.merchant_account_metadata.clone(),
        }
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentServiceCreateSessionTokenRequest>
    for SessionTokenRequestData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceCreateSessionTokenRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let currency = common_enums::Currency::foreign_try_from(value.currency())?;

        Ok(Self {
            amount: common_utils::types::MinorUnit::new(value.minor_amount),
            currency,
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceCreateSessionTokenRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceCreateSessionTokenRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // For session token operations, address information is typically not available or required
        let address: PaymentAddress = PaymentAddress::new(
            None,        // shipping
            None,        // billing
            None,        // payment_method_billing
            Some(false), // should_unify_address = false for session token operations
        );

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        // Extract connector_meta_data from merchant_account_metadata
        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card, // Default
            address,
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description: None,
            return_url: None,
            connector_meta_data,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token: None,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl ForeignTryFrom<PaymentServiceRegisterRequest> for ConnectorCustomerData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: PaymentServiceRegisterRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let email = value
            .email
            .and_then(|email_str| Email::try_from(email_str.expose()).ok());

        Ok(Self {
            customer_id: value.customer_id.map(Secret::new),
            email: email.map(Secret::new),
            name: value.customer_name.map(Secret::new),
            description: None,
            split_payments: None,
            phone: None,
            preprocessing_id: None,
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentServiceCreatePaymentMethodTokenRequest>
    for PaymentMethodTokenizationData<DefaultPCIHolder>
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceCreatePaymentMethodTokenRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let currency = common_enums::Currency::foreign_try_from(value.currency())?;

        Ok(Self {
            amount: common_utils::types::MinorUnit::new(value.amount),
            currency,
            payment_method_data: PaymentMethodData::<DefaultPCIHolder>::foreign_try_from(
                value.payment_method.ok_or_else(|| {
                    ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                        error_identifier: 400,
                        error_message: "Payment method data is required".to_owned(),
                        error_object: None,
                    })
                })?,
            )?,
            browser_info: None,        // browser_info not available in this proto
            capture_method: None,      // capture_method not available in this proto
            customer_acceptance: None, // customer_acceptance not available in this proto
            setup_future_usage: None,  // setup_future_usage not available in this proto
            mandate_id: None,
            setup_mandate_details: None,
            integrity_object: None,
            split_payments: None,
            merchant_account_metadata: value
                .merchant_account_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
                .transpose()?,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceCreatePaymentMethodTokenRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceCreatePaymentMethodTokenRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        // For payment method token creation, address is optional
        let address = value
            .address
            .map(|addr| {
                // Then create PaymentAddress
                PaymentAddress::foreign_try_from(addr)
            })
            .transpose()?
            .unwrap_or_else(PaymentAddress::default);

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::foreign_try_from(
                value.payment_method.unwrap_or_default(),
            )?,
            address,
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: value
                .customer_id
                .clone()
                .map(|customer_id| CustomerId::try_from(Cow::from(customer_id)))
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_CUSTOMER_ID".to_owned(),
                    error_identifier: 400,
                    error_message: "Failed to parse Customer Id".to_owned(),
                    error_object: None,
                }))?,
            connector_customer: None,
            description: None,
            return_url: value.return_url,
            connector_meta_data: None,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token: None,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

pub fn generate_create_payment_method_token_response(
    router_data_v2: RouterDataV2<
        PaymentMethodToken,
        PaymentFlowData,
        PaymentMethodTokenizationData<DefaultPCIHolder>,
        PaymentMethodTokenResponse,
    >,
) -> Result<
    grpc_api_types::payments::PaymentServiceCreatePaymentMethodTokenResponse,
    error_stack::Report<ApplicationErrorResponse>,
> {
    let token_response = router_data_v2.response;

    match token_response {
        Ok(response) => {
            let token_clone = response.token.clone();
            Ok(
                grpc_api_types::payments::PaymentServiceCreatePaymentMethodTokenResponse {
                    payment_method_token: response.token,
                    error_code: None,
                    error_message: None,
                    error_reason: None,
                    status_code: 200,
                    response_headers: router_data_v2
                        .resource_common_data
                        .get_connector_response_headers_as_map(),
                    response_ref_id: Some(grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(
                            token_clone,
                        )),
                    }),
                    state: None,
                },
            )
        }
        Err(e) => Ok(
            grpc_api_types::payments::PaymentServiceCreatePaymentMethodTokenResponse {
                payment_method_token: String::new(),
                error_code: Some(e.code),
                error_message: Some(e.message),
                error_reason: e.reason,
                status_code: e.status_code as u32,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                response_ref_id: e.connector_transaction_id.map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                state: None,
            },
        ),
    }
}

impl ForeignTryFrom<grpc_api_types::payments::PaymentServiceCreateConnectorCustomerRequest>
    for ConnectorCustomerData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceCreateConnectorCustomerRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let email = value
            .email
            .and_then(|email_str| Email::try_from(email_str.expose()).ok());

        Ok(Self {
            customer_id: value.customer_id.map(Secret::new),
            email: email.map(Secret::new),
            name: value.customer_name.map(Secret::new),
            description: None, // description field not available in this proto
            split_payments: None,
            phone: None,
            preprocessing_id: None,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceCreateConnectorCustomerRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceCreateConnectorCustomerRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;
        let address = value
            .address
            .map(|addr| {
                // Then create PaymentAddress
                PaymentAddress::foreign_try_from(addr)
            })
            .transpose()?
            .unwrap_or_else(PaymentAddress::default);

        // Extract connector_meta_data from merchant_account_metadata
        let connector_meta_data = value
            .merchant_account_metadata
            .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
            .transpose()?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::Card, // Default for connector customer creation
            address,                             // Default address
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ), // request_ref_id field not available in this proto
            customer_id: None,
            connector_customer: None,
            description: None, // description field not available in this proto
            return_url: None,
            connector_meta_data,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token: None,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: value.test_mode,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

pub fn generate_create_connector_customer_response(
    router_data_v2: RouterDataV2<
        CreateConnectorCustomer,
        PaymentFlowData,
        ConnectorCustomerData,
        crate::connector_types::ConnectorCustomerResponse,
    >,
) -> Result<
    grpc_payment_types::PaymentServiceCreateConnectorCustomerResponse,
    error_stack::Report<ApplicationErrorResponse>,
> {
    let customer_response = router_data_v2.response;

    match customer_response {
        Ok(response) => Ok(
            grpc_payment_types::PaymentServiceCreateConnectorCustomerResponse {
                connector_customer_id: response.connector_customer_id.clone(),
                error_code: None,
                error_message: None,
                status_code: 200,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                response_ref_id: Some(grpc_api_types::payments::Identifier {
                    id_type: Some(grpc_api_types::payments::identifier::IdType::Id(
                        response.connector_customer_id.clone(),
                    )),
                }),
                error_reason: None,
            },
        ),
        Err(e) => Ok(
            grpc_payment_types::PaymentServiceCreateConnectorCustomerResponse {
                connector_customer_id: String::new(),
                error_code: Some(e.code),
                error_message: Some(e.message),
                status_code: e.status_code as u32,
                response_headers: router_data_v2
                    .resource_common_data
                    .get_connector_response_headers_as_map(),
                response_ref_id: e.connector_transaction_id.map(|id| {
                    grpc_api_types::payments::Identifier {
                        id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                    }
                }),
                error_reason: e.reason,
            },
        ),
    }
}

impl<
        T: PaymentMethodDataTypes
            + Default
            + Debug
            + Send
            + Eq
            + PartialEq
            + Serialize
            + serde::de::DeserializeOwned
            + Clone
            + CardConversionHelper<T>,
    > ForeignTryFrom<grpc_api_types::payments::PaymentServiceRepeatEverythingRequest>
    for RepeatPaymentData<T>
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceRepeatEverythingRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        // Extract values first to avoid partial move
        let merchant_configured_currency = match value.merchant_configured_currency {
            None => None,
            Some(_) => Some(common_enums::Currency::foreign_try_from(
                value.merchant_configured_currency(),
            )?),
        };
        let amount = value.amount;
        let minor_amount = value.minor_amount;
        let currency = value.currency();
        let mit_category = match value.mit_category() {
            grpc_payment_types::MitCategory::Unspecified => None,
            _ => Some(common_enums::MitCategory::foreign_try_from(
                value.mit_category(),
            )?),
        };
        let payment_method_type =
            <Option<PaymentMethodType>>::foreign_try_from(value.payment_method_type())?;
        let capture_method = value.capture_method();
        let merchant_order_reference_id = value.merchant_order_reference_id;
        let webhook_url = value.webhook_url;

        let email: Option<Email> = match value.email {
            Some(ref email_str) => {
                Some(Email::try_from(email_str.clone().expose()).map_err(|_| {
                    error_stack::Report::new(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_EMAIL_FORMAT".to_owned(),
                        error_identifier: 400,
                        error_message: "Invalid email".to_owned(),
                        error_object: None,
                    }))
                })?)
            }
            None => None,
        };

        // Extract mandate reference_id
        let mandate_ref = match value.mandate_reference_id {
            Some(mandate_reference_id) => match mandate_reference_id.mandate_id_type {
                Some(
                    grpc_payment_types::mandate_reference_id::MandateIdType::ConnectorMandateId(cm),
                ) => MandateReferenceId::ConnectorMandateId(ConnectorMandateReferenceId::new(
                    cm.connector_mandate_id,
                    cm.payment_method_id,
                    None,
                    None,
                    cm.connector_mandate_request_reference_id,
                )),
                Some(
                    grpc_payment_types::mandate_reference_id::MandateIdType::NetworkMandateId(nmi),
                ) => MandateReferenceId::NetworkMandateId(nmi),
                Some(
                    grpc_payment_types::mandate_reference_id::MandateIdType::NetworkTokenWithNti(
                        nti,
                    ),
                ) => MandateReferenceId::NetworkTokenWithNTI(NetworkTokenWithNTIRef {
                    network_transaction_id: nti.network_transaction_id,
                    token_exp_month: nti.token_exp_month,
                    token_exp_year: nti.token_exp_year,
                }),
                None => Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_MANDATE_REFERENCE_ID".to_owned(),
                    error_identifier: 400,
                    error_message: "Mandate reference id is required".to_owned(),
                    error_object: None,
                }))?,
            },
            None => Err(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "MISSING_MANDATE_REFERENCE".to_owned(),
                error_identifier: 400,
                error_message: "Mandate reference is required for repeat payments".to_owned(),
                error_object: None,
            }))?,
        };

        let payment_method_data = value
            .payment_method
            .map(PaymentMethodData::<T>::foreign_try_from)
            .transpose()
            .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                error_identifier: 400,
                error_message: "Payment method data construction failed".to_owned(),
                error_object: None,
            }))?
            .unwrap_or(PaymentMethodData::MandatePayment);

        let billing_descriptor =
            value
                .billing_descriptor
                .as_ref()
                .map(|descriptor| BillingDescriptor {
                    name: descriptor.name.clone(),
                    city: descriptor.city.clone(),
                    phone: descriptor.phone.clone(),
                    statement_descriptor: descriptor.statement_descriptor.clone(),
                    statement_descriptor_suffix: descriptor.statement_descriptor_suffix.clone(),
                    reference: descriptor.reference.clone(),
                });

        let authentication_data = value
            .authentication_data
            .clone()
            .map(router_request_types::AuthenticationData::try_from)
            .transpose()?;

        Ok(Self {
            mandate_reference: mandate_ref,
            amount,
            minor_amount: common_utils::types::MinorUnit::new(minor_amount),
            currency: common_enums::Currency::foreign_try_from(currency)?,
            merchant_order_reference_id,
            metadata: value
                .metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "metadata")))
                .transpose()?,
            webhook_url,
            router_return_url: value.return_url,
            integrity_object: None,
            capture_method: Some(CaptureMethod::foreign_try_from(capture_method)?),
            email,
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            payment_method_type,
            merchant_account_metadata: value
                .merchant_account_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
                .transpose()?,
            off_session: value.off_session,
            split_payments: None,
            recurring_mandate_payment_data: value.recurring_mandate_payment_data.map(|v| {
                RecurringMandatePaymentData {
                    payment_method_type: None,
                    original_payment_authorized_amount: v
                        .original_payment_authorized_amount
                        .map(common_utils::types::MinorUnit::new),
                    original_payment_authorized_currency: Some(
                        common_enums::Currency::foreign_try_from(
                            v.original_payment_authorized_currency(),
                        )
                        .unwrap_or_default(),
                    ),
                    mandate_metadata: None,
                }
            }),
            shipping_cost: value.shipping_cost.map(common_utils::types::MinorUnit::new),
            mit_category,
            billing_descriptor,
            enable_partial_authorization: value.enable_partial_authorization,
            payment_method_data,
            authentication_data,
            locale: value.locale.clone(),
            connector_testing_data: value.connector_testing_data.and_then(|s| {
                serde_json::from_str(&s.expose())
                    .ok()
                    .map(common_utils::pii::SecretSerdeValue::new)
            }),
            merchant_account_id: value.merchant_account_id,
            merchant_configured_currency,
        })
    }
}

pub fn generate_repeat_payment_response<T: PaymentMethodDataTypes>(
    router_data_v2: RouterDataV2<
        RepeatPayment,
        PaymentFlowData,
        RepeatPaymentData<T>,
        PaymentsResponseData,
    >,
) -> Result<
    grpc_api_types::payments::PaymentServiceRepeatEverythingResponse,
    error_stack::Report<ApplicationErrorResponse>,
> {
    let transaction_response = router_data_v2.response;
    let status = router_data_v2.resource_common_data.status;
    let grpc_status = grpc_api_types::payments::PaymentStatus::foreign_from(status);

    // Create state if either access token or connector customer is available
    let state = if router_data_v2.resource_common_data.access_token.is_some()
        || router_data_v2
            .resource_common_data
            .connector_customer
            .is_some()
    {
        Some(ConnectorState {
            access_token: router_data_v2
                .resource_common_data
                .access_token
                .as_ref()
                .map(|token_data| grpc_api_types::payments::AccessToken {
                    token: token_data.access_token.clone(),
                    expires_in_seconds: token_data.expires_in,
                    token_type: token_data.token_type.clone(),
                }),
            connector_customer_id: router_data_v2
                .resource_common_data
                .connector_customer
                .clone(),
        })
    } else {
        None
    };
    let raw_connector_response = router_data_v2
        .resource_common_data
        .get_raw_connector_response();

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    match transaction_response {
        Ok(response) => match response {
            PaymentsResponseData::TransactionResponse {
                resource_id,
                network_txn_id,
                connector_response_reference_id,
                connector_metadata,
                mandate_reference,
                status_code,
                incremental_authorization_allowed,
                ..
            } => Ok(
                grpc_api_types::payments::PaymentServiceRepeatEverythingResponse {
                    transaction_id: Some(grpc_api_types::payments::Identifier::foreign_try_from(
                        resource_id,
                    )?),
                    status: grpc_status as i32,
                    error_code: None,
                    error_message: None,
                    error_reason: None,
                    network_decline_code: None,
                    network_advice_code: None,
                    network_error_message: None,
                    network_txn_id,
                    response_ref_id: connector_response_reference_id.map(|id| {
                        grpc_api_types::payments::Identifier {
                            id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                        }
                    }),
                    connector_metadata: convert_connector_metadata_to_secret_string(
                        connector_metadata,
                    ),
                    mandate_reference: mandate_reference.map(|m| {
                        grpc_api_types::payments::MandateReference {
                            mandate_id: m.connector_mandate_id,
                            payment_method_id: m.payment_method_id,
                            connector_mandate_request_reference_id: m
                                .connector_mandate_request_reference_id,
                        }
                    }),
                    status_code: status_code as u32,
                    raw_connector_response,
                    response_headers: router_data_v2
                        .resource_common_data
                        .get_connector_response_headers_as_map(),
                    state,
                    raw_connector_request,
                    connector_response: router_data_v2
                        .resource_common_data
                        .connector_response
                        .and_then(|data| {
                            grpc_api_types::payments::ConnectorResponseData::foreign_try_from(data)
                                .ok()
                        }),
                    captured_amount: router_data_v2.resource_common_data.amount_captured,
                    minor_captured_amount: router_data_v2
                        .resource_common_data
                        .minor_amount_captured
                        .map(|amount_captured| amount_captured.get_amount_as_i64()),
                    incremental_authorization_allowed,
                },
            ),
            _ => Err(ApplicationErrorResponse::BadRequest(ApiError {
                sub_code: "INVALID_RESPONSE".to_owned(),
                error_identifier: 400,
                error_message: "Invalid response from connector".to_owned(),
                error_object: None,
            }))?,
        },
        Err(err) => {
            let status = match err.get_attempt_status_for_grpc(
                err.status_code,
                router_data_v2.resource_common_data.status,
            ) {
                Some(attempt_status) => {
                    grpc_api_types::payments::PaymentStatus::foreign_from(attempt_status)
                }
                None => grpc_api_types::payments::PaymentStatus::AttemptStatusUnspecified,
            };
            Ok(
                grpc_api_types::payments::PaymentServiceRepeatEverythingResponse {
                    transaction_id: err.connector_transaction_id.clone().map(|id| {
                        grpc_api_types::payments::Identifier {
                            id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                        }
                    }),
                    status: status as i32,
                    error_code: Some(err.code),
                    error_message: Some(err.message),
                    error_reason: err.reason,
                    network_decline_code: err.network_decline_code,
                    network_advice_code: err.network_advice_code,
                    network_error_message: err.network_error_message,
                    network_txn_id: None,
                    response_ref_id: err.connector_transaction_id.map(|id| {
                        grpc_api_types::payments::Identifier {
                            id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                        }
                    }),
                    connector_metadata: None,
                    raw_connector_response: None,
                    status_code: err.status_code as u32,
                    response_headers: router_data_v2
                        .resource_common_data
                        .get_connector_response_headers_as_map(),
                    state,
                    mandate_reference: None,
                    raw_connector_request,
                    connector_response: None,
                    captured_amount: None,
                    minor_captured_amount: None,
                    incremental_authorization_allowed: None,
                },
            )
        }
    }
}

impl From<&grpc_api_types::payments::AccessToken> for AccessTokenResponseData {
    fn from(token: &grpc_api_types::payments::AccessToken) -> Self {
        Self {
            access_token: token.token.clone(),
            token_type: token.token_type.clone(),
            expires_in: token.expires_in_seconds,
        }
    }
}

pub fn generate_payment_sdk_session_token_response(
    router_data_v2: RouterDataV2<
        SdkSessionToken,
        PaymentFlowData,
        PaymentsSdkSessionTokenData,
        PaymentsResponseData,
    >,
) -> Result<PaymentServiceSdkSessionTokenResponse, error_stack::Report<ApplicationErrorResponse>> {
    let transaction_response = router_data_v2.response;

    let raw_connector_request = router_data_v2
        .resource_common_data
        .get_raw_connector_request();

    let raw_connector_response = router_data_v2
        .resource_common_data
        .get_raw_connector_response();

    match transaction_response {
        Ok(response) => {
            match response {
                PaymentsResponseData::SdkSessionTokenResponse {
                    session_token,
                    status_code,
                } => {
                    let grpc_session_token = match session_token {
                        SessionToken::GooglePay(gpay_token) => {
                            let gpay_response = grpc_api_types::payments::GpaySessionTokenResponse::foreign_try_from(*gpay_token)?;
                            Some(grpc_api_types::payments::SessionToken {
                                wallet_name: Some(
                                    grpc_api_types::payments::session_token::WalletName::GooglePay(
                                        gpay_response,
                                    ),
                                ),
                            })
                        }
                        SessionToken::Paypal(paypal_token) => {
                            let paypal_response =
                            grpc_api_types::payments::PaypalSessionTokenResponse {
                                connector: paypal_token.connector,
                                session_token: paypal_token.session_token,
                                sdk_next_action: grpc_api_types::payments::SdkNextAction::from(
                                    paypal_token.sdk_next_action.next_action,
                                )
                                .into(),
                                client_token: paypal_token.client_token,
                                transaction_info: paypal_token.transaction_info.map(grpc_api_types::payments::PaypalTransactionInfo::foreign_try_from).transpose()?,
                            };
                            Some(grpc_api_types::payments::SessionToken {
                                wallet_name: Some(
                                    grpc_api_types::payments::session_token::WalletName::Paypal(
                                        paypal_response,
                                    ),
                                ),
                            })
                        }
                        SessionToken::ApplePay(apple_pay_token) => {
                            let apple_pay_response = grpc_api_types::payments::ApplepaySessionTokenResponse {
                            session_token_data: apple_pay_token.session_token_data.map(grpc_api_types::payments::ApplePaySessionResponse::foreign_try_from).transpose()?,
                            payment_request_data: apple_pay_token.payment_request_data.map(grpc_api_types::payments::ApplePayPaymentRequest::foreign_try_from).transpose()?,
                            connector: apple_pay_token.connector,
                            delayed_session_token: apple_pay_token.delayed_session_token,
                            sdk_next_action: grpc_api_types::payments::SdkNextAction::from(apple_pay_token.sdk_next_action.next_action).into(),
                            connector_reference_id: apple_pay_token.connector_reference_id,
                            connector_sdk_public_key: apple_pay_token.connector_sdk_public_key,
                            connector_merchant_id: apple_pay_token.connector_merchant_id,
                        };
                            Some(grpc_api_types::payments::SessionToken {
                                wallet_name: Some(
                                    grpc_api_types::payments::session_token::WalletName::ApplePay(
                                        apple_pay_response,
                                    ),
                                ),
                            })
                        }
                    };

                    Ok(PaymentServiceSdkSessionTokenResponse {
                        session_token: grpc_session_token,
                        error_message: None,
                        error_code: None,
                        error_reason: None,
                        raw_connector_response,
                        status_code: status_code as u32,
                        raw_connector_request,
                    })
                }
                _ => Err(report!(ApplicationErrorResponse::InternalServerError(
                    ApiError {
                        sub_code: "INVALID_RESPONSE_TYPE".to_owned(),
                        error_identifier: 500,
                        error_message: "Invalid response type received from connector".to_owned(),
                        error_object: None,
                    }
                ))),
            }
        }
        Err(e) => Ok(PaymentServiceSdkSessionTokenResponse {
            session_token: None,
            error_message: Some(e.message),
            error_code: Some(e.code),
            error_reason: e.reason,
            raw_connector_response,
            status_code: e.status_code as u32,
            raw_connector_request,
        }),
    }
}

impl From<NextActionCall> for grpc_api_types::payments::SdkNextAction {
    fn from(value: NextActionCall) -> Self {
        match value {
            NextActionCall::Confirm => Self::Confirm,
            NextActionCall::PostSessionTokens => Self::PostSessionTokens,
        }
    }
}

impl ForeignTryFrom<GpaySessionTokenResponse>
    for grpc_api_types::payments::GpaySessionTokenResponse
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: GpaySessionTokenResponse,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let gpay_session_token_response = match value {
            GpaySessionTokenResponse::GooglePaySession(session) => Self {
                google_pay_session: Some(grpc_api_types::payments::GooglePaySessionResponse {
                    merchant_info: Some(grpc_api_types::payments::GpayMerchantInfo {
                        merchant_id: session.merchant_info.merchant_id,
                        merchant_name: session.merchant_info.merchant_name,
                    }),
                    shipping_address_required: session.shipping_address_required,
                    email_required: session.email_required,
                    shipping_address_parameters: Some(
                        grpc_api_types::payments::GpayShippingAddressParameters {
                            phone_number_required: session
                                .shipping_address_parameters
                                .phone_number_required,
                        },
                    ),
                    allowed_payment_methods: session
                        .allowed_payment_methods
                        .into_iter()
                        .map(grpc_api_types::payments::GpayAllowedPaymentMethods::from)
                        .collect(),
                    transaction_info: Some(grpc_api_types::payments::GpayTransactionInfo {
                        country_code: grpc_api_types::payments::CountryAlpha2::foreign_try_from(
                            session.transaction_info.country_code,
                        )? as i32,
                        currency_code: grpc_api_types::payments::Currency::foreign_try_from(
                            session.transaction_info.currency_code,
                        )? as i32,
                        total_price_status: session.transaction_info.total_price_status,
                        total_price: session.transaction_info.total_price.get_amount_as_i64(),
                    }),
                    delayed_session_token: session.delayed_session_token,
                    connector: session.connector,
                    sdk_next_action: grpc_api_types::payments::SdkNextAction::from(
                        session.sdk_next_action.next_action,
                    )
                    .into(),
                    secrets: session.secrets.map(|s| {
                        grpc_api_types::payments::SecretInfoToInitiateSdk {
                            display: Some(s.display),
                            payment: s.payment,
                        }
                    }),
                }),
            },
        };
        Ok(gpay_session_token_response)
    }
}

impl From<GpayAllowedPaymentMethods> for grpc_api_types::payments::GpayAllowedPaymentMethods {
    fn from(value: GpayAllowedPaymentMethods) -> Self {
        Self {
            payment_method_type: value.payment_method_type,
            parameters: Some(grpc_api_types::payments::GpayAllowedMethodsParameters {
                allowed_auth_methods: value.parameters.allowed_auth_methods,
                allowed_card_networks: value.parameters.allowed_card_networks,
                billing_address_required: value.parameters.billing_address_required,
                billing_address_parameters: value.parameters.billing_address_parameters.map(|b| {
                    grpc_api_types::payments::GpayBillingAddressParameters {
                        phone_number_required: b.phone_number_required,
                        format: grpc_api_types::payments::GpayBillingAddressFormat::from(b.format)
                            as i32,
                    }
                }),
                assurance_details_required: value.parameters.assurance_details_required,
            }),
            tokenization_specification: Some(
                grpc_api_types::payments::GpayTokenizationSpecification {
                    token_specification_type: value
                        .tokenization_specification
                        .token_specification_type,
                    parameters: Some(grpc_api_types::payments::GpayTokenParameters {
                        gateway: value.tokenization_specification.parameters.gateway,
                        gateway_merchant_id: value
                            .tokenization_specification
                            .parameters
                            .gateway_merchant_id,
                        protocol_version: value
                            .tokenization_specification
                            .parameters
                            .protocol_version,
                        public_key: value.tokenization_specification.parameters.public_key,
                    }),
                },
            ),
        }
    }
}

impl From<GpayBillingAddressFormat> for grpc_api_types::payments::GpayBillingAddressFormat {
    fn from(value: GpayBillingAddressFormat) -> Self {
        match value {
            GpayBillingAddressFormat::MIN => Self::Min,
            GpayBillingAddressFormat::FULL => Self::Full,
        }
    }
}

impl ForeignTryFrom<ApplePaySessionResponse> for grpc_api_types::payments::ApplePaySessionResponse {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: ApplePaySessionResponse,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let third_party_sdk = match value {
            ApplePaySessionResponse::ThirdPartySdk(third_party) => {
                grpc_api_types::payments::ThirdPartySdkSessionResponse {
                    secrets: Some(grpc_api_types::payments::SecretInfoToInitiateSdk {
                        display: Some(third_party.secrets.display),
                        payment: third_party.secrets.payment,
                    }),
                }
            }
        };
        Ok(Self {
            third_party_sdk: Some(third_party_sdk),
        })
    }
}

impl ForeignTryFrom<ApplePayPaymentRequest> for grpc_api_types::payments::ApplePayPaymentRequest {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: ApplePayPaymentRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let country_code =
            grpc_api_types::payments::CountryAlpha2::foreign_try_from(value.country_code)?;
        let currency_code =
            grpc_api_types::payments::Currency::foreign_try_from(value.currency_code)?;

        Ok(Self {
            country_code: country_code as i32,
            currency_code: currency_code as i32,
            total: Some(grpc_api_types::payments::AmountInfo {
                label: value.total.label,
                total_type: value.total.total_type,
                amount: value.total.amount.get_amount_as_i64(),
            }),
            merchant_capabilities: value.merchant_capabilities.unwrap_or_default(),
            supported_networks: value.supported_networks.unwrap_or_default(),
            merchant_identifier: value.merchant_identifier,
        })
    }
}

impl ForeignTryFrom<PaypalTransactionInfo> for grpc_api_types::payments::PaypalTransactionInfo {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: PaypalTransactionInfo,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let currency_code =
            grpc_api_types::payments::Currency::foreign_try_from(value.currency_code)?;

        let flow = match value.flow {
            PaypalFlow::Checkout => grpc_api_types::payments::PaypalFlow::Checkout,
        };

        Ok(Self {
            flow: flow as i32,
            currency_code: currency_code as i32,
            total_price: value.total_price.get_amount_as_i64(),
        })
    }
}

impl ForeignTryFrom<grpc_api_types::payments::BankNames> for common_enums::BankNames {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::BankNames,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        match value {
            grpc_api_types::payments::BankNames::Unspecified => {
                Err(report!(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "UNSPECIFIED_BANK_NAME".to_owned(),
                    error_identifier: 401,
                    error_message: "Bank name must be specified".to_owned(),
                    error_object: None,
                })))
            }
            grpc_api_types::payments::BankNames::AmericanExpress => Ok(Self::AmericanExpress),
            grpc_api_types::payments::BankNames::AffinBank => Ok(Self::AffinBank),
            grpc_api_types::payments::BankNames::AgroBank => Ok(Self::AgroBank),
            grpc_api_types::payments::BankNames::AllianceBank => Ok(Self::AllianceBank),
            grpc_api_types::payments::BankNames::AmBank => Ok(Self::AmBank),
            grpc_api_types::payments::BankNames::BankOfAmerica => Ok(Self::BankOfAmerica),
            grpc_api_types::payments::BankNames::BankOfChina => Ok(Self::BankOfChina),
            grpc_api_types::payments::BankNames::BankIslam => Ok(Self::BankIslam),
            grpc_api_types::payments::BankNames::BankMuamalat => Ok(Self::BankMuamalat),
            grpc_api_types::payments::BankNames::BankRakyat => Ok(Self::BankRakyat),
            grpc_api_types::payments::BankNames::BankSimpananNasional => {
                Ok(Self::BankSimpananNasional)
            }
            grpc_api_types::payments::BankNames::Barclays => Ok(Self::Barclays),
            grpc_api_types::payments::BankNames::BlikPsp => Ok(Self::BlikPSP),
            grpc_api_types::payments::BankNames::CapitalOne => Ok(Self::CapitalOne),
            grpc_api_types::payments::BankNames::Chase => Ok(Self::Chase),
            grpc_api_types::payments::BankNames::Citi => Ok(Self::Citi),
            grpc_api_types::payments::BankNames::CimbBank => Ok(Self::CimbBank),
            grpc_api_types::payments::BankNames::Discover => Ok(Self::Discover),
            grpc_api_types::payments::BankNames::NavyFederalCreditUnion => {
                Ok(Self::NavyFederalCreditUnion)
            }
            grpc_api_types::payments::BankNames::PentagonFederalCreditUnion => {
                Ok(Self::PentagonFederalCreditUnion)
            }
            grpc_api_types::payments::BankNames::SynchronyBank => Ok(Self::SynchronyBank),
            grpc_api_types::payments::BankNames::WellsFargo => Ok(Self::WellsFargo),
            grpc_api_types::payments::BankNames::AbnAmro => Ok(Self::AbnAmro),
            grpc_api_types::payments::BankNames::AsnBank => Ok(Self::AsnBank),
            grpc_api_types::payments::BankNames::Bunq => Ok(Self::Bunq),
            grpc_api_types::payments::BankNames::Handelsbanken => Ok(Self::Handelsbanken),
            grpc_api_types::payments::BankNames::HongLeongBank => Ok(Self::HongLeongBank),
            grpc_api_types::payments::BankNames::HsbcBank => Ok(Self::HsbcBank),
            grpc_api_types::payments::BankNames::Ing => Ok(Self::Ing),
            grpc_api_types::payments::BankNames::Knab => Ok(Self::Knab),
            grpc_api_types::payments::BankNames::KuwaitFinanceHouse => Ok(Self::KuwaitFinanceHouse),
            grpc_api_types::payments::BankNames::Moneyou => Ok(Self::Moneyou),
            grpc_api_types::payments::BankNames::Rabobank => Ok(Self::Rabobank),
            grpc_api_types::payments::BankNames::Regiobank => Ok(Self::Regiobank),
            grpc_api_types::payments::BankNames::Revolut => Ok(Self::Revolut),
            grpc_api_types::payments::BankNames::SnsBank => Ok(Self::SnsBank),
            grpc_api_types::payments::BankNames::TriodosBank => Ok(Self::TriodosBank),
            grpc_api_types::payments::BankNames::VanLanschot => Ok(Self::VanLanschot),
            grpc_api_types::payments::BankNames::ArzteUndApothekerBank => {
                Ok(Self::ArzteUndApothekerBank)
            }
            grpc_api_types::payments::BankNames::AustrianAnadiBankAg => {
                Ok(Self::AustrianAnadiBankAg)
            }
            grpc_api_types::payments::BankNames::BankAustria => Ok(Self::BankAustria),
            grpc_api_types::payments::BankNames::Bank99Ag => Ok(Self::Bank99Ag),
            grpc_api_types::payments::BankNames::BankhausCarlSpangler => {
                Ok(Self::BankhausCarlSpangler)
            }
            grpc_api_types::payments::BankNames::BankhausSchelhammerUndSchatteraAg => {
                Ok(Self::BankhausSchelhammerUndSchatteraAg)
            }
            grpc_api_types::payments::BankNames::BankMillennium => Ok(Self::BankMillennium),
            grpc_api_types::payments::BankNames::BawagPskAg => Ok(Self::BawagPskAg),
            grpc_api_types::payments::BankNames::BksBankAg => Ok(Self::BksBankAg),
            grpc_api_types::payments::BankNames::BrullKallmusBankAg => Ok(Self::BrullKallmusBankAg),
            grpc_api_types::payments::BankNames::BtvVierLanderBank => Ok(Self::BtvVierLanderBank),
            grpc_api_types::payments::BankNames::CapitalBankGraweGruppeAg => {
                Ok(Self::CapitalBankGraweGruppeAg)
            }
            grpc_api_types::payments::BankNames::CeskaSporitelna => Ok(Self::CeskaSporitelna),
            grpc_api_types::payments::BankNames::Dolomitenbank => Ok(Self::Dolomitenbank),
            grpc_api_types::payments::BankNames::EasybankAg => Ok(Self::EasybankAg),
            grpc_api_types::payments::BankNames::EPlatbyVub => Ok(Self::EPlatbyVUB),
            grpc_api_types::payments::BankNames::ErsteBankUndSparkassen => {
                Ok(Self::ErsteBankUndSparkassen)
            }
            grpc_api_types::payments::BankNames::FrieslandBank => Ok(Self::FrieslandBank),
            grpc_api_types::payments::BankNames::HypoAlpeadriabankInternationalAg => {
                Ok(Self::HypoAlpeadriabankInternationalAg)
            }
            grpc_api_types::payments::BankNames::HypoNoeLbFurNiederosterreichUWien => {
                Ok(Self::HypoNoeLbFurNiederosterreichUWien)
            }
            grpc_api_types::payments::BankNames::HypoOberosterreichSalzburgSteiermark => {
                Ok(Self::HypoOberosterreichSalzburgSteiermark)
            }
            grpc_api_types::payments::BankNames::HypoTirolBankAg => Ok(Self::HypoTirolBankAg),
            grpc_api_types::payments::BankNames::HypoVorarlbergBankAg => {
                Ok(Self::HypoVorarlbergBankAg)
            }
            grpc_api_types::payments::BankNames::HypoBankBurgenlandAktiengesellschaft => {
                Ok(Self::HypoBankBurgenlandAktiengesellschaft)
            }
            grpc_api_types::payments::BankNames::KomercniBanka => Ok(Self::KomercniBanka),
            grpc_api_types::payments::BankNames::MBank => Ok(Self::MBank),
            grpc_api_types::payments::BankNames::MarchfelderBank => Ok(Self::MarchfelderBank),
            grpc_api_types::payments::BankNames::Maybank => Ok(Self::Maybank),
            grpc_api_types::payments::BankNames::OberbankAg => Ok(Self::OberbankAg),
            grpc_api_types::payments::BankNames::OsterreichischeArzteUndApothekerbank => {
                Ok(Self::OsterreichischeArzteUndApothekerbank)
            }
            grpc_api_types::payments::BankNames::OcbcBank => Ok(Self::OcbcBank),
            grpc_api_types::payments::BankNames::PayWithIng => Ok(Self::PayWithING),
            grpc_api_types::payments::BankNames::PlaceZipko => Ok(Self::PlaceZIPKO),
            grpc_api_types::payments::BankNames::PlatnoscOnlineKartaPlatnicza => {
                Ok(Self::PlatnoscOnlineKartaPlatnicza)
            }
            grpc_api_types::payments::BankNames::PosojilnicaBankEGen => {
                Ok(Self::PosojilnicaBankEGen)
            }
            grpc_api_types::payments::BankNames::PostovaBanka => Ok(Self::PostovaBanka),
            grpc_api_types::payments::BankNames::PublicBank => Ok(Self::PublicBank),
            grpc_api_types::payments::BankNames::RaiffeisenBankengruppeOsterreich => {
                Ok(Self::RaiffeisenBankengruppeOsterreich)
            }
            grpc_api_types::payments::BankNames::RhbBank => Ok(Self::RhbBank),
            grpc_api_types::payments::BankNames::SchelhammerCapitalBankAg => {
                Ok(Self::SchelhammerCapitalBankAg)
            }
            grpc_api_types::payments::BankNames::StandardCharteredBank => {
                Ok(Self::StandardCharteredBank)
            }
            grpc_api_types::payments::BankNames::SchoellerbankAg => Ok(Self::SchoellerbankAg),
            grpc_api_types::payments::BankNames::SpardaBankWien => Ok(Self::SpardaBankWien),
            grpc_api_types::payments::BankNames::SporoPay => Ok(Self::SporoPay),
            grpc_api_types::payments::BankNames::SantanderPrzelew24 => Ok(Self::SantanderPrzelew24),
            grpc_api_types::payments::BankNames::TatraPay => Ok(Self::TatraPay),
            grpc_api_types::payments::BankNames::Viamo => Ok(Self::Viamo),
            grpc_api_types::payments::BankNames::VolksbankGruppe => Ok(Self::VolksbankGruppe),
            grpc_api_types::payments::BankNames::VolkskreditbankAg => Ok(Self::VolkskreditbankAg),
            grpc_api_types::payments::BankNames::VrBankBraunau => Ok(Self::VrBankBraunau),
            grpc_api_types::payments::BankNames::UobBank => Ok(Self::UobBank),
            grpc_api_types::payments::BankNames::PayWithAliorBank => Ok(Self::PayWithAliorBank),
            grpc_api_types::payments::BankNames::BankiSpoldzielcze => Ok(Self::BankiSpoldzielcze),
            grpc_api_types::payments::BankNames::PayWithInteligo => Ok(Self::PayWithInteligo),
            grpc_api_types::payments::BankNames::BnpParibasPoland => Ok(Self::BNPParibasPoland),
            grpc_api_types::payments::BankNames::BankNowySa => Ok(Self::BankNowySA),
            grpc_api_types::payments::BankNames::CreditAgricole => Ok(Self::CreditAgricole),
            grpc_api_types::payments::BankNames::PayWithBos => Ok(Self::PayWithBOS),
            grpc_api_types::payments::BankNames::PayWithCitiHandlowy => {
                Ok(Self::PayWithCitiHandlowy)
            }
            grpc_api_types::payments::BankNames::PayWithPlusBank => Ok(Self::PayWithPlusBank),
            grpc_api_types::payments::BankNames::ToyotaBank => Ok(Self::ToyotaBank),
            grpc_api_types::payments::BankNames::VeloBank => Ok(Self::VeloBank),
            grpc_api_types::payments::BankNames::ETransferPocztowy24 => {
                Ok(Self::ETransferPocztowy24)
            }
            grpc_api_types::payments::BankNames::PlusBank => Ok(Self::PlusBank),
            grpc_api_types::payments::BankNames::BankiSpbdzielcze => Ok(Self::BankiSpbdzielcze),
            grpc_api_types::payments::BankNames::BankNowyBfgSa => Ok(Self::BankNowyBfgSa),
            grpc_api_types::payments::BankNames::GetinBank => Ok(Self::GetinBank),
            grpc_api_types::payments::BankNames::BlikPoland => Ok(Self::Blik),
            grpc_api_types::payments::BankNames::NoblePay => Ok(Self::NoblePay),
            grpc_api_types::payments::BankNames::IdeaBank => Ok(Self::IdeaBank),
            grpc_api_types::payments::BankNames::EnveloBank => Ok(Self::EnveloBank),
            grpc_api_types::payments::BankNames::NestPrzelew => Ok(Self::NestPrzelew),
            grpc_api_types::payments::BankNames::MbankMtransfer => Ok(Self::MbankMtransfer),
            grpc_api_types::payments::BankNames::Inteligo => Ok(Self::Inteligo),
            grpc_api_types::payments::BankNames::PbacZIpko => Ok(Self::PbacZIpko),
            grpc_api_types::payments::BankNames::BnpParibas => Ok(Self::BnpParibas),
            grpc_api_types::payments::BankNames::BankPekaoSa => Ok(Self::BankPekaoSa),
            grpc_api_types::payments::BankNames::VolkswagenBank => Ok(Self::VolkswagenBank),
            grpc_api_types::payments::BankNames::AliorBank => Ok(Self::AliorBank),
            grpc_api_types::payments::BankNames::Boz => Ok(Self::Boz),
            grpc_api_types::payments::BankNames::BangkokBank => Ok(Self::BangkokBank),
            grpc_api_types::payments::BankNames::KrungsriBank => Ok(Self::KrungsriBank),
            grpc_api_types::payments::BankNames::KrungThaiBank => Ok(Self::KrungThaiBank),
            grpc_api_types::payments::BankNames::TheSiamCommercialBank => {
                Ok(Self::TheSiamCommercialBank)
            }
            grpc_api_types::payments::BankNames::KasikornBank => Ok(Self::KasikornBank),
            grpc_api_types::payments::BankNames::OpenBankSuccess => Ok(Self::OpenBankSuccess),
            grpc_api_types::payments::BankNames::OpenBankFailure => Ok(Self::OpenBankFailure),
            grpc_api_types::payments::BankNames::OpenBankCancelled => Ok(Self::OpenBankCancelled),
            grpc_api_types::payments::BankNames::Aib => Ok(Self::Aib),
            grpc_api_types::payments::BankNames::BankOfScotland => Ok(Self::BankOfScotland),
            grpc_api_types::payments::BankNames::DanskeBank => Ok(Self::DanskeBank),
            grpc_api_types::payments::BankNames::FirstDirect => Ok(Self::FirstDirect),
            grpc_api_types::payments::BankNames::FirstTrust => Ok(Self::FirstTrust),
            grpc_api_types::payments::BankNames::Halifax => Ok(Self::Halifax),
            grpc_api_types::payments::BankNames::Lloyds => Ok(Self::Lloyds),
            grpc_api_types::payments::BankNames::Monzo => Ok(Self::Monzo),
            grpc_api_types::payments::BankNames::NatWest => Ok(Self::NatWest),
            grpc_api_types::payments::BankNames::NationwideBank => Ok(Self::NationwideBank),
            grpc_api_types::payments::BankNames::RoyalBankOfScotland => {
                Ok(Self::RoyalBankOfScotland)
            }
            grpc_api_types::payments::BankNames::Starling => Ok(Self::Starling),
            grpc_api_types::payments::BankNames::TsbBank => Ok(Self::TsbBank),
            grpc_api_types::payments::BankNames::TescoBank => Ok(Self::TescoBank),
            grpc_api_types::payments::BankNames::UlsterBank => Ok(Self::UlsterBank),
            grpc_api_types::payments::BankNames::Yoursafe => Ok(Self::Yoursafe),
            grpc_api_types::payments::BankNames::N26 => Ok(Self::N26),
            grpc_api_types::payments::BankNames::NationaleNederlanden => {
                Ok(Self::NationaleNederlanden)
            }
        }
    }
}

// New ForeignTryFrom implementations for individual 3DS authentication flow proto definitions

impl<
        T: PaymentMethodDataTypes
            + Default
            + Debug
            + Send
            + Eq
            + PartialEq
            + Serialize
            + serde::de::DeserializeOwned
            + Clone
            + CardConversionHelper<T>,
    > ForeignTryFrom<grpc_api_types::payments::PaymentServicePreAuthenticateRequest>
    for PaymentsPreAuthenticateData<T>
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServicePreAuthenticateRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let email: Option<Email> = match value.email {
            Some(ref email_str) => {
                Some(Email::try_from(email_str.clone().expose()).map_err(|_| {
                    error_stack::Report::new(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_EMAIL_FORMAT".to_owned(),
                        error_identifier: 400,
                        error_message: "Invalid email".to_owned(),
                        error_object: None,
                    }))
                })?)
            }
            None => None,
        };

        let minor_amount = common_utils::types::MinorUnit::new(value.minor_amount);
        let currency = common_enums::Currency::foreign_try_from(value.currency())?;
        let return_url = value.return_url;
        let enrolled_for_3ds = value.enrolled_for_3ds;

        // Clone payment_method to avoid ownership issues
        let payment_method_clone = value.payment_method.clone();

        // Create redirect response from metadata if present
        // This is used to pass connector-specific data (e.g., collectionReference for Worldpay)
        let redirect_response = if value.metadata.is_some() {
            let params_string = serde_urlencoded::to_string(&value.metadata).change_context(
                ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_METADATA".to_owned(),
                    error_identifier: 400,
                    error_message: "Failed to serialize metadata".to_owned(),
                    error_object: None,
                }),
            )?;
            Some(ContinueRedirectionResponse {
                params: Some(Secret::new(params_string)),
                payload: None,
            })
        } else {
            None
        };

        Ok(Self {
            payment_method_data: value
                .payment_method
                .map(PaymentMethodData::<T>::foreign_try_from)
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                    error_identifier: 400,
                    error_message: "Payment method data construction failed".to_owned(),
                    error_object: None,
                }))?,
            amount: minor_amount,
            email,
            currency: Some(currency),
            payment_method_type: <Option<PaymentMethodType>>::foreign_try_from(
                payment_method_clone.unwrap_or_default(),
            )?,
            continue_redirection_url: value
                .continue_redirection_url
                .map(|url_str| {
                    url::Url::parse(&url_str).change_context(ApplicationErrorResponse::BadRequest(
                        ApiError {
                            sub_code: "INVALID_URL".to_owned(),
                            error_identifier: 400,
                            error_message: "Invalid continue redirection URL".to_owned(),
                            error_object: None,
                        },
                    ))
                })
                .transpose()?,
            router_return_url: return_url
                .map(|url_str| {
                    url::Url::parse(&url_str).change_context(ApplicationErrorResponse::BadRequest(
                        ApiError {
                            sub_code: "INVALID_URL".to_owned(),
                            error_identifier: 400,
                            error_message: "Invalid router return URL".to_owned(),
                            error_object: None,
                        },
                    ))
                })
                .transpose()?,
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            enrolled_for_3ds,
            redirect_response,
            capture_method: value
                .capture_method
                .map(|cm| {
                    CaptureMethod::foreign_try_from(
                        grpc_api_types::payments::CaptureMethod::try_from(cm).unwrap_or_default(),
                    )
                })
                .transpose()?,
            mandate_reference: None,
        })
    }
}

impl<
        T: PaymentMethodDataTypes
            + Default
            + Debug
            + Send
            + Eq
            + PartialEq
            + Serialize
            + serde::de::DeserializeOwned
            + Clone
            + CardConversionHelper<T>,
    > ForeignTryFrom<grpc_api_types::payments::PaymentServiceAuthenticateRequest>
    for PaymentsAuthenticateData<T>
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServiceAuthenticateRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let email: Option<Email> = match value.email {
            Some(ref email_str) => {
                Some(Email::try_from(email_str.clone().expose()).map_err(|_| {
                    error_stack::Report::new(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_EMAIL_FORMAT".to_owned(),
                        error_identifier: 400,
                        error_message: "Invalid email".to_owned(),
                        error_object: None,
                    }))
                })?)
            }
            None => None,
        };

        let minor_amount = common_utils::types::MinorUnit::new(value.minor_amount);
        let currency = common_enums::Currency::foreign_try_from(value.currency())?;
        let return_url = value.return_url;

        // Clone payment_method to avoid ownership issues
        let payment_method_clone = value.payment_method.clone();

        let redirect_response =
            value
                .redirection_response
                .map(|redirection_response| ContinueRedirectionResponse {
                    params: redirection_response.params.map(Secret::new),
                    payload: Some(Secret::new(serde_json::Value::Object(
                        redirection_response
                            .payload
                            .into_iter()
                            .map(|(k, v)| (k, serde_json::Value::String(v)))
                            .collect(),
                    ))),
                });

        Ok(Self {
            payment_method_data: value
                .payment_method
                .map(PaymentMethodData::<T>::foreign_try_from)
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                    error_identifier: 400,
                    error_message: "Payment method data construction failed".to_owned(),
                    error_object: None,
                }))?,
            amount: minor_amount,
            email,
            currency: Some(currency),
            payment_method_type: <Option<PaymentMethodType>>::foreign_try_from(
                payment_method_clone.unwrap_or_default(),
            )?,
            router_return_url: return_url
                .map(|url_str| {
                    url::Url::parse(&url_str).change_context(ApplicationErrorResponse::BadRequest(
                        ApiError {
                            sub_code: "INVALID_URL".to_owned(),
                            error_identifier: 400,
                            error_message: "Invalid router return URL".to_owned(),
                            error_object: None,
                        },
                    ))
                })
                .transpose()?,
            continue_redirection_url: value
                .continue_redirection_url
                .map(|url_str| {
                    url::Url::parse(&url_str).change_context(ApplicationErrorResponse::BadRequest(
                        ApiError {
                            sub_code: "INVALID_URL".to_owned(),
                            error_identifier: 400,
                            error_message: "Invalid continue redirection URL".to_owned(),
                            error_object: None,
                        },
                    ))
                })
                .transpose()?,
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            enrolled_for_3ds: false,
            redirect_response,
            capture_method: value
                .capture_method
                .map(|cm| {
                    CaptureMethod::foreign_try_from(
                        grpc_api_types::payments::CaptureMethod::try_from(cm).unwrap_or_default(),
                    )
                })
                .transpose()?,
            authentication_data: value
                .authentication_data
                .map(router_request_types::AuthenticationData::try_from)
                .transpose()?,
        })
    }
}

impl<
        T: PaymentMethodDataTypes
            + Default
            + Debug
            + Send
            + Eq
            + PartialEq
            + Serialize
            + serde::de::DeserializeOwned
            + Clone
            + CardConversionHelper<T>,
    > ForeignTryFrom<grpc_api_types::payments::PaymentServicePostAuthenticateRequest>
    for PaymentsPostAuthenticateData<T>
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: grpc_api_types::payments::PaymentServicePostAuthenticateRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let email: Option<Email> = match value.email {
            Some(ref email_str) => {
                Some(Email::try_from(email_str.clone().expose()).map_err(|_| {
                    error_stack::Report::new(ApplicationErrorResponse::BadRequest(ApiError {
                        sub_code: "INVALID_EMAIL_FORMAT".to_owned(),
                        error_identifier: 400,
                        error_message: "Invalid email".to_owned(),
                        error_object: None,
                    }))
                })?)
            }
            None => None,
        };

        let minor_amount = common_utils::types::MinorUnit::new(value.minor_amount);
        let currency = common_enums::Currency::foreign_try_from(value.currency())?;
        let return_url = value.return_url;

        // Clone payment_method to avoid ownership issues
        let payment_method_clone = value.payment_method.clone();

        let redirect_response =
            value
                .redirection_response
                .map(|redirection_response| ContinueRedirectionResponse {
                    params: redirection_response.params.map(Secret::new),
                    payload: Some(Secret::new(serde_json::Value::Object(
                        redirection_response
                            .payload
                            .into_iter()
                            .map(|(k, v)| (k, serde_json::Value::String(v)))
                            .collect(),
                    ))),
                });
        Ok(Self {
            payment_method_data: value
                .payment_method
                .map(PaymentMethodData::<T>::foreign_try_from)
                .transpose()
                .change_context(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_PAYMENT_METHOD_DATA".to_owned(),
                    error_identifier: 400,
                    error_message: "Payment method data construction failed".to_owned(),
                    error_object: None,
                }))?,
            amount: minor_amount,
            email,
            currency: Some(currency),
            payment_method_type: <Option<PaymentMethodType>>::foreign_try_from(
                payment_method_clone.unwrap_or_default(),
            )?,
            router_return_url: return_url
                .map(|url_str| {
                    url::Url::parse(&url_str).change_context(ApplicationErrorResponse::BadRequest(
                        ApiError {
                            sub_code: "INVALID_URL".to_owned(),
                            error_identifier: 400,
                            error_message: "Invalid router return URL".to_owned(),
                            error_object: None,
                        },
                    ))
                })
                .transpose()?,
            continue_redirection_url: value
                .continue_redirection_url
                .map(|url_str| {
                    url::Url::parse(&url_str).change_context(ApplicationErrorResponse::BadRequest(
                        ApiError {
                            sub_code: "INVALID_URL".to_owned(),
                            error_identifier: 400,
                            error_message: "Invalid continue redirection URL".to_owned(),
                            error_object: None,
                        },
                    ))
                })
                .transpose()?,
            browser_info: value
                .browser_info
                .map(BrowserInformation::foreign_try_from)
                .transpose()?,
            enrolled_for_3ds: false,
            redirect_response,
        })
    }
}

// PaymentFlowData implementations for new proto definitions

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServicePreAuthenticateRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServicePreAuthenticateRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let address = match value.address {
            Some(address) => PaymentAddress::foreign_try_from(address)?,
            None => {
                return Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_ADDRESS".to_owned(),
                    error_identifier: 400,
                    error_message: "Address is required".to_owned(),
                    error_object: None,
                }))?
            }
        };

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;
        let vault_headers = extract_headers_from_metadata(metadata);

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::foreign_try_from(
                value.payment_method.unwrap_or_default(),
            )?,
            address,
            auth_type: common_enums::AuthenticationType::ThreeDs, // Pre-auth typically uses 3DS
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description: value.description,
            return_url: value.return_url.clone(),
            connector_meta_data: value
                .merchant_account_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
                .transpose()?,
            amount_captured: None,
            minor_amount_captured: None,
            minor_amount_capturable: None,
            access_token: None,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: None,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            connector_response_headers: None,
            vault_headers,
            raw_connector_request: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServiceAuthenticateRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServiceAuthenticateRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let address = match &value.address {
            Some(address_value) => PaymentAddress::foreign_try_from((*address_value).clone())?,
            None => {
                return Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_ADDRESS".to_owned(),
                    error_identifier: 400,
                    error_message: "Address is required".to_owned(),
                    error_object: None,
                }))?
            }
        };

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;
        let vault_headers = extract_headers_from_metadata(metadata);

        let metadata = value
            .metadata
            .map(|m| SecretSerdeValue::foreign_try_from((m, "metadata")))
            .transpose()?;
        let description = metadata
            .as_ref()
            .and_then(|m| m.peek().get("description"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::foreign_try_from(
                value.payment_method.unwrap_or_default(),
            )?,
            address,
            auth_type: common_enums::AuthenticationType::ThreeDs, // Auth step uses 3DS
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description,
            return_url: value.return_url.clone(),
            connector_meta_data: value
                .merchant_account_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
                .transpose()?,
            amount_captured: None,
            minor_amount_captured: None,
            access_token: None,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: None,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            connector_response_headers: None,
            vault_headers,
            raw_connector_request: None,
            minor_amount_capturable: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl
    ForeignTryFrom<(
        grpc_api_types::payments::PaymentServicePostAuthenticateRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            grpc_api_types::payments::PaymentServicePostAuthenticateRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let address = match &value.address {
            Some(address_value) => PaymentAddress::foreign_try_from((*address_value).clone())?,
            None => {
                return Err(ApplicationErrorResponse::BadRequest(ApiError {
                    sub_code: "INVALID_ADDRESS".to_owned(),
                    error_identifier: 400,
                    error_message: "Address is required".to_owned(),
                    error_object: None,
                }))?
            }
        };

        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;
        let vault_headers = extract_headers_from_metadata(metadata);

        let access_token = value
            .state
            .as_ref()
            .and_then(|state| state.access_token.as_ref())
            .map(AccessTokenResponseData::from);

        let metadata = value
            .metadata
            .map(|m| SecretSerdeValue::foreign_try_from((m, "metadata")))
            .transpose()?;
        let description = metadata
            .as_ref()
            .and_then(|m| m.peek().get("description"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "IRRELEVANT_PAYMENT_ID".to_string(),
            attempt_id: "IRRELEVANT_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: PaymentMethod::foreign_try_from(
                value.payment_method.unwrap_or_default(),
            )?,
            address,
            auth_type: common_enums::AuthenticationType::ThreeDs, // Post-auth uses 3DS
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description,
            return_url: value.return_url.clone(),
            connector_meta_data: value
                .merchant_account_metadata
                .map(|m| ForeignTryFrom::foreign_try_from((m, "merchant account metadata")))
                .transpose()?,
            amount_captured: None,
            minor_amount_captured: None,
            access_token,
            session_token: None,
            reference_id: value.connector_order_reference_id.clone(),
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: None,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            connector_response_headers: None,
            vault_headers,
            raw_connector_request: None,
            minor_amount_capturable: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

// Conversion implementations for MandateRevoke flow
impl ForeignTryFrom<PaymentServiceRevokeMandateRequest> for MandateRevokeRequestData {
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        value: PaymentServiceRevokeMandateRequest,
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            mandate_id: Secret::new(value.mandate_id),
            connector_mandate_id: value.connector_mandate_id.map(Secret::new),
            payment_method_type: None,
        })
    }
}

impl
    ForeignTryFrom<(
        PaymentServiceRevokeMandateRequest,
        Connectors,
        &MaskedMetadata,
    )> for PaymentFlowData
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (value, connectors, metadata): (
            PaymentServiceRevokeMandateRequest,
            Connectors,
            &MaskedMetadata,
        ),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        let merchant_id_from_header = extract_merchant_id_from_metadata(metadata)?;

        Ok(Self {
            merchant_id: merchant_id_from_header,
            payment_id: "MANDATE_REVOKE_ID".to_string(),
            attempt_id: "MANDATE_REVOKE_ATTEMPT_ID".to_string(),
            status: common_enums::AttemptStatus::Pending,
            payment_method: common_enums::PaymentMethod::Card, // Default for mandate operations
            address: PaymentAddress::default(),
            auth_type: common_enums::AuthenticationType::default(),
            connector_request_reference_id: extract_connector_request_reference_id(
                &value.request_ref_id,
            ),
            customer_id: None,
            connector_customer: None,
            description: Some("Mandate revoke operation".to_string()),
            return_url: None,
            connector_meta_data: None,
            amount_captured: None,
            minor_amount_captured: None,
            access_token: None,
            session_token: None,
            reference_id: None,
            payment_method_token: None,
            preprocessing_id: None,
            connector_api_version: None,
            test_mode: None,
            connector_http_status_code: None,
            external_latency: None,
            connectors,
            raw_connector_response: None,
            raw_connector_request: None,
            connector_response_headers: None,
            vault_headers: None,
            minor_amount_capturable: None,
            connector_response: None,
            recurring_mandate_payment_data: None,
            order_details: None,
            minor_amount_authorized: None,
        })
    }
}

impl ForeignTryFrom<(bool, RedirectDetailsResponse)>
    for grpc_api_types::payments::PaymentServiceVerifyRedirectResponseResponse
{
    type Error = ApplicationErrorResponse;

    fn foreign_try_from(
        (source_verified, redirect_details_response): (bool, RedirectDetailsResponse),
    ) -> Result<Self, error_stack::Report<Self::Error>> {
        Ok(Self {
            source_verified,
            transaction_id: redirect_details_response
                .resource_id
                .map(|resource_id| {
                    grpc_api_types::payments::Identifier::foreign_try_from(resource_id)
                })
                .transpose()?,
            response_ref_id: redirect_details_response
                .connector_response_reference_id
                .map(|id| grpc_api_types::payments::Identifier {
                    id_type: Some(grpc_api_types::payments::identifier::IdType::Id(id)),
                }),
            response_minor_amount: redirect_details_response
                .response_minor_amount
                .map(|amount| amount.get_amount_as_i64()),
            response_currency: redirect_details_response
                .response_currency
                .map(grpc_api_types::payments::Currency::foreign_try_from)
                .transpose()?
                .map(|currency| currency.into()),
            status: redirect_details_response
                .status
                .map(grpc_api_types::payments::PaymentStatus::foreign_from)
                .map(|status| status as i32),
            error_code: redirect_details_response.error_code,
            error_reason: redirect_details_response.error_reason,
            error_message: redirect_details_response.error_message,
            raw_connector_response: redirect_details_response
                .raw_connector_response
                .map(|response| response.into()),
        })
    }
}
