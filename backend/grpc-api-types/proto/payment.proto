// Copyright (c) Juspay Technologies. All rights reserved.
//
// Package: ucs.v2
// File: payment.proto
//
// Overview:
//   This file defines the core data types, enumerations, and request/response
//   messages used across the Unified Connector Service (UCS) v2 API.
//
//   It is imported by services.proto, which defines the gRPC service interfaces
//   (PaymentService, RefundService, DisputeService). Consumers of the API
//   should treat services.proto as the entry point and this file as the
//   shared type library.
//
// Key Concepts:
//   - Money:         All monetary amounts are represented in minor currency units
//                   (e.g., 1000 = $10.00 USD). See the Money message.
//   - SecretString:  A wrapper type (defined in payment_methods.proto) used for
//                   fields that contain sensitive data such as card numbers, CVVs,
//                   email addresses, and tokens. These values are masked in logs
//                   and traces. Treat them as you would any PII or credential.
//   - Identifier:   A oneof used to represent a connector transaction ID. Use
//                   the `id` variant for a plain string ID, `encoded_data` for
//                   an opaque/encoded reference, and `no_response_id_marker` when
//                   the connector returns no ID at all (e.g., async flows).
//   - ConnectorState: Carries session-scoped data (e.g., access tokens) that
//                   must be round-tripped by the caller between requests in a
//                   multi-step flow.
//
// Versioning:
//   Field numbers are stable and must never be reused once reserved or deleted.
//   Any removed field must be listed in a `reserved` statement. Enum zero values
//   follow the convention `ENUM_NAME_UNSPECIFIED = 0` to distinguish an unset
//   field from a meaningful value.
//
// Related Files:
//   - services.proto      — gRPC service definitions
//   - payment_methods.proto — Payment method data types and SecretString

syntax = "proto3";

package ucs.v2;

import "google/protobuf/empty.proto";
import "payment_methods.proto";

option go_package = "github.com/juspay/connector-service/backend/grpc-api-types/proto;proto";

// ============================================================================
// CORE DATA TYPES
// ============================================================================

// Money represents a monetary amount with currency
// All amounts are in minor units (e.g., cents for USD)
message Money {
  int64 minor_amount = 1;  // Amount in minor units (e.g., 1000 = $10.00)
  Currency currency = 2;       // ISO 4217 currency code (e.g., "USD", "EUR")
}

// ErrorInfo provides structured error information for API responses
message ErrorInfo {
  optional UnifiedErrorDetails unified_details = 1;                    // Machine-readable error code
  optional IssuerErrorDetails issuer_details = 2;                 // Human-readable error message
  optional ConnectorErrorDetails connector_details = 3;                 // Detailed explanation
}

message UnifiedErrorDetails {
  optional string code = 1;                    // Machine-readable error code
  optional string message = 2;                 // Human-readable error message
  optional string description = 3;                 // Detailed explanation
  optional string user_guidance_message = 4; // User-facing message with guidance on next steps
}

// IssuerErrorDetails provides structured error information specific to card issuer responses
message IssuerErrorDetails {
  optional string code = 1;                    // Machine-readable error code
  optional string message = 2;                 // Human-readable error message
  optional NetworkErrorDetails network_details = 4;               // Network-specific error details, if applicable
}

message NetworkErrorDetails {
  optional string advice_code = 1;     // Network advice code for retry logic
  optional string decline_code = 2;    // Card scheme decline code
  optional string error_message = 3;   // Network-specific error details
}

message ConnectorErrorDetails {
  optional string code = 1;                    // Connector-specific error code
  optional string message = 2;                 // Human-readable error message
  optional string reason = 3;             // Detailed explanation
}

// Metadata consolidates all metadata types
message Metadata {
  SecretString general = 1;      // General metadata
  SecretString connector = 2;    // Connector-specific metadata
  SecretString merchant_account = 3;     // Merchant account metadata
}

// Represents an identifier, which can be one of several types.
message Identifier {
  oneof id_type {
    // Connector's transaction ID.
    string id = 1;

    // Encoded data representing the ID or related information.
    string encoded_data = 2;

    // Indicates that no specific ID is returned or applicable.
    google.protobuf.Empty no_response_id_marker = 3;
  }
}

message Customer {
    optional string name = 1;            // Customer's full name
    optional SecretString email = 2;           // Customer's email address
    optional string id = 3;              // Internal customer ID
    optional string connector_id = 4;    // Customer ID in the connector system
    optional string phone_number = 5;    // Customer's phone number
}

// ============================================================================
// COMMON MESSAGES
// ============================================================================

// HTTP methods
enum HttpMethod {
  HTTP_METHOD_UNSPECIFIED = 0; // Default, unspecified HTTP method.
  HTTP_METHOD_GET = 1;                     // HTTP GET method.
  HTTP_METHOD_POST = 2;                    // HTTP POST method.
  HTTP_METHOD_PUT = 3;                     // HTTP PUT method.
  HTTP_METHOD_DELETE = 4;                  // HTTP DELETE method.
}

// Status of a payment attempt
enum PaymentStatus {
  ATTEMPT_STATUS_UNSPECIFIED = 0; // Default value

  // Initial states
  STARTED = 1;
  PAYMENT_METHOD_AWAITED = 22;    // Waiting for customer to provide payment method
  DEVICE_DATA_COLLECTION_PENDING = 24; // Waiting for device data collection
  CONFIRMATION_AWAITED = 23;      // Waiting for customer confirmation

  // Authentication flow
  AUTHENTICATION_PENDING = 4;
  AUTHENTICATION_SUCCESSFUL = 5;
  AUTHENTICATION_FAILED = 2;

  // Authorization flow
  AUTHORIZING = 9;
  AUTHORIZED = 6;
  AUTHORIZATION_FAILED = 7;
  PARTIALLY_AUTHORIZED = 25;

  // Charging flow
  CHARGED = 8;
  PARTIAL_CHARGED = 17;
  PARTIAL_CHARGED_AND_CHARGEABLE = 18; // Partially charged, remaining amount can be captured
  AUTO_REFUNDED = 16;

  // Capture flow
  CAPTURE_INITIATED = 13;
  CAPTURE_FAILED = 14;

  // Void flow
  VOID_INITIATED = 12;
  VOIDED = 11;
  VOID_FAILED = 15;
  VOIDED_POST_CAPTURE = 57;

  // Other payment flows
  COD_INITIATED = 10; // Cash on Delivery initiated
  EXPIRED = 26; // Payment expired before it could be captured

  // Terminal/fallback states
  ROUTER_DECLINED = 3;
  PENDING = 20;       // General pending state
  FAILURE = 21;       // General failure state
  UNRESOLVED = 19;    // Status could not be determined
}

// Status of a payment authorization
enum AuthorizationStatus {
  AUTHORIZATION_STATUS_UNSPECIFIED = 0; // Default value
  AUTHORIZATION_SUCCESS = 1;
  AUTHORIZATION_FAILURE = 2;
  AUTHORIZATION_PROCESSING = 3;
  AUTHORIZATION_UNRESOLVED = 4;
}

// Status of generic operations (non-payment specific).
enum OperationStatus {
  OPERATION_STATUS_UNSPECIFIED = 0; // Default value
  OPERATION_STATUS_SUCCESS = 1;     // Operation completed successfully
  OPERATION_STATUS_FAILURE = 2;     // Operation failed
  OPERATION_STATUS_PENDING = 3;     // Operation is in progress
  OPERATION_STATUS_AUTHENTICATION_FAILED = 4; // Authentication/authorization failed
  OPERATION_STATUS_RATE_LIMITED = 5; // Rate limit exceeded
  OPERATION_STATUS_INVALID_REQUEST = 6; // Invalid request parameters
}

// Status of a refund
enum RefundStatus {
  REFUND_STATUS_UNSPECIFIED = 0; // Default value
  REFUND_FAILURE = 1;
  REFUND_MANUAL_REVIEW = 2;      // Refund requires manual review
  REFUND_PENDING = 3;
  REFUND_SUCCESS = 4;
  REFUND_TRANSACTION_FAILURE = 5; // Failure at the transaction level for the refund
}

// Status of a dispute
enum DisputeStatus {
  DISPUTE_STATUS_UNSPECIFIED = 0; // Default value
  DISPUTE_OPENED = 1;
  DISPUTE_EXPIRED = 2;
  DISPUTE_ACCEPTED = 3;
  DISPUTE_CANCELLED = 4;
  DISPUTE_CHALLENGED = 5;         // Dispute is being challenged with evidence
  DISPUTE_WON = 6;
  DISPUTE_LOST = 7;
}

// Status of a mandate
enum MandateStatus {
  MANDATE_STATUS_UNSPECIFIED = 0; // Default value
  MANDATE_PENDING = 1;
  ACTIVE = 2;
  MANDATE_INACTIVE = 3;
  REVOKED = 4;
  MANDATE_REVOKE_FAILED = 5;
}

// Method for capturing a payment
enum CaptureMethod {
  CAPTURE_METHOD_UNSPECIFIED = 0; // Default value
  AUTOMATIC = 1;                  // Capture is done automatically after authorization.
  MANUAL = 2;                     // Capture must be triggered manually.
  MANUAL_MULTIPLE = 3;            // Multiple manual captures are possible.
  SCHEDULED = 4;                  // Capture is scheduled for a later time.
  SEQUENTIAL_AUTOMATIC = 5;       // Sequential automatic captures.
}

// Indicates how a payment method might be used in the future
enum FutureUsage {
  FUTURE_USAGE_UNSPECIFIED = 0;   // Default value
  OFF_SESSION = 1;                // For merchant-initiated transactions (e.g., subscriptions).
  ON_SESSION = 2;                 // For customer-initiated transactions.
}

// Indicates the category of MIT
enum MitCategory {
  MIT_CATEGORY_UNSPECIFIED = 0;   // Default value
  // A fixed purchase amount split into multiple scheduled payments until the total is paid.
  INSTALLMENT_MIT = 1;
  // Merchant-initiated transaction using stored credentials, but not tied to a fixed schedule
  UNSCHEDULED_MIT = 2;
  // Merchant-initiated payments that happen at regular intervals (usually the same amount each time).
  RECURRING_MIT = 3;
  // A retried MIT after a previous transaction failed or was declined.
  RESUBMISSION_MIT = 4;
}

// Indicates the type of payment sync request
enum SyncRequestType {
  SYNC_REQUEST_TYPE_UNSPECIFIED = 0;   // Default value
  SINGLE_PAYMENT_SYNC = 1;
  MULTIPLE_CAPTURE_SYNC = 2;
}

// Type of acceptance
enum AcceptanceType {
  ACCEPTANCE_TYPE_UNSPECIFIED = 0; // Default value
  ONLINE = 1;                      // Acceptance was given online.
  OFFLINE = 2;                     // Acceptance was given offline.
}

// Type of authentication used for a payment
enum AuthenticationType {
  AUTHENTICATION_TYPE_UNSPECIFIED = 0; // Default value
  THREE_DS = 1;                        // 3D Secure authentication.
  NO_THREE_DS = 2;                     // No 3D Secure, or 3DS explicitly bypassed.
}

// Indicates if 3DS method data was successfully completed
enum ThreeDsCompletionIndicator {
  THREE_DS_COMPLETION_INDICATOR_UNSPECIFIED = 0; // Default value
  THREE_DS_COMPLETION_INDICATOR_SUCCESS = 1; // 3DS method successfully completed ("Y")
  THREE_DS_COMPLETION_INDICATOR_FAILURE = 2; // 3DS method was not successful ("N")
  THREE_DS_COMPLETION_INDICATOR_NOT_AVAILABLE = 3; // 3DS method URL was unavailable ("U")
}

// Transaction status from authentication/verification process
enum TransactionStatus {
  TRANSACTION_STATUS_UNSPECIFIED = 0; // Default value
  // Authentication/Account Verification Successful
  TRANSACTION_STATUS_SUCCESS = 1;        // "Y"

  // Not Authenticated/Account Not Verified; Transaction denied
  TRANSACTION_STATUS_FAILURE = 2;        // "N"

  // Authentication/Account Verification Could Not Be Performed; Technical or other problem
  TRANSACTION_STATUS_VERIFICATION_NOT_PERFORMED = 3; // "U"

  // Attempts Processing Performed; Not Authenticated/Verified, but proof of attempted authentication/verification is provided
  TRANSACTION_STATUS_NOT_VERIFIED = 4;   // "A"

  // Authentication/Account Verification Rejected; Issuer is rejecting authentication/verification
  TRANSACTION_STATUS_REJECTED = 5;       // "R"

  // Challenge Required; Additional authentication is required using the Challenge Request (CReq) / Challenge Response (CRes)
  TRANSACTION_STATUS_CHALLENGE_REQUIRED = 6; // "C"
  // Challenge Required; Decoupled Authentication confirmed
  TRANSACTION_STATUS_CHALLENGE_REQUIRED_DECOUPLED_AUTHENTICATION = 7; // "D"

  // Informational Only; 3DS Requestor challenge preference acknowledged
  TRANSACTION_STATUS_INFORMATION_ONLY = 8; // "I"
}

// SCA (Strong Customer Authentication) exemption indicators.
enum ExemptionIndicator {
  // Unspecified/default value.
  EXEMPTION_INDICATOR_UNSPECIFIED = 0;

  // Low-value payment exemption (below regulatory threshold).
  EXEMPTION_INDICATOR_LOW_VALUE = 1;

  // Secure corporate payment (SCP) exemption.
  EXEMPTION_INDICATOR_SECURE_CORPORATE_PAYMENT = 2;

  // Trusted beneficiary or whitelist exemption.
  EXEMPTION_INDICATOR_TRUSTED_LISTING = 3;

  // Transaction Risk Analysis (TRA) exemption.
  EXEMPTION_INDICATOR_TRANSACTION_RISK_ASSESSMENT = 4;

  // 3DS server or ACS outage exemption.
  EXEMPTION_INDICATOR_THREE_DS_OUTAGE = 5;

  // SCA delegation exemption (authentication delegated to another party).
  EXEMPTION_INDICATOR_SCA_DELEGATION = 6;

  // Out of SCA scope (e.g., one-leg-out transactions).
  EXEMPTION_INDICATOR_OUT_OF_SCA_SCOPE = 7;

  // Other exemption reason not covered by known types.
  EXEMPTION_INDICATOR_OTHER = 8;

  // Low-risk program exemption (network-initiated low-risk flag).
  EXEMPTION_INDICATOR_LOW_RISK_PROGRAM = 9;

  // Recurring transaction exemption (subsequent payment in a series).
  EXEMPTION_INDICATOR_RECURRING_OPERATION = 10;
}

// Preferred payment experience for the customer
enum PaymentExperience {
  PAYMENT_EXPERIENCE_UNSPECIFIED = 0; // Default value
  REDIRECT_TO_URL = 1;                // Redirect customer to a URL.
  INVOKE_SDK_CLIENT = 2;              // Invoke a client-side SDK.
  DISPLAY_QR_CODE = 3;                // Display a QR code.
  ONE_CLICK = 4;                      // One-click payment experience.
  LINK_WALLET = 5;                    // Link a digital wallet.
  INVOKE_PAYMENT_APP = 6;             // Invoke a payment application.
  DISPLAY_WAIT_SCREEN = 7;            // Display a waiting screen.
  COLLECT_OTP = 8;                    // Collect an OTP from the customer.
}

// Channel through which the payment was initiated
enum PaymentChannel {
  PAYMENT_CHANNEL_UNSPECIFIED = 0; // Default value
  ECOMMERCE = 1;
  MAIL_ORDER = 2;
  TELEPHONE_ORDER = 3;
}

// Type of event that a webhook can represent
enum WebhookEventType {
  WEBHOOK_EVENT_TYPE_UNSPECIFIED = 0; // Default unspecified event

  // Payment intent events
  PAYMENT_INTENT_FAILURE = 1;              // Authorization + Capture failure
  PAYMENT_INTENT_SUCCESS = 2;              // Authorization + Capture success
  PAYMENT_INTENT_PROCESSING = 3;           // Payment intent is processing
  PAYMENT_INTENT_PARTIALLY_FUNDED = 4;     // Payment intent is partially funded
  PAYMENT_INTENT_CANCELLED = 5;            // Payment intent cancelled
  PAYMENT_INTENT_CANCEL_FAILURE = 6;       // Payment intent cancel failure
  PAYMENT_INTENT_AUTHORIZATION_SUCCESS = 7; // Authorization success
  PAYMENT_INTENT_AUTHORIZATION_FAILURE = 8; // Authorization failure
  PAYMENT_INTENT_CAPTURE_SUCCESS = 9;      // Capture success
  PAYMENT_INTENT_CAPTURE_FAILURE = 10;     // Capture failure
  PAYMENT_INTENT_EXPIRED = 11;             // Payment intent expired
  PAYMENT_ACTION_REQUIRED = 12;            // Payment requires additional action

  SOURCE_CHARGEABLE = 13;                  // Source is chargeable
  SOURCE_TRANSACTION_CREATED = 14;         // Source transaction created

  // Refund events
  WEBHOOK_REFUND_FAILURE = 15;                     // Refund failure
  WEBHOOK_REFUND_SUCCESS = 16;                     // Refund success

  // Dispute events
  WEBHOOK_DISPUTE_OPENED = 17;                     // Dispute opened
  WEBHOOK_DISPUTE_EXPIRED = 18;                    // Dispute expired
  WEBHOOK_DISPUTE_ACCEPTED = 19;                   // Dispute accepted
  WEBHOOK_DISPUTE_CANCELLED = 20;                  // Dispute cancelled
  WEBHOOK_DISPUTE_CHALLENGED = 21;                 // Dispute challenged
  WEBHOOK_DISPUTE_WON = 22;                        // Dispute successfully challenged by merchant
  WEBHOOK_DISPUTE_LOST = 23;                       // Dispute unsuccessfully challenged

  // Mandate events
  MANDATE_ACTIVE = 24;                     // Mandate is active
  MANDATE_REVOKED = 25;                    // Mandate revoked

  // Misc events
  ENDPOINT_VERIFICATION = 26;              // Endpoint verification
  EXTERNAL_AUTHENTICATION_ARES = 27;       // External authentication ARes
  FRM_APPROVED = 28;                       // Fraud risk management approved
  FRM_REJECTED = 29;                       // Fraud risk management rejected

  // Payout events
  PAYOUT_SUCCESS = 30;                     // Payout success
  PAYOUT_FAILURE = 31;                     // Payout failure
  PAYOUT_PROCESSING = 32;                  // Payout processing
  PAYOUT_CANCELLED = 33;                   // Payout cancelled
  PAYOUT_CREATED = 34;                     // Payout created
  PAYOUT_EXPIRED = 35;                     // Payout expired
  PAYOUT_REVERSED = 36;                    // Payout reversed

  // Recovery events
  RECOVERY_PAYMENT_FAILURE = 37;           // Recovery payment failure
  RECOVERY_PAYMENT_SUCCESS = 38;           // Recovery payment success
  RECOVERY_PAYMENT_PENDING = 39;           // Recovery payment pending
  RECOVERY_INVOICE_CANCEL = 40;            // Recovery invoice cancelled
}

// Currency codes (ISO 4217)
// Note: Using enum for type safety. Consider string for flexibility.
enum Currency {
  CURRENCY_UNSPECIFIED = 0;
  AED = 1; AFN = 2; ALL = 3; AMD = 4; ANG = 5; AOA = 6; ARS = 7; AUD = 8;
  AWG = 9; AZN = 10; BAM = 11; BBD = 12; BDT = 13; BGN = 14; BHD = 15;
  BIF = 16; BMD = 17; BND = 18; BOB = 19; BRL = 20; BSD = 21; BTN = 22;
  BWP = 23; BYN = 24; BZD = 25; CAD = 26; CDF = 27; CHF = 28; CLF = 29;
  CLP = 30; CNY = 31; COP = 32; CRC = 33; CUC = 34; CUP = 35; CVE = 36;
  CZK = 37; DJF = 38; DKK = 39; DOP = 40; DZD = 41; EGP = 42; ERN = 43;
  ETB = 44; EUR = 45; FJD = 46; FKP = 47; GBP = 48; GEL = 49; GHS = 50;
  GIP = 51; GMD = 52; GNF = 53; GTQ = 54; GYD = 55; HKD = 56; HNL = 57;
  HRK = 58; HTG = 59; HUF = 60; IDR = 61; ILS = 62; INR = 63; IQD = 64;
  IRR = 65; ISK = 66; JMD = 67; JOD = 68; JPY = 69; KES = 70; KGS = 71;
  KHR = 72; KMF = 73; KPW = 74; KRW = 75; KWD = 76; KYD = 77; KZT = 78;
  LAK = 79; LBP = 80; LKR = 81; LRD = 82; LSL = 83; LYD = 84; MAD = 85;
  MDL = 86; MGA = 87; MKD = 88; MMK = 89; MNT = 90; MOP = 91; MRU = 92;
  MUR = 93; MVR = 94; MWK = 95; MXN = 96; MYR = 97; MZN = 98; NAD = 99;
  NGN = 100; NIO = 101; NOK = 102; NPR = 103; NZD = 104; OMR = 105; PAB = 106;
  PEN = 107; PGK = 108; PHP = 109; PKR = 110; PLN = 111; PYG = 112; QAR = 113;
  RON = 114; RSD = 115; RUB = 116; RWF = 117; SAR = 118; SBD = 119; SCR = 120;
  SDG = 121; SEK = 122; SGD = 123; SHP = 124; SLE = 125; SLL = 126; SOS = 127;
  SRD = 128; SSP = 129; STD = 130; STN = 131; SVC = 132; SYP = 133; SZL = 134;
  THB = 135; TJS = 136; TMT = 137; TND = 138; TOP = 139; TRY = 140; TTD = 141;
  TWD = 142; TZS = 143; UAH = 144; UGX = 145; USD = 146; UYU = 147; UZS = 148;
  VES = 149; VND = 150; VUV = 151; WST = 152; XAF = 153; XCD = 154; XOF = 155;
  XPF = 156; YER = 157; ZAR = 158; ZMW = 159; ZWL = 160;
}

// Connector enumeration
enum Connector {
  CONNECTOR_UNSPECIFIED = 0; // Default value
  ADYENPLATFORM = 1; ACI = 2; ADYEN = 3; AIRWALLEX = 4; AUTHORIZEDOTNET = 5;
  BAMBORA = 6; BAMBORAAPAC = 7; BANKOFAMERICA = 8; BILLWERK = 9; BITPAY = 10;
  BLUESNAP = 11; BOKU = 12; BRAINTREE = 13; CASHTOCODE = 14; CHARGEBEE = 15;
  CHECKOUT = 16; COINBASE = 17; COINGATE = 18; CRYPTOPAY = 19; CTP_MASTERCARD = 20;
  CTP_VISA = 21; CYBERSOURCE = 22; DATATRANS = 23; DEUTSCHEBANK = 24; DIGITALVIRGO = 25;
  DLOCAL = 26; EBANX = 27; ELAVON = 28; FISERV = 29; FISERVEMEA = 30; FIUU = 31;
  FORTE = 32; GETNET = 33; GLOBALPAY = 34; GLOBEPAY = 35; GOCARDLESS = 36;
  GPAYMENTS = 37; HIPAY = 38; HELCIM = 39; INESPAY = 40; IATAPAY = 41; ITAUBANK = 42;
  JPMORGAN = 43; JUSPAYTHREEDSSERVER = 44; KLARNA = 45; MIFINITY = 46; MOLLIE = 47;
  MONERIS = 48; MULTISAFEPAY = 49; NETCETERA = 50; NEXINETS = 51; NEXIXPAY = 52;
  NMI = 53; NOMUPAY = 54; NOON = 55; NOVALNET = 56; NUVEI = 57; OPENNODE = 58;
  PAYBOX = 59; PAYME = 60; PAYONE = 61; PAYPAL = 62; PAYSTACK = 63; PAYU = 64;
  PLACETOPAY = 65; POWERTRANZ = 66; PROPHETPAY = 67; RAPYD = 68; RAZORPAY = 69;
  RECURLY = 70; REDSYS = 71; SHIFT4 = 72; SQUARE = 73; STAX = 74; STRIPE = 75;
  TAXJAR = 76; THREEDSECUREIO = 77; TRUSTPAY = 78; TSYS = 79; VOLT = 80;
  WELLSFARGO = 81; WISE = 82; WORLDLINE = 83; WORLDPAY = 84; WORLDPAYVANTIV = 85;
  SIGNIFYD = 86; PLAID = 87; RISKIFIED = 88; XENDIT = 89; ZEN = 90; ZSL = 91;
  PHONEPE = 92; CASHFREE = 93; PAYTM = 94; CALIDA = 95; PAYLOAD = 96; AUTHIPAY = 97;
  SILVERFLOW = 98; CELERO = 99; TRUSTPAYMENTS = 100; PAYSAFE = 101; BARCLAYCARD = 102;
  WORLDPAYXML = 103; REVOLUT = 104; LOONIO = 105; GIGADAT = 106; HYPERPG = 107; ZIFT = 108;
}

// Payment method types
enum PaymentMethodType {
  PAYMENT_METHOD_TYPE_UNSPECIFIED = 0; // Default value
  ACH = 1; AFFIRM = 2; AFTERPAY_CLEARPAY = 3; ALFAMART = 4; ALI_PAY = 5;
  ALI_PAY_HK = 6; ALMA = 7; AMAZON_PAY = 8; APPLE_PAY = 9; ATOME = 10;
  BACS = 11; BANCONTACT_CARD = 12; BECS = 13; BENEFIT = 14; BIZUM = 15;
  BLIK = 16; BOLETO = 17; BCA_BANK_TRANSFER = 18; BNI_VA = 19; BRI_VA = 20;
  CARD_REDIRECT = 21; CIMB_VA = 22; CLASSIC_REWARD = 23; CREDIT = 24; CRYPTO_CURRENCY = 25;
  CASHAPP = 26; DANA = 27; DANAMON_VA = 28; DEBIT = 29; DUIT_NOW = 30;
  EFECTY = 31; EFT = 32; EPS = 33; FPS = 34; EVOUCHER = 35; GIROPAY = 36;
  GIVEX = 37; GOOGLE_PAY = 38; GO_PAY = 39; GCASH = 40; IDEAL = 41;
  INTERAC = 42; INDOMARET = 43; KAKAO_PAY = 44; LOCAL_BANK_REDIRECT = 45; MANDIRI_VA = 46;
  KNET = 47; MB_WAY = 48; MOBILE_PAY = 49; MOMO = 50; MOMO_ATM = 51;
  MULTIBANCO = 52; ONLINE_BANKING_THAILAND = 53; ONLINE_BANKING_CZECH_REPUBLIC = 54;
  ONLINE_BANKING_FINLAND = 55; ONLINE_BANKING_FPX = 56; ONLINE_BANKING_POLAND = 57;
  ONLINE_BANKING_SLOVAKIA = 58; OXXO = 59; PAGO_EFECTIVO = 60; PERMATA_BANK_TRANSFER = 61;
  OPEN_BANKING_UK = 62; PAY_BRIGHT = 63; PAZE = 64; PIX = 65; PAY_SAFE_CARD = 66;
  PRZELEWY24 = 67; PROMPT_PAY = 68; PSE = 69; RED_COMPRA = 70; RED_PAGOS = 71;
  SAMSUNG_PAY = 72; SEPA = 73; SEPA_BANK_TRANSFER = 74; SOFORT = 75; SWISH = 76;
  TOUCH_N_GO = 77; TRUSTLY = 78; TWINT = 79; UPI_COLLECT = 80; UPI_INTENT = 81;
  UPI_QR = 82; VIPPS = 83; VIET_QR = 84; VENMO = 85; WALLEY = 86;
  WE_CHAT_PAY = 87; SEVEN_ELEVEN = 88; LAWSON = 89; MINI_STOP = 90; FAMILY_MART = 91;
  SEICOMART = 92; PAY_EASY = 93; LOCAL_BANK_TRANSFER = 94; OPEN_BANKING_PIS = 95;
  DIRECT_CARRIER_BILLING = 96; INSTANT_BANK_TRANSFER = 97; PAY_PAL = 98; REVOLUT_PAY = 99;
  INSTANT_BANK_TRANSFER_FINLAND = 100; INSTANT_BANK_TRANSFER_POLAND = 101;
}

// Product type enumeration
enum ProductType {
  PRODUCT_TYPE_UNSPECIFIED = 0; // Default value
  PHYSICAL = 1;
  DIGITAL = 2;
  TRAVEL = 3;
  RIDE = 4;
  EVENT = 5;
  ACCOMMODATION = 6;
}

// Dispute stage enumeration
enum DisputeStage {
  DISPUTE_STAGE_UNSPECIFIED = 0; // Default value
  PRE_DISPUTE = 1;
  ACTIVE_DISPUTE = 2;
  PRE_ARBITRATION = 3;
}

// Tokenization options for payment processing
enum Tokenization {
  TOKENIZATION_UNSPECIFIED = 0; // Default value
  TOKENIZATION_TOKENIZE_AT_PSP = 1;  // Use default tokenization behavior  
  TOKENIZATION_SKIP_PSP = 2;  // Skip PSP-side token creation  
}


// Represents a physical address with contact information
message Address {
  // Personal Information
  optional SecretString first_name = 1;
  optional SecretString last_name = 2;

  // Address Details
  optional SecretString line1 = 3;
  optional SecretString line2 = 4;
  optional SecretString line3 = 5;
  optional SecretString city = 6;
  optional SecretString state = 7;
  optional SecretString zip_code = 8;
  optional CountryAlpha2 country_alpha2_code = 9;

  // Contact Information
  optional SecretString email = 10;
  optional SecretString phone_number = 11;
  optional string phone_country_code = 12;
}

// Details of a single product in an order
message OrderDetailsWithAmount {
  // Name of the product that is being purchased
  string product_name = 1;
  // The quantity of the product to be purchased
  uint32 quantity = 2;
  // Amount per quantity (in minor currency units)
  int64 amount = 3;
  // Tax rate applicable to the product
  optional double tax_rate = 4;
  // Total tax amount (in minor currency units)
  optional int64 total_tax_amount = 5;
  // Indicates if the product requires shipping
  optional bool requires_shipping = 6;
  // The image URL of the product
  optional string product_img_link = 7;
  // ID of the product that is being purchased
  optional string product_id = 8;
  // Category of the product that is being purchased
  optional string category = 9;
  // Sub category of the product that is being purchased
  optional string sub_category = 10;
  // Brand of the product that is being purchased
  optional string brand = 11; 
  // Description for the item
  optional string description = 12;
  // Unit of measure used for the item quantity.
  optional string unit_of_measure = 13;
  // Type of the product that is being purchased
  optional ProductType product_type = 14;
  // The tax code for the product
  optional string product_tax_code = 15;
}

// Access token details
message AccessToken {
  // The token string.
  SecretString token = 1;
  // Expiration timestamp (seconds since epoch)
  optional int64 expires_in_seconds = 2;
  // Token type (e.g., "Bearer", "Basic").
  optional string token_type = 3;
}

// State data for connector storage
message ConnectorState {
  // Access token obtained from connector
  optional AccessToken access_token = 1;
  // Connector's customer ID (e.g., Authorize.net customer profile ID)
  optional string connector_customer_id = 2;
}

// Billing descriptor information
message BillingDescriptor {
  // Customer's billing name
  optional SecretString name = 1;
  // Customer's billing city
  optional SecretString city = 2;
  // Customer's billing phone number
  optional SecretString phone = 3;
  // Complete description that appears on customers' statements
  optional string statement_descriptor = 4;
  // Provides information about a card payment that customers see on their statements
  optional string statement_descriptor_suffix = 5;
  // A reference to be shown on billing description
  optional string reference = 6;
}

// Algorithm used to generate CAVV (Cardholder Authentication Verification Value)
enum CavvAlgorithm {
  CAVV_ALGORITHM_UNSPECIFIED = 0;
  CAVV_ALGORITHM_ZERO = 1;   // "00" — Reserved or unspecified algorithm.
  CAVV_ALGORITHM_ONE = 2;    // "01" — HMAC-based algorithm.
  CAVV_ALGORITHM_TWO = 3;    // "02" — RSA-based algorithm (standard 3DS cryptographic method).
  CAVV_ALGORITHM_THREE = 4;  // "03" — Elliptic Curve algorithm.
  CAVV_ALGORITHM_FOUR = 5;   // "04" — Proprietary algorithm defined by the card network.
  CAVV_ALGORITHM_A = 6;      // "A" — Custom or network-defined algorithm indicator.
}

// Cartes Bancaires network-specific parameters for 3DS
message CartesBancairesParams {
  // Algorithm used to generate the CAVV value.
  CavvAlgorithm cavv_algorithm = 1;

  // Exemption indicator specific to Cartes Bancaires network.
  string cb_exemption = 2;

  // Cartes Bancaires risk score assigned during 3DS authentication.
  int32 cb_score = 3;
}

// Network-level parameters for 3DS processing
message NetworkParams {
  // Parameters specific to Cartes Bancaires network, if applicable.
  optional CartesBancairesParams cartes_bancaires = 1;
}

// Additional authentication data, typically from 3DS
message AuthenticationData {
  // Electronic Commerce Indicator (ECI) from 3DS.
  optional string eci = 1;
  // Cardholder Authentication Verification Value (CAVV).
  optional string cavv = 2;
  // 3DS Server Transaction ID.
  optional Identifier threeds_server_transaction_id = 3;
  
  // 3DS Message Version (e.g., "2.1.0", "2.2.0").
  optional string message_version = 4;
  // Directory Server Transaction ID (DS Trans ID).
  optional string ds_transaction_id = 5;
  // Transaction status from authentication/verification process.
  optional TransactionStatus trans_status = 6;
  // ACS Transaction ID (ACS Trans ID).
  optional string acs_transaction_id = 7;
  // Transaction identifier generated by the 3DS system.
  optional string transaction_id = 8;
  // UCAF (Universal Cardholder Authentication Field) collection indicator.
  optional string ucaf_collection_indicator = 9;
  // SCA exemption indicator for this authentication.
  optional ExemptionIndicator exemption_indicator = 10;
  // Network-specific parameters for 3DS processing.
  optional NetworkParams network_params = 11;
}

// Details of customer acceptance for mandates or terms
message CustomerAcceptance {
  // Type of acceptance (e.g., online, offline).
  AcceptanceType acceptance_type = 1;
  // Timestamp when the acceptance was made (Unix timestamp, seconds since epoch).
  int64 accepted_at = 2;
  // Details if the acceptance was an online mandate.
  optional OnlineMandate online_mandate_details = 3;
}

// Details for an online mandate acceptance
message OnlineMandate {
  // IP address from which the mandate was accepted.
  optional string ip_address = 1;
  // User agent string of the browser used for mandate acceptance.
  string user_agent = 2;
}

// Amount data for mandate
message MandateAmountData {
  Money amount = 1;                // Amount and currency for the mandate (in minor currency units)
  optional int64 start_date = 2;              // Unix timestamp for start date
  optional int64 end_date = 3;                // Unix timestamp for end date
}

// Mandate type with amount details
message MandateType {
  oneof mandate_type {
    // Single use mandate with amount details
    MandateAmountData single_use = 1;

    // Multi use mandate with amount details (for recurring payments)
    MandateAmountData multi_use = 2;
  }
}

// Setup mandate details for payment authorization
message SetupMandateDetails {
  // A way to update the mandate's payment method details
  optional string update_mandate_id = 1;
  // Details of customer acceptance
  optional CustomerAcceptance customer_acceptance = 2;

  // Type of mandate (single_use or multi_use) with amount details
  optional MandateType mandate_type = 3;
}

// Information about the customer's browser
message BrowserInformation {
  // Display Information
  optional uint32 color_depth = 1;
  optional uint32 screen_height = 2;
  optional uint32 screen_width = 3;
  // Browser Settings
  optional bool java_enabled = 4;
  optional bool java_script_enabled = 5;
  optional string language = 6;
  optional int32 time_zone_offset_minutes = 7;

  // Browser Headers
  optional string accept_header = 8;
  optional string user_agent = 9;
  optional string accept_language = 10;
  optional string referer = 11;

  // Device Information
  optional string ip_address = 12;
  optional string os_type = 13;
  optional string os_version = 14;
  optional string device_model = 15;
}

message MandateReferenceId {
  oneof mandate_id_type {
    // mandate_id sent by the connector
    ConnectorMandateReferenceId connector_mandate_id = 1;

    // network_txns_id sent by Issuer to connector, Used for PG agnostic mandate txns along with card data
    string network_mandate_id = 2;

    // network_txns_id sent by Issuer to connector, Used for PG agnostic mandate txns along with network token data
    NetworkTokenWithNTI network_token_with_nti = 3;
  }
}

message ConnectorMandateReferenceId {
  optional string connector_mandate_id = 1;
  optional string payment_method_id = 2;
  optional string connector_mandate_request_reference_id = 3;
}

message NetworkTokenWithNTI {
  string network_transaction_id = 1;
  optional SecretString token_exp_month = 2;
  optional SecretString token_exp_year = 3;
}

// Container for various address types related to a payment
message PaymentAddress {
  Address shipping_address = 1;
  Address billing_address = 2;
}

// Redirection response data
message RedirectionResponse {
  optional string params = 1;
  map<string, string> payload = 2;
}

// Data for a redirection, can be either form data, raw HTML, or URI.
message RedirectForm {
  oneof form_type {
    // Data for constructing an HTML form for redirection.
    FormData form = 1;
    // Raw HTML data for redirection.
    HtmlData html = 2;

    // URI for direct redirection (e.g., UPI deep links).
    UriData uri = 3;

    // Braintree-specific redirection data for SDK-based flows.  
    BraintreeData braintree = 4;

    // Mifinity-specific redirection data for SDK-based flows.  
    MifinityData mifinity = 5;
  }
}

// Represents data for an HTML form to be submitted
message FormData {
// The endpoint URL where the form should be submitted.
  string endpoint = 1;

  // HTTP method to be used for form submission (e.g., POST).
  HttpMethod method = 2;

  // Key-value pairs representing the form fields.
  map<string, string> form_fields = 3;
}

// Represents raw HTML data
message HtmlData {
  // The HTML content as a string.
  string html_data = 1;
}

// Represents URI data for direct redirection
message UriData {
  // The URI for redirection (e.g., UPI deep link).
  string uri = 1;
}

// Represents Braintree-specific redirection data
message BraintreeData {
  // Client token for Braintree SDK initialization  
  string client_token = 1;  
    
  // Tokenized payment method identifier  
  string card_token = 2;  
    
  // Bank Identification Number for card verification  
  string bin = 3;  
    
  // URL for completing the authorization flow  
  string acs_url = 4;  
}

// Represents Mifinity-specific redirection data
message MifinityData {
  // Initialization token for Mifinity SDK initialization
  string initialization_token = 1;
}

// Details of an HTTP request, typically for incoming webhooks
message RequestDetails {
  // HTTP method of the request (e.g., GET, POST).
  HttpMethod method = 1;

  // URI of the request.
  optional string uri = 2;

  // Headers of the HTTP request.
  map<string, string> headers = 3;

  // Body of the HTTP request.
  bytes body = 4;

  // Query parameters of the request.
  optional string query_params = 5;
}

// Secrets used for verifying connector webhooks.
message WebhookSecrets {
  // Primary secret for webhook verification.
  string secret = 1;

  // Additional secret, if required by the connector.
  optional string additional_secret = 2;
}

// Secrets used for source verification.
message RedirectResponseSecrets {
  // Primary secret for source verification.
  string secret = 1;

  // Additional secret, if required by the connector.
  optional string additional_secret = 2;
}

// Incomplete transformation response
message IncompleteTransformationResponse {
  // The resource object bytes that should be sent in PSync call
  bytes resource_object = 1;
  // Reason why transformation is incomplete
  string reason = 2;
}

// Content of a Event
message EventResponse {
  oneof content {
    // Content if the event is for a payment synchronization.
    PaymentServiceGetResponse payments_response = 1;
    // Content if the event is for a refund synchronization.
    RefundResponse refunds_response = 2;
    // Content if the event is for a dispute synchronization.
    DisputeResponse disputes_response = 3;
    // Content if the payment event transformation is incomplete and requires psync call.
    IncompleteTransformationResponse incomplete_transformation = 4;
  }
}

// Data for a multiple capture request
message MultipleCaptureRequestData {
  // Sequence number for this capture in a series of multiple captures.
  int64 capture_sequence = 1;
  // Reference for this specific capture.
  string capture_reference = 2;
}

// Type of evidence that can be submitted for a dispute
enum EvidenceType {
  EVIDENCE_TYPE_UNSPECIFIED = 0;              // Default value
  CANCELLATION_POLICY = 1;                    // Cancellation policy document
  CUSTOMER_COMMUNICATION = 2;                 // Communication with customer
  CUSTOMER_SIGNATURE = 3;                     // Customer signature document
  RECEIPT = 4;                                // Receipt or proof of purchase
  REFUND_POLICY = 5;                         // Refund policy document
  SERVICE_DOCUMENTATION = 6;                  // Service documentation
  SHIPPING_DOCUMENTATION = 7;                // Shipping documentation
  INVOICE_SHOWING_DISTINCT_TRANSACTIONS = 8;  // Invoice showing distinct transactions
  RECURRING_TRANSACTION_AGREEMENT = 9;        // Recurring transaction agreement
  UNCATEGORIZED_FILE = 10;                   // Uncategorized evidence file
}

// Represents a single piece of evidence for a dispute
message EvidenceDocument {
    // Type of the evidence.
  EvidenceType evidence_type = 1;
  // Content Options
  // Content of the document, if it's a file.
  optional bytes file_content = 2;
  // MIME type of the file (e.g., "application/pdf", "image/png"), if file_content is provided.
  optional string file_mime_type = 3;
  // Identifier for the file if stored with an external provider.
  optional string provider_file_id = 4;
  // Textual content of the evidence, if it's not a file or in addition to a file.
  optional string text_content = 5;
}

// Extended authorization response data
message ExtendedAuthorizationResponseData {
  optional bool extended_authentication_applied = 1; // Whether extended authentication was applied
  optional int64 capture_before = 2; // Unix timestamp before which capture must occur
  optional int64 extended_authorization_last_applied_at = 3; // Unix timestamp of when extended authentication was last applied
}

// Additional payment method data for card payments
message CardConnectorResponse {
  optional string authentication_data = 1;      // JSON string
  optional string payment_checks = 2;           // JSON string
  optional string card_network = 3; // Card network returned by the processor
  optional string domestic_network = 4; // Domestic (co-branded) card network
  optional string auth_code = 5; // Unique authorisation code generated for the payment
}

// Additional payment method data for Google Pay
message GooglePayConnectorResponse {
  optional string auth_code = 1; // Unique authorisation code generated for the payment
}

// Additional payment method data for Apple Pay
message ApplePayConnectorResponse {
  optional string auth_code = 1; // Unique authorisation code generated for the payment
}

// Additional payment method connector response
message AdditionalPaymentMethodConnectorResponse {
  oneof payment_method_data {
    CardConnectorResponse card = 1; // Card-specific response data
    UpiConnectorResponse upi = 2;  // UPI-specific response data
    GooglePayConnectorResponse google_pay = 3; // Google Pay-specific response data
    ApplePayConnectorResponse apple_pay = 4; // Apple Pay-specific response data
  }
}

// Connector response data containing various information from the connector
message ConnectorResponseData {
  // Additional payment method specific data
  optional AdditionalPaymentMethodConnectorResponse additional_payment_method_data = 1;
  // Extended authorization data
  optional ExtendedAuthorizationResponseData extended_authorization_response_data = 2;
  // Whether overcapture is enabled
  optional bool is_overcapture_enabled = 3;
}

// ============================================================================
// SESSION TOKEN MESSAGES
// ============================================================================

message SessionToken {
  oneof wallet_name {
    GpaySessionTokenResponse google_pay = 1;
    PaypalSessionTokenResponse paypal = 2;
    ApplepaySessionTokenResponse apple_pay = 3;
  }
}

// Google Pay Session Token
message GpaySessionTokenResponse {
  GooglePaySessionResponse google_pay_session = 1;
}

message GooglePayThirdPartySdk {
  bool delayed_session_token = 1;
  string connector = 2;
  SdkNextAction sdk_next_action = 3;
}

message GooglePaySessionResponse {
  GpayMerchantInfo merchant_info = 1;
  bool shipping_address_required = 2;
  bool email_required = 3;
  GpayShippingAddressParameters shipping_address_parameters = 4;
  repeated GpayAllowedPaymentMethods allowed_payment_methods = 5;
  GpayTransactionInfo transaction_info = 6;
  bool delayed_session_token = 7;
  string connector = 8;
  SdkNextAction sdk_next_action = 9;
  optional SecretInfoToInitiateSdk secrets = 10;
}

message GpayMerchantInfo {
  optional string merchant_id = 1;
  string merchant_name = 2;
}

message GpayShippingAddressParameters {
  bool phone_number= 1;
}

message GpayAllowedPaymentMethods {
  string payment_method_type = 1;
  GpayAllowedMethodsParameters parameters = 2;
  GpayTokenizationSpecification tokenization_specification = 3;
}

message GpayAllowedMethodsParameters {
  repeated string allowed_auth_methods = 1;
  repeated string allowed_card_networks = 2;
  optional bool billing_address= 3;
  optional GpayBillingAddressParameters billing_address_parameters = 4;
  optional bool assurance_details= 5;
}

message GpayBillingAddressParameters {
  bool phone_number= 1;
  GpayBillingAddressFormat format = 2;
}

enum GpayBillingAddressFormat {
  BILLING_ADDRESS_FORMAT_UNSPECIFIED = 0;
  BILLING_ADDRESS_FORMAT_FULL = 1;
  BILLING_ADDRESS_FORMAT_MIN = 2;
}

message GpayTokenizationSpecification {
  string token_specification_type = 1;
  GpayTokenParameters parameters = 2;
}

message GpayTokenParameters {
  optional string gateway = 1;
  optional string gateway_merchant_id = 2;
  optional string protocol_version = 3;
  optional SecretString public_key = 4;
}

enum GpayTotalPriceStatus {
  TOTAL_PRICE_STATUS_UNSPECIFIED = 0;
  NOT_CURRENTLY_KNOWN = 1;
  ESTIMATED = 2;
  FINAL = 3;
}

message GpayTransactionInfo {
  CountryAlpha2 country_code = 1;
  Currency currency_code = 2;
  GpayTotalPriceStatus total_price_status = 3;
  int64 total_price = 4;  // Minor units
}

// Apple Pay Session Token
message ApplepaySessionTokenResponse {
  optional ApplePaySessionResponse session_token_data = 1;
  ApplePayPaymentRequest payment_request_data = 2;
  string connector = 3;
  bool delayed_session_token = 4;
  SdkNextAction sdk_next_action = 5;
  optional string connector_reference_id = 6;
  optional string connector_sdk_public_key = 7;
  optional string connector_merchant_id = 8;
}

message ApplePaySessionResponse {
  ThirdPartySdkSessionResponse third_party_sdk = 1;
}

message ThirdPartySdkSessionResponse {
  SecretInfoToInitiateSdk secrets = 1;
}

message NoThirdPartySdkSessionResponse {
  uint64 epoch_timestamp = 1;
  uint64 expires_at = 2;
  string merchant_session_identifier = 3;
  string nonce = 4;
  string merchant_identifier = 5;
  string domain_name = 6;
  string display_name = 7;
  string signature = 8;
  string operational_analytics_identifier = 9;
  uint32 retries = 10;
  string psp_id = 11;
}

message ApplePayPaymentRequest {
  CountryAlpha2 country_code = 1;
  Currency currency_code = 2;
  AmountInfo total = 3;
  repeated string merchant_capabilities = 4;
  repeated string supported_networks = 5;
  optional string merchant_identifier = 6;
}

message AmountInfo {
  string label = 1;
  optional string total_type = 2;
  int64 amount = 3;  // Minor units
}

message ApplePayBillingContactFields {
  repeated ApplePayAddressParameters fields = 1;
}

message ApplePayShippingContactFields {
  repeated ApplePayAddressParameters fields = 1;
}

enum ApplePayAddressParameters {
  APPLE_PAY_ADDRESS_PARAMETERS_UNSPECIFIED = 0;
  POSTAL_ADDRESS = 1;
  PHONE = 2;
  EMAIL = 3;
}

message ApplePayRecurringPaymentRequest {
  string payment_description = 1;
  ApplePayRegularBillingRequest regular_billing = 2;
  optional string billing_agreement = 3;
  string management_url = 4;
}

message ApplePayRegularBillingRequest {
  int64 amount = 1;  // Minor units
  string label = 2;
  ApplePayPaymentTiming payment_timing = 3;
  optional int64 recurring_payment_start_date = 4;
  optional int64 recurring_payment_end_date = 5;
  optional RecurringPaymentIntervalUnit recurring_payment_interval_unit = 6;
  optional int32 recurring_payment_interval_count = 7;
}

enum ApplePayPaymentTiming {
  APPLE_PAY_PAYMENT_TIMING_UNSPECIFIED = 0;
  IMMEDIATE = 1;
  RECURRING = 2;
}

enum RecurringPaymentIntervalUnit {
  RECURRING_PAYMENT_INTERVAL_UNIT_UNSPECIFIED = 0;
  YEAR = 1;
  MONTH = 2;
  DAY = 3;
  HOUR = 4;
  MINUTE = 5;
}

// PayPal Session Token
message PaypalSessionTokenResponse {
  string connector = 1;
  string session_token = 2;
  SdkNextAction sdk_next_action = 3;
  optional string client_token = 4;
  optional PaypalTransactionInfo transaction_info = 5;
}

message PaypalTransactionInfo {
  PaypalFlow flow = 1;
  Currency currency_code = 2;
  int64 total_price = 3;  // Minor units
}

enum PaypalFlow {
  PAYPAL_FLOW_UNSPECIFIED = 0;
  PAYPAL_FLOW_CHECKOUT = 1;
}

// Common Session Token Types
enum SdkNextAction {
  SDK_NEXT_ACTION_UNSPECIFIED = 0;
  SDK_NEXT_ACTION_POST_SESSION_TOKENS = 1;
  SDK_NEXT_ACTION_CONFIRM = 2;
}

message SecretInfoToInitiateSdk {
  SecretString display = 1;
  optional SecretString payment = 2;
}

// ============================================================================
// PAYMENT SERVICE REQUESTS
// ============================================================================

// Request message for creating an access token
message ClientAuthServiceCreateAccessTokenRequest {
  Identifier request_ref_id = 1;
  Connector connector = 2; // The connector to create the access token for
  optional Metadata metadata = 3; // Additional metadata for the request
  
  // Environment Configuration
  optional bool test_mode = 4; // A boolean value to indicate if the connector is in Test mode
}

// Response message for creating an access token
message ClientAuthServiceCreateAccessTokenResponse {
  SecretString access_token = 1; // The access token string
  optional string token_type = 2; // Token type (e.g., "Bearer", "Basic")
  optional int64 expires_in_seconds = 3;// Expiration timestamp of the token (seconds since epoch)
  OperationStatus status = 4;// Status of the access token creation attempt
  optional ErrorInfo error = 5;
  uint32 status_code = 6;// HTTP status code from the connector
  optional Identifier response_ref_id = 7;
}

// Request message for authorizing a payment
message PaymentServiceAuthorizeRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Amount Information (using Money for consistency)
  Money amount = 2;// The amount for the payment
  optional int64 order_tax_amount = 3;// Tax amount for the order
  optional int64 shipping_cost = 4;// Cost of shipping for the order

  // Payment Method and Capture Settings
  PaymentMethod payment_method = 5;// Payment method to be used
  optional CaptureMethod capture_method = 6;// Method for capturing the payment

  // Customer Information
  optional Customer customer = 7;

  // Address Information
  PaymentAddress address = 8;

  // Authentication Details
  AuthenticationType auth_type = 9;
  optional bool enrolled_for_3ds = 10;
  optional AuthenticationData authentication_data = 11;

  // Metadata (consolidated)
  optional Metadata metadata = 12;
  // URLs for Redirection and Webhooks
  optional string return_url = 13;
  optional string webhook_url = 14;
  optional string complete_authorize_url = 15;

  // Session and Token Information
  optional string session_token = 16;

  // Order Details
  optional string order_category = 17;
  optional string merchant_order_reference_id = 18;
  optional string connector_order_reference_id = 19;

  // Behavioral Flags and Preferences
  optional FutureUsage setup_future_usage = 20;
  optional bool off_session = 21;
  optional bool request_incremental_authorization = 22;
  optional bool request_extended_authorization = 23;
  optional bool enable_partial_authorization = 24;

  // Contextual Information
  optional CustomerAcceptance customer_acceptance = 25;
  optional BrowserInformation browser_info = 26;
  optional PaymentExperience payment_experience = 27;
  optional string description = 28;
  optional PaymentChannel payment_channel = 29;

  // Environment Configuration
  optional bool test_mode = 30;

  // Mandate Setup Details
  optional SetupMandateDetails setup_mandate_details = 31;

  // Statement Descriptor
  optional BillingDescriptor billing_descriptor = 32;

  // State Information
  optional ConnectorState state = 33;
  // Order Details
  repeated OrderDetailsWithAmount order_details = 34;

  // Locale Information
  optional string locale = 35;

  // Tokenization configuration
  optional Tokenization tokenization_strategy = 36;
}

// Request message for authorizing a payment only (without setup flows)
message PaymentServiceAuthorizeOnlyRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Amount Information
  Money amount = 2;
  optional int64 order_tax_amount = 3;
  optional int64 shipping_cost = 4;

  // Payment Method and Capture Settings
  PaymentMethod payment_method = 5;
  optional CaptureMethod capture_method = 6;

  // Customer Information
  optional Customer customer = 7;

  // Address Information
  PaymentAddress address = 8;

  // Authentication Details
  AuthenticationType auth_type = 9;
  optional bool enrolled_for_3ds = 10;
  optional AuthenticationData authentication_data = 11;

  // Metadata
  optional Metadata metadata = 12;

  // URLs for Redirection and Webhooks
  optional string return_url = 13;
  optional string webhook_url = 14;
  optional string complete_authorize_url = 15;

  // Session and Token Information
  optional string session_token = 16;

  // Order Details
  optional string order_category = 17;
  optional string merchant_order_reference_id = 18;
  // Behavioral Flags and Preferences
  optional FutureUsage setup_future_usage = 19;
  optional bool off_session = 20;
  optional bool request_incremental_authorization = 21;
  optional bool request_extended_authorization = 22;
  optional bool enable_partial_authorization = 23;

  // Contextual Information
  optional CustomerAcceptance customer_acceptance = 24;
  optional BrowserInformation browser_info = 25;
  optional PaymentExperience payment_experience = 26;
  optional string description = 27;
  optional PaymentChannel payment_channel = 28;
  // Environment Configuration
  optional bool test_mode = 29;

  // Mandate Setup Details
  optional SetupMandateDetails setup_mandate_details = 30;

  // Statement Descriptor
  optional BillingDescriptor billing_descriptor = 31;

  // State Information
  optional ConnectorState state = 32;

  // Order Details
  repeated OrderDetailsWithAmount order_details = 33;

  // Payment Method Token
  optional string payment_method_token = 34;
  // Connector Order Reference
  optional string connector_order_reference_id = 35;

  // Locale Information
  optional string locale = 36;

  // URL for Redirection
  optional string continue_redirection_url = 37;

  // 3DS Completion Indicator
  optional ThreeDsCompletionIndicator threeds_completion_indicator = 38;
  // Redirection Information after DDC step
  optional RedirectionResponse redirection_response = 39;

  // Tokenization configuration
  optional Tokenization tokenization_strategy = 40;
}

// Response message for a payment authorization
message PaymentServiceAuthorizeResponse {
  // Identification
  Identifier transaction_id = 1;

  // Status Information
  PaymentStatus status = 2;
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // Redirection and Transaction Details
  optional RedirectForm redirection_data = 6;
  optional string network_transaction_id = 7;
  optional Identifier response_ref_id = 8;

  // Authorization Details
  optional bool incremental_authorization_allowed = 9;

  // State Information
  optional ConnectorState state = 10;

  // Raw Response/Request for debugging
  optional SecretString raw_connector_response = 11;
  optional SecretString raw_connector_request = 12;

  // Payment Details
  optional int64 captured_amount = 13;
  optional int64 capturable_amount = 14;
  optional int64 authorized_amount = 15;

  // Mandate and Connector Response
  optional MandateReferenceId mandate_reference = 16;
  optional ConnectorResponseData connector_response = 17;
  optional SecretString connector_metadata = 18; // Connector-specific metadata for the transaction
}

// Request message for synchronizing payment status
message PaymentServiceGetRequest {
  // Identification
  Identifier transaction_id = 1;
  optional string encoded_data = 2;

  // Reference
  optional Identifier request_ref_id = 3;

  // Capture Settings
  optional CaptureMethod capture_method = 4;

  optional bytes handle_response = 5;

  // Amount Information
  optional Money amount = 6;

  // Behavioral Flags
  optional FutureUsage setup_future_usage = 7;

  // State Information
  optional ConnectorState state = 8;

  // Metadata
  optional Metadata metadata = 9;

  // Sync Type
  optional SyncRequestType sync_type = 10;

  // Connector Reference Id
  optional string connector_order_reference_id = 11;

  // Environment Configuration
  optional bool test_mode = 12;

  // Payment Experience
  optional PaymentExperience payment_experience = 13;
}

// Response message for a payment status synchronization
message PaymentServiceGetResponse {
  // Identification
  Identifier transaction_id = 1;

  // Status Information
  PaymentStatus status = 2;
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // Transaction Details
  optional MandateReferenceId mandate_reference = 6;
  optional string network_transaction_id = 7;
  optional Identifier response_ref_id = 8;

  // Payment Details
  optional Money amount = 9;
  optional int64 captured_amount = 10; // Captured amount in minor currency units
  optional PaymentMethodType payment_method_type = 11;
  optional CaptureMethod capture_method = 12;
  optional AuthenticationType auth_type = 13;

  // Timestamps
  optional int64 created_at = 14;
  optional int64 updated_at = 15;
  optional int64 authorized_at = 16;
  optional int64 captured_at = 17;
  // Additional Context
  optional string customer_name = 18;
  optional string email = 19;
  optional string connector_customer_id = 20;
  optional string merchant_order_reference_id = 21;
  optional Metadata metadata = 22;
  optional ConnectorResponseData connector_response = 23;

  // State Information
  optional ConnectorState state = 24;

  // Raw Response/Request for debugging
  optional SecretString raw_connector_response = 25;
  optional SecretString raw_connector_request = 26;

  // Redirection and Transaction Details
  optional RedirectForm redirection_data = 27;

  // Capability Flags
  optional bool incremental_authorization_allowed = 28;
}

// Request message for voiding a payment
message PaymentServiceVoidRequest {
  // Identification
  Identifier request_ref_id = 1;
  Identifier transaction_id = 2;

  // Void Details
  optional string cancellation_reason = 3;
  optional bool all_keys_required= 4;

  // Browser Information
  optional BrowserInformation browser_info = 5;
  // Amount Information
  optional Money amount = 6;

  // Metadata
  optional Metadata metadata = 7;

  // State Information
  optional ConnectorState state = 8;

  // Environment Configuration
  optional bool test_mode = 9;
  // Additional Context
  optional string merchant_order_reference_id = 10;
}

// Response message for a payment void operation
message PaymentServiceVoidResponse {
  // Identification
  Identifier transaction_id = 1;

  // Status Information
  PaymentStatus status = 2;
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // Reference
  optional Identifier response_ref_id = 6;

  // State Information
  optional ConnectorState state = 7;

  // Raw Request for debugging
  optional SecretString raw_connector_request = 8;

  // Mandate Details
  optional MandateReferenceId mandate_reference = 9;

  // Authorization Details
  optional bool incremental_authorization_allowed = 10;

  optional SecretString connector_metadata = 11; // Connector-specific metadata for the transaction
}

// Request message for reversing a captured payment if not yet settled (similar to void but for post-capture transactions)
message PaymentServiceReverseRequest {
  // Identification
  Identifier request_ref_id = 1;
  Identifier transaction_id = 2;

  // Reverse Details
  optional string cancellation_reason = 3;
  optional bool all_keys_required= 4;

  // Browser Information
  optional BrowserInformation browser_info = 5;

  // Metadata
  optional Metadata metadata = 6;
}

// Response message for reversing a captured payment if not yet settled (similar to void but for post-capture transactions)
message PaymentServiceReverseResponse {
  // Identification
  Identifier transaction_id = 1;

  // Status Information
  PaymentStatus status = 2;
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // Reference
  optional Identifier response_ref_id = 6;
}

// Request message for SDK session token
message ClientAuthServiceSdkSessionTokenRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Amount Information
  Money amount = 2;
  optional int64 order_tax_amount = 3;
  optional int64 shipping_cost = 4;

  // Payment Method Type
  optional PaymentMethodType payment_method_type = 5;

  optional CountryAlpha2 country_alpha2_code = 6;

  // Customer Information
  optional Customer customer = 7;

  // Metadata
  optional Metadata metadata = 8;
}

// Response message for SDK session token
message ClientAuthServiceSdkSessionTokenResponse {
  SessionToken session_token = 1;
  optional ErrorInfo error = 2;
  uint32 status_code = 3;
  optional SecretString raw_connector_response = 4;
  optional SecretString raw_connector_request = 5;
}

// Request message for capturing a payment
message PaymentServiceCaptureRequest {
  // Identification
  Identifier request_ref_id = 1;
  Identifier transaction_id = 2;

  // Capture Details
  Money amount_to_capture = 3;

  // Metadata
  optional Metadata metadata = 4;

  // Multiple Capture Information
  optional MultipleCaptureRequestData multiple_capture_data = 5;

  // Browser Information
  optional BrowserInformation browser_info = 6;

  // Capture Settings
  optional CaptureMethod capture_method = 7;

  // State Information
  optional ConnectorState state = 8;

  // Environment Configuration
  optional bool test_mode = 9;

  // Additional Context
  optional string merchant_order_reference_id = 10;
}

// Response message for a payment capture operation
message PaymentServiceCaptureResponse {
  // Identification
  Identifier transaction_id = 1;

  // Status Information
  PaymentStatus status = 2;
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // Reference
  optional Identifier response_ref_id = 6;

  // State Information
  optional ConnectorState state = 7;

  // Raw Request for debugging
  optional SecretString raw_connector_request = 8;

  // Payment Details
  optional int64 captured_amount = 9; // Captured amount in minor currency units

  // Mandate Details
  MandateReferenceId mandate_reference = 10;

  // Authorization Details
  optional bool incremental_authorization_allowed = 11;

  optional SecretString connector_metadata = 12; // Connector-specific metadata for the transaction
  
}

// Request message for creating an order
message PaymentServiceCreateOrderRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Amount Information
  Money amount = 2;

  // URLs for Redirection and Webhooks
  optional string webhook_url = 3;

  // Metadata
  Metadata metadata = 4;

  // State Information
  optional ConnectorState state = 5;

  // Environment Configuration
  optional bool test_mode = 6;
}

// Response message for create order operation
message PaymentServiceCreateOrderResponse {
  // Identification
  Identifier order_id = 1; // Identifier for the create order response

  // Status Information
  PaymentStatus status = 2;// Status of the order creation attempt
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // Reference
  optional Identifier response_ref_id = 6;

  // Raw Request/Response for debugging
  optional SecretString raw_connector_request = 7;
  optional SecretString raw_connector_response = 8;
}

// Request message for processing a refund
message PaymentServiceRefundRequest {
  // Identification
  Identifier request_ref_id = 1;
  string refund_id = 2;
  Identifier transaction_id = 3;// Renamed from connector_transaction_id

  // Amount Information
  Money payment_amount = 4;
  int64 refund_amount = 5;// Amount to be refunded, in minor currency units

  // Refund Context
  optional string reason = 6;// Reason for the refund
  optional string webhook_url = 7;// URL for webhook notifications
  optional string merchant_account_id = 8;// Merchant account ID for the refund
  optional CaptureMethod capture_method = 9;// Capture method related to the original payment

  // Metadata
  optional Metadata metadata = 10;// Metadata specific to the connector

  // Browser Information
  optional BrowserInformation browser_info = 11; // Browser information, if relevant  
  // State Information
  optional ConnectorState state = 12;// State data for access token storage and other connector-specific state

  // Environment Configuration
  optional bool test_mode = 13;// A boolean value to indicate if the connector is in Test mode

  // Payment Method Type
  optional PaymentMethodType payment_method_type = 14;// Indicates the sub type of payment method. (e.g., card, bank_redirect, bank_transfer)
  optional string customer_id = 15;// Merchant's customer ID
}

// Response message for a refund operation (unified for both Create and Get)
message RefundResponse {
  // Identification
  Identifier transaction_id = 1;// Identifier for the synchronized resource
  string refund_id = 2;// Connector's ID for the refund

  // Status Information
  RefundStatus status = 3; // Current status of the refund
  optional ErrorInfo error = 4;
  uint32 status_code = 5; // HTTP status code from the connector
  map<string, string> response_headers = 6; // Optional HTTP response headers from the connector

  // Reference
  optional Identifier response_ref_id = 7; // Response reference ID for tracking

  // Refund Details
  optional Money refund_amount = 8;
  optional int64 payment_amount = 9;
  optional string refund_reason = 10; // Reason for the refund

  // Timestamps
  optional int64 created_at = 11; // Unix timestamp when the refund was created
  optional int64 updated_at = 12; // Unix timestamp when the refund was last updated
  optional int64 processed_at = 13; // Unix timestamp when the refund was processed

  // Additional Context
  optional string customer_name = 14; // Name of the customer
  optional SecretString email = 15; // Email address of the customer
  optional string merchant_order_reference_id = 16;
  optional SecretString metadata = 17;
  optional SecretString refund_metadata = 18; // Refund-specific metadata from the connector

  // State Information
  optional ConnectorState state = 19;

  // Raw Response/Request for debugging
  optional SecretString raw_connector_response = 20;
  optional SecretString raw_connector_request = 21;
}

// Request message for creating a dispute
message PaymentServiceDisputeRequest {
  // Identification
  Identifier request_ref_id = 1;
  Identifier transaction_id = 2; // Transaction ID to raise the dispute for
  string dispute_id = 3;  // Connector's unique identifier

  // State Information
  optional ConnectorState state = 4;  // State data for access token storage and other connector-specific state
}

// Response message for dispute operations (unified for both Create and Get)
message DisputeResponse {
  // Identification
  optional string dispute_id = 1;  // Connector's unique identifier for the dispute
  optional Identifier transaction_id = 2; // Transaction ID associated with the dispute

  // Status Information
  optional DisputeStatus dispute_status = 3;
  optional DisputeStage dispute_stage = 4;
  optional string connector_status_code = 5;
  optional ErrorInfo error = 6;
  uint32 status_code = 7;
  map<string, string> response_headers = 8;

  // Dispute Details
  optional Money dispute_amount = 9;
  optional int64 dispute_date = 10;// Unix timestamp
  optional int64 service_date = 11;// Unix timestamp
  optional int64 shipping_date = 12;// Unix timestamp
  optional int64 due_date = 13;// Unix timestamp

  // Evidence
  repeated EvidenceDocument evidence_documents = 14;// Collection of evidence documents submitted

  // Additional Context
  optional string dispute_reason = 15;
  optional string dispute_message = 16;

  // Reference
  optional Identifier response_ref_id = 17;

  // Raw Request for debugging
  optional SecretString raw_connector_request = 18;
}

// Request message for setting up a mandate
message PaymentServiceRegisterAutoDebitRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Mandate Details
  Money amount = 2;
  PaymentMethod payment_method = 3;

  optional Customer customer = 4;
  // Address Information
  PaymentAddress address = 5;

  // Authentication Details
  AuthenticationType auth_type = 6;// Type of authentication to be used
  bool enrolled_for_3ds = 7; // Indicates if the customer is enrolled for 3D Secure
  optional AuthenticationData authentication_data = 8; // Additional authentication data

  // Metadata
  optional Metadata metadata = 9;

  // URLs for Redirection and Webhooks
  optional string return_url = 10; // URL to redirect after setup
  optional string webhook_url = 11; // URL for webhook notifications
  optional string complete_authorize_url = 12; // URL to complete authorization

  // Session and Token Information
  optional string session_token = 13; // Session token, if applicable

  // Order Details
  optional int64 order_tax_amount = 14; // Tax amount, if an initial payment is part of setup
  optional string order_category = 15; // Category of the order/service related to the mandate
  optional string merchant_order_reference_id = 16; // Merchant's internal reference ID
  optional int64 shipping_cost = 17; // Shipping cost, if an initial payment is part of setup

  // Behavioral Flags and Preferences
  optional FutureUsage setup_future_usage = 18; // Indicates future usage intention
  optional bool off_session = 19; // Indicates if off-session process
  bool request_incremental_authorization = 20; // Indicates if incremental authorization is requested
  optional bool request_extended_authorization = 21; // Indicates if extended authorization is requested
  optional bool enable_partial_authorization = 22; // Indicates if partial authorization is enabled

  // Contextual Information
  optional CustomerAcceptance customer_acceptance = 23; // Details of customer acceptance
  optional BrowserInformation browser_info = 24; // Information about the customer's browser
  optional PaymentExperience payment_experience = 25; // Preferred payment experience
  optional PaymentChannel payment_channel = 26; // Describes the channel through which the payment was initiated

  // Billing Descriptor
  optional BillingDescriptor billing_descriptor = 27; // Billing Descriptor information to be sent to the payment gateway

  // State Information
  optional ConnectorState state = 28; // State data for access token storage and other connector-specific state

  // Payment Method Token
  optional string payment_method_token = 29;

  // Send the connector order identifier here if an order was created before authorize
  optional string order_id = 30;

  // Locale Information
  optional string locale = 31;  // Locale/language preference for the shopper (e.g., "en-US")
  // Testing Data
  optional SecretString connector_testing_data = 32;  // Connector-specific testing data (JSON stringified)
}

// Response message for a mandate setup operation
message PaymentServiceRegisterAutoDebitResponse {
  // Identification
  Identifier registration_id = 1; // Identifier for the mandate registration

  // Status Information
  PaymentStatus status = 2; // Status of the mandate setup attempt (using PaymentStatus with mandate values)
  optional ErrorInfo error = 3;
  uint32 status_code = 4; // HTTP status code from the connector
  map<string, string> response_headers = 5; // Optional HTTP response headers from the connector

  // Mandate Details
  MandateReferenceId mandate_reference = 6; // Reference to the created mandate

  // Redirection and Transaction Details
  optional RedirectForm redirection_data = 7; // Data for redirecting the customer's browser
  optional string network_transaction_id = 8; // Renamed from network_transaction_id
  optional Identifier response_ref_id = 9;
  optional ConnectorResponseData connector_response = 10; // Various data regarding the response from connector

  // Authorization Details
  optional bool incremental_authorization_allowed = 11; // Indicates if incremental authorization is allowed

  // Captured Amount Details
  optional int64 captured_amount = 12;  // Captured amount in minor currency units

  // State Information
  optional ConnectorState state = 13; // State data for access token storage and other connector-specific state

  // Raw Request for debugging
  optional string raw_connector_request = 14; // Raw request to the connector for debugging
  optional SecretString connector_metadata = 15; // Connector-specific metadata for the transaction
}

// Request message for repeat payment (MIT - Merchant Initiated Transaction)
message PaymentServiceAutoDebitRequest {
  // Identification
  Identifier request_ref_id = 1; // Reference ID for tracking

  // Mandate Information (for MIT)
  optional MandateReferenceId mandate_reference_id = 2; // Reference to existing mandate

  // Amount Information
  Money amount = 3;

  // Optional payment Method Information (for network transaction flows)
  optional PaymentMethod payment_method = 4;

  // Optional fields
  optional string merchant_order_reference_id = 5;
  optional Metadata metadata = 6;
  optional string webhook_url = 7;
  optional string return_url = 8;
  optional string description = 9;

  // Address Information
  optional PaymentAddress address = 10;

  // Capture Settings
  optional CaptureMethod capture_method = 11;

  // Customer Information
  optional SecretString email = 12;
  optional string connector_customer_id = 13;

  // Browser Information
  optional BrowserInformation browser_info = 14;

  optional bool test_mode = 15;
  optional PaymentMethodType payment_method_type = 16;

  // Merchant Account Configuration
  optional SecretString merchant_account_id = 17;
  optional Currency merchant_configured_currency = 18;

  // Behavioral Flags and Preferences
  optional bool off_session = 19;
  optional bool enable_partial_authorization = 20;

  // State Information
  optional ConnectorState state = 21;

  // Original Payment Details (for reference and validation in MIT flows)
  optional Money original_payment_authorized_amount = 22;

  // Shipping Cost
  optional int64 shipping_cost = 23; // Shipping cost in minor units (e.g., cents)
  // Billing Descriptor
  optional BillingDescriptor billing_descriptor = 24;

  // MIT Category
  optional MitCategory mit_category = 25;

  // Authentication Data
  optional AuthenticationData authentication_data = 26;

  // Locale Information
  optional string locale = 27;

  // Testing Data
  optional SecretString connector_testing_data = 28;
}

// Response message for repeat payment operation
message PaymentServiceAutoDebitResponse {
  // Identification
  Identifier transaction_id = 1;

  // Status Information
  PaymentStatus status = 2;
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // Metadata
  optional SecretString connector_metadata = 6;

  // Transaction Details
  optional string network_transaction_id = 7;
  optional Identifier response_ref_id = 8;
  optional MandateReferenceId mandate_reference = 9;

  // State Information
  optional ConnectorState state = 10;

  // Raw Response/Request for debugging
  optional SecretString raw_connector_response = 11;
  optional SecretString raw_connector_request = 12;

  // Payment Details
  optional int64 captured_amount = 13;  // Captured amount in minor currency units
  optional ConnectorResponseData connector_response = 14;

  // Authorization Details
  optional bool incremental_authorization_allowed = 15;
}

// Request message for a mandate revoke operation
message PaymentServiceRevokeAutoDebitRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Mandate Details
  string mandate_id = 2;
  optional string connector_mandate_id = 3;
}

// Response message for a mandate revoke operation
message PaymentServiceRevokeAutoDebitResponse {
  // Status Information
  MandateStatus status = 1;
  optional ErrorInfo error = 2;
  uint32 status_code = 3;
  map<string, string> response_headers = 4;

  // Transaction Details
  optional string network_transaction_id = 5;
  optional Identifier response_ref_id = 6;

  // Raw Response/Request for debugging
  optional SecretString raw_connector_response = 7;
  optional SecretString raw_connector_request = 8;
}

// ============================================================================
// 3DS AUTHENTICATION FLOW MESSAGES
// ============================================================================

// Request message for pre-authentication step
message ThreeDSAuthServicePreAuthenticateRequest {
  // Payment Identification
  Identifier request_ref_id = 1;

  // Amount Information
  Money amount = 2;

  // Payment Method
  PaymentMethod payment_method = 3;

  // Customer Information
  optional Customer customer = 4;

  // Address Information
  PaymentAddress address = 5;
  // Authentication Details
  bool enrolled_for_3ds = 6;

  // Metadata
  optional Metadata metadata = 7;

  // URLs for Redirection
  optional string return_url = 8;
  optional string continue_redirection_url = 9;

  // Contextual Information
  optional BrowserInformation browser_info = 10;  
  // State Information
  optional ConnectorState state = 11;

  // Capture Settings
  optional CaptureMethod capture_method = 12;

  // Description
  optional string description = 13;
}

// Response message for pre-authentication step
message ThreeDSAuthServicePreAuthenticateResponse {
  // Identification
  Identifier transaction_id = 1;

  // Status Information
  PaymentStatus status = 2;
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // Redirection and Transaction Details
  optional RedirectForm redirection_data = 6;
  optional string network_transaction_id = 7;
  optional Identifier response_ref_id = 8;

  // Metadata
  optional Metadata metadata = 9;

  // State Information
  optional ConnectorState state = 10;

  // Raw Response for debugging
  optional SecretString raw_connector_response = 11;
  // Authentication Results
  optional AuthenticationData authentication_data = 12;
}

// Request message for authentication step
message ThreeDSAuthServiceAuthenticateRequest {
  // Payment Identification
  Identifier request_ref_id = 1;

  // Amount Information
  Money amount = 2;

  // Payment Method
  PaymentMethod payment_method = 3;

  // Customer Information
  optional Customer customer = 4;

  // Address Information
  PaymentAddress address = 5;

  // Authentication Details
  optional AuthenticationData authentication_data = 6;

  // Metadata
  optional Metadata metadata = 7;

  // URLs for Redirection
  optional string return_url = 8;
  optional string continue_redirection_url = 9;

  // Contextual Information
  optional BrowserInformation browser_info = 10;

  // State Information
  optional ConnectorState state = 11;

  // Redirection Information after DDC step
  optional RedirectionResponse redirection_response = 12;

  // Capture Settings
  optional CaptureMethod capture_method = 13;
}

// Response message for authentication step
message ThreeDSAuthServiceAuthenticateResponse {
  // Identification
  Identifier transaction_id = 1;

  // Status Information
  PaymentStatus status = 2;
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // Redirection and Transaction Details
  optional RedirectForm redirection_data = 6;
  optional string network_transaction_id = 7;
  optional Identifier response_ref_id = 8;

  // Authentication Results
  optional AuthenticationData authentication_data = 9;

  // Metadata
  optional SecretString connector_metadata = 10;

  // State Information
  optional ConnectorState state = 11;

  // Raw Response for debugging
  optional SecretString raw_connector_response = 12;
}

// Request message for post-authentication step
message ThreeDSAuthServicePostAuthenticateRequest {
  // Payment Identification
  Identifier request_ref_id = 1;

  // Amount Information
  Money amount = 2;

  // Payment Method
  PaymentMethod payment_method = 3;

  // Customer Information
  optional Customer customer = 4;
  // Address Information
  PaymentAddress address = 5;

  // Authentication Details
  optional AuthenticationData authentication_data = 6;
  optional string connector_order_reference_id = 7;
  // Metadata
  optional Metadata metadata = 8;

  // URLs for Redirection
  optional string return_url = 9;
  optional string continue_redirection_url = 10;

  // Contextual Information
  optional BrowserInformation browser_info = 11;
  // State Information
  optional ConnectorState state = 12;

  // Redirection Information after DDC step
  optional RedirectionResponse redirection_response = 13;
}

// Response message for post-authentication step
message ThreeDSAuthServicePostAuthenticateResponse {
  // Identification
  Identifier transaction_id = 1;

  // Status Information
  PaymentStatus status = 2;
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // Redirection and Transaction Details
  optional RedirectForm redirection_data = 6;
  optional string network_transaction_id = 7;
  optional Identifier response_ref_id = 8;

  // Authentication Results
  optional AuthenticationData authentication_data = 9;

  // Authorization Details
  optional bool incremental_authorization_allowed = 10;

  // Metadata
  optional SecretString connector_metadata = 11;

  // State Information
  optional ConnectorState state = 12;

  // Raw Response for debugging
  optional SecretString raw_connector_response = 13;
}

// Request message for incremental authorization
message PaymentServiceIncrementalAuthorizationRequest {
  // Identification
  Identifier request_ref_id = 1;
  Identifier transaction_id = 2;

  // Amount Information
  Money amount = 3; // new amount to be authorized (in minor currency units)

  // Optional Fields
  optional string reason = 4;

  // Metadata
  optional SecretString connector_metadata = 5;

  // State Information
  optional ConnectorState state = 6;
}

// Response message for incremental authorization
message PaymentServiceIncrementalAuthorizationResponse {
  // Identification
  optional string connector_authorization_id = 1;

  // Status Information
  AuthorizationStatus status = 2;
  optional ErrorInfo error = 3;
  uint32 status_code = 4;
  map<string, string> response_headers = 5;

  // State Information
  optional ConnectorState state = 6;
}

// Request message for creating a session token
message ClientAuthServiceCreateSessionTokenRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Amount Information
  Money amount = 2;

  // Metadata
  optional Metadata metadata = 3;

  // State Information
  optional ConnectorState state = 4;

  // Browser Information
  optional BrowserInformation browser_info = 5;

  optional bool test_mode = 6;
}

// Response message for creating a session token
message ClientAuthServiceCreateSessionTokenResponse {
  // Error Information
  optional ErrorInfo error = 1;
  uint32 status_code = 2;

  // Session Token Details
  string session_token = 3;
}

// Request message for PaymentService.HandleEvent RPC
message PaymentServiceHandleEventRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Request Details
  RequestDetails request_details = 2;

  // Security
  optional WebhookSecrets webhook_secrets = 3;

  // State Information
  optional ConnectorState state = 4;
}

// Status of webhook Event process
enum WebhookEventStatus {
  WEBHOOK_EVENT_STATUS_UNSPECIFIED = 0;
  WEBHOOK_EVENT_STATUS_COMPLETE = 1;
  WEBHOOK_EVENT_STATUS_INCOMPLETE = 2;
}

// Response message for PaymentService.HandleEvent RPC
message PaymentServiceHandleEventResponse {
  // Event type
  WebhookEventType event_type = 1;

  // Content
  PaymentServiceGetResponse payments_response = 2;

  // Verification
  bool source_verified = 3;

  // Reference
  optional Identifier response_ref_id = 4;

  // Event Status
  WebhookEventStatus event_status = 5;
}

// Request message for VerifyRedirectResponse
message PaymentServiceVerifyRedirectResponseRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Request Details
  RequestDetails request_details = 2;

  // Security
  optional RedirectResponseSecrets redirect_response_secrets = 3;
}

// Response message for VerifyRedirectResponse
message PaymentServiceVerifyRedirectResponseResponse {
  // Verification
  bool source_verified = 1;

  // Identification
  optional Identifier transaction_id = 2;

  // Response Amount Information
  optional Money response_amount = 3;

  // Reference
  optional Identifier response_ref_id = 4;

  // Status Information
  optional PaymentStatus status = 5;
  optional ErrorInfo error = 6;

  // Raw Response
  optional SecretString raw_connector_response = 7;
}

// ============================================================================
// REFUND SERVICE MESSAGES
// ============================================================================

// Request message for synchronizing refund status
message RefundServiceGetRequest {
  // Identification
  Identifier request_ref_id = 1;
  Identifier transaction_id = 2;
  string refund_id = 3;

  // Refund Details
  optional string refund_reason = 4;

  // Browser Information
  optional BrowserInformation browser_info = 5;

  // Metadata
  optional Metadata metadata = 6;

  // State Information
  optional ConnectorState state = 7;

  // Environment Configuration
  optional bool test_mode = 8;
  // Payment Method Type
  optional PaymentMethodType payment_method_type = 9;
}

// Request message for RefundService.HandleEvent RPC
message RefundServiceHandleEventRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Request Details
  RequestDetails request_details = 2;

  // Security
  optional WebhookSecrets webhook_secrets = 3;
}

// Response message for RefundService.HandleEvent RPC
message RefundServiceHandleEventResponse {
  // Event Information
  WebhookEventType event_type = 1;

  // Content
  RefundResponse content = 2;

  // Verification
  bool source_verified = 3;

  // Reference
  optional Identifier response_ref_id = 4;
}

// ============================================================================
// DISPUTE SERVICE MESSAGES
// ============================================================================

// Request message for submitting evidence for a dispute
message DisputeServiceSubmitEvidenceRequest {
  // Identification
  Identifier request_ref_id = 1;
  optional Identifier transaction_id = 2;
  string dispute_id = 3;

  // Dates
  optional int64 service_date = 4;
  optional int64 shipping_date = 5;

  // Evidence
  repeated EvidenceDocument evidence_documents = 6; // Collection of evidence documents
}

// Response message for a submit evidence operation
message DisputeServiceSubmitEvidenceResponse {
  // Identification
  optional string dispute_id = 1;
  repeated string submitted_evidence_ids = 2;

  // Status Information
  DisputeStatus dispute_status = 3;
  string connector_status_code = 4;
  optional ErrorInfo error = 5;
  uint32 status_code = 6;
  map<string, string> response_headers = 7;

  // Reference
  optional Identifier response_ref_id = 8;

  // Raw Request for debugging
  optional SecretString raw_connector_request = 9;
}

// Request message for retrieving dispute information
message DisputeServiceGetRequest {
  // Identification
  Identifier request_ref_id = 1;
  optional string dispute_id = 2;
  string connector_dispute_id = 3;
}

// Request message for DisputeService.HandleEvent RPC
message DisputeServiceHandleEventRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Request Details
  RequestDetails request_details = 2;

  // Security
  optional WebhookSecrets webhook_secrets = 3;
}

// Response message for DisputeService.HandleEvent RPC
message DisputeServiceHandleEventResponse {
  // Event Information
  WebhookEventType event_type = 1;

  // Content
  DisputeResponse content = 2;

  // Verification
  bool source_verified = 3;

  // Reference
  optional Identifier response_ref_id = 4;
}

// Request message for defending a dispute
message DisputeServiceDefendRequest {
  // Identification
  Identifier request_ref_id = 1;
  Identifier transaction_id = 2;
  string dispute_id = 3;

  // Defend Details
  optional string reason_code = 4;
}

// Response message for defending a dispute
message DisputeServiceDefendResponse {
  // Identification
  string dispute_id = 1;

  // Status Information
  DisputeStatus dispute_status = 2;
  optional string connector_status_code = 3;
  optional ErrorInfo error = 4;
  uint32 status_code = 5;
  map<string, string> response_headers = 6;

  // Reference
  optional Identifier response_ref_id = 7;

  // Raw Request for debugging
  optional SecretString raw_connector_request = 8;
}

// Request message for accepting a dispute
message DisputeServiceAcceptRequest {
  // Identification
  Identifier request_ref_id = 1;
  Identifier transaction_id = 2;
  string dispute_id = 3;
}

// Response message for accepting a dispute
message DisputeServiceAcceptResponse {
  // Identification
  string dispute_id = 1;

  // Status Information
  DisputeStatus dispute_status = 2;
  optional string connector_status_code = 3;
  optional ErrorInfo error = 4;
  uint32 status_code = 5;
  map<string, string> response_headers = 6;

  // Reference
  optional Identifier response_ref_id = 7;

  // Raw Request for debugging
  optional SecretString raw_connector_request = 8;
}

// ============================================================================
// ADDITIONAL REQUEST/RESPONSE MESSAGES
// ============================================================================

// Request message for creating a payment method token
message PaymentServiceCreatePaymentMethodTokenRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Payment Information
  Money amount = 2;
  PaymentMethod payment_method = 3;

  // Customer Information
  optional Customer customer = 4;

  // Address Information
  optional PaymentAddress address = 5;

  // Metadata
  optional Metadata metadata = 6;

  // URLs for Redirection
  optional string return_url = 7;

  // Environment Configuration
  optional bool test_mode = 8;
}

// Response message for creating a payment method token
message PaymentServiceCreatePaymentMethodTokenResponse {
  // Token Information
  string payment_method_token = 1;

  // Error Information
  optional ErrorInfo error = 2;
  uint32 status_code = 3;
  map<string, string> response_headers = 4;

  // Reference
  optional Identifier response_ref_id = 5;

  // State Information
  optional ConnectorState state = 6;
}

// Request message for creating a connector customer
message PaymentServiceCreateConnectorCustomerRequest {
  // Identification
  Identifier request_ref_id = 1;

  // Customer Information
  optional Customer customer = 2;

  // Address Information
  optional PaymentAddress address = 3;

  // Metadata
  optional Metadata metadata = 4;

  // Environment Configuration
  optional bool test_mode = 5;
}

// Response message for creating a connector customer
message PaymentServiceCreateConnectorCustomerResponse {
  // Customer Information
  string connector_customer_id = 1;

  // Error Information
  optional ErrorInfo error = 2;
  uint32 status_code = 3;
  map<string, string> response_headers = 4;

  // Reference
  optional Identifier response_ref_id = 5;
}
